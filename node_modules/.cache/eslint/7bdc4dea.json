[{"/Users/wawalike/Desktop/ggProject/src/main.ts":"1","/Users/wawalike/Desktop/ggProject/src/App.vue":"2","/Users/wawalike/Desktop/ggProject/src/router/index.ts":"3","/Users/wawalike/Desktop/ggProject/src/store/index.ts":"4","/Users/wawalike/Desktop/ggProject/src/views/wait/index.vue":"5","/Users/wawalike/Desktop/ggProject/src/views/antx/index.vue":"6","/Users/wawalike/Desktop/ggProject/src/views/builderView/index.vue":"7","/Users/wawalike/Desktop/ggProject/src/views/antv/index.vue":"8","/Users/wawalike/Desktop/ggProject/src/components/layout/index.vue":"9"},{"size":205,"mtime":1660722308937,"results":"10","hashOfConfig":"11"},{"size":1126,"mtime":1661131086972,"results":"12","hashOfConfig":"11"},{"size":878,"mtime":1661134348602,"results":"13","hashOfConfig":"11"},{"size":157,"mtime":1656660965482,"results":"14","hashOfConfig":"11"},{"size":342,"mtime":1661130202874,"results":"15","hashOfConfig":"11"},{"size":12160,"mtime":1661139483593,"results":"16","hashOfConfig":"11"},{"size":6555,"mtime":1660873345434,"results":"17","hashOfConfig":"11"},{"size":21374,"mtime":1660896916427,"results":"18","hashOfConfig":"11"},{"size":3109,"mtime":1660787650014,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"1ccpi6e",{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"26","messages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"28","messages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"30","messages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"32","messages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"25"},{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"25"},{"filePath":"40","messages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"25"},"/Users/wawalike/Desktop/ggProject/src/main.ts",[],[],"/Users/wawalike/Desktop/ggProject/src/App.vue",[],[],"/Users/wawalike/Desktop/ggProject/src/router/index.ts",[],"/Users/wawalike/Desktop/ggProject/src/store/index.ts",[],"/Users/wawalike/Desktop/ggProject/src/views/wait/index.vue",[],"/Users/wawalike/Desktop/ggProject/src/views/antx/index.vue",["43","44","45","46","47","48"],"/Users/wawalike/Desktop/ggProject/src/views/builderView/index.vue",["49","50","51","52","53"],"<template>\n  <div class=\"builderView\">\n    <div class=\"builderView_left\">\n      <div\n        v-for=\"item in data.leftData\"\n        :key=\"item.code\"\n        :class=\"{\n          rectangleStyle: item.code == 'rectangle',\n          prismaticStyle: item.code == 'prismatic',\n        }\"\n        @dragstart=\"dragDiv($event, item)\"\n        draggable=\"true\"\n      ></div>\n    </div>\n    <div\n      class=\"builderView_right\"\n      @drop=\"dropEvent(data.currentData)\"\n      @dragover.prevent\n    >\n      <!--  @mousedown=\"mousedownDiv\" -->\n      <div\n        v-for=\"(right, $index) in rightData\"\n        :key=\"$index\"\n        :style=\"{\n          'margin-top': right.code == 'rectangle' && $index != 0 ? '-6px' : '0',\n        }\"\n        :class=\"{\n          rectangleStyle: right.code == 'rectangle',\n          prismaticStyle: right.code == 'prismatic',\n          lineStyle: right.code == 'line',\n          arrowStyle: right.code == 'arrow',\n        }\"\n      >\n        <input\n          type=\"text\"\n          class=\"rightInput\"\n          v-if=\"right.code == 'rectangle'\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent, reactive, ref, Ref, toRefs } from 'vue';\nexport default defineComponent({\n    name: 'builderView',\n    setup(_props,_ctx) {\n        type P = {\n            name: string,\n            code: string,\n            value: string\n        }\n        //reactive设置响应式数据\n        const data = reactive({\n            leftData: [{\n                name: '长方形',\n                code: 'rectangle',\n                value: ''\n            }\n            // ,{\n            //     name: '棱形',\n            //     code: 'prismatic',\n            //     value: ''\n            // }\n            ],\n            clientX: '',//鼠标水平坐标\n            clientY: '',//鼠标垂直坐标\n            offsetLeft: '',//当前拖拽元素左侧偏移距离\n            offsetTop: '',//当前拖拽元素上方偏移距离\n            currentDragDom: '',\n            currentData: {},//当前拖拽数据\n        })\n        //ref设置响应式数据\n        const rightData: Ref<P[]> = ref([]);\n        const dragDiv = (_event: any, item: never) => {\n            data.currentData = item;\n        }\n        const dropEvent = (item:P) => {\n            if(rightData.value.length!=0) {\n                rightData.value.push({\n                    name: '线',\n                    code: 'line',\n                    value: ''\n                },{\n                    name: '箭头',\n                    code: 'arrow',\n                    value: ''\n                })\n            }\n            rightData.value.push(item);\n            console.log(rightData.value);\n        }\n        /**\n         * @description js实现元素拖拽移动\n        */\n        const mousedownDiv = (e:any) => {\n            let offsetWidth = e.target.clientWidth;\n            let offsetHeight = e.target.clientHeight;\n            let parentNodeTop = e.target.parentNode.offsetTop + 20;//父元素上边距离上部距离\n            let parentNodeLeft = e.target.parentNode.offsetLeft + 20;//父元素左边距离左侧距离\n            let parentNodeBottomTop = e.target.parentNode.offsetTop + e.target.parentNode.offsetHeight - offsetHeight - 20;//父元素下边距离上部距离\n            let parentNodeRightLeft = e.target.parentNode.offsetLeft + e.target.parentNode.offsetWidth - offsetWidth - 20;//父元素右边距离左侧距离\n            let clientX = 0;\n            let clientY = 0;\n            document.onmousemove = function(event){\n                clientX = event.clientX;\n                clientY = event.clientY;\n                e.target.style.position = 'absolute';\n                e.target.style.left = ((clientX - offsetWidth/2) < parentNodeLeft)? (parentNodeLeft + \"px\") : ((clientX - offsetWidth/2)>parentNodeRightLeft)?(parentNodeRightLeft + 'px'):((clientX - offsetWidth/2) + \"px\")\n                e.target.style.top = ((clientY - offsetHeight/2) < parentNodeTop)? (parentNodeTop + \"px\") : ((clientY - offsetHeight/2)>parentNodeBottomTop?(parentNodeBottomTop+ 'px'):(clientY - offsetHeight/2) + \"px\")\n            };\n            document.onmouseup = function(){\n                //取消鼠标移动事件\n                document.onmousemove = null;\n                document.onmouseup = null;\n            }\n        }\n        return {\n            data,//reactive定义响应式数据\n            rightData,//ref定义响应式数据：右侧渲染数据\n            dragDiv,//开始拖拽\n            dropEvent,//拖拽接收元素松开被拖拽元素事件\n            mousedownDiv,//js实现元素拖拽（鼠标按下事件）\n        }\n    }\n})\n</script>\n<style lang=\"less\" scoped>\n.builderView {\n  display: flex;\n  height: 100%;\n  .builderView_left {\n    width: 300px;\n    height: 100%;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 20px 0;\n    box-sizing: border-box;\n    .rectangleStyle {\n      width: 100px;\n      height: 50px;\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      margin: 0 auto;\n      cursor: pointer;\n      background-color: #fff;\n    }\n    .prismaticStyle {\n      width: 80px;\n      height: 80px;\n      transform: rotate(45deg);\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      margin: 0 auto;\n      cursor: pointer;\n      background-color: #fff;\n      margin-top: 50px;\n    }\n  }\n  .builderView_right {\n    flex: 1;\n    height: 100%;\n    margin-left: 10px;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 20px;\n    box-sizing: border-box;\n    overflow: auto;\n    .rectangleStyle {\n      width: 100px;\n      min-height: 30px;\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      margin: 0 auto;\n      cursor: pointer;\n      background-color: #fff;\n      // padding: 10px 20px;\n      text-align: center;\n    }\n    .prismaticStyle {\n      width: 100px;\n      height: 100px;\n      transform: rotate(45deg);\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      margin: 0 auto;\n      cursor: pointer;\n      background-color: #fff;\n      text-align: center;\n      margin-top: 13px !important;\n    }\n    .lineStyle {\n      width: 2px;\n      height: 50px;\n      background-color: lightBlue;\n      margin: 0 auto;\n    }\n    .arrowStyle {\n      width: 0;\n      height: 0;\n      border: 6px solid;\n      border-color: lightBlue transparent transparent transparent;\n      margin: 0 auto;\n    }\n    .rightInput {\n      width: 98%;\n      min-height: 30px;\n      border: none;\n      text-align: center;\n    }\n  }\n}\n</style>\n","/Users/wawalike/Desktop/ggProject/src/views/antv/index.vue",["54"],"<template>\n  <div class=\"antv\">\n    <div id=\"container\"></div>\n  </div>\n</template>\n<script>\nimport { defineComponent, onMounted } from \"vue\";\nimport G6 from \"@antv/g6\";\nexport default defineComponent({\n  name: \"antV\",\n  setup() {\n    onMounted(() => {\n      /**\n       * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n       */\n      // let addedCount = 0;\n      // // Register a custom behavior: add a node when user click the blank part of canvas\n      // G6.registerBehavior('click-add-node', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         // The event is canvas:click, the responsing function is onClick\n      //         return {\n      //         'canvas:click': 'onClick',\n      //         };\n      //     },\n      //     // Click event\n      //     onClick(ev) {\n      //         const self = this;\n      //         const graph = self.graph;\n      //         // Add a new node\n      //         graph.addItem('node', {\n      //         x: ev.canvasX,\n      //         y: ev.canvasY,\n      //         id: `node-${addedCount}`, // Generate the unique id\n      //         });\n      //         addedCount++;\n      //     },\n      // });\n      // // Register a custom behavior: click two end nodes to add an edge\n      // G6.registerBehavior('click-add-edge', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         return {\n      //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n      //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n      //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n      //         };\n      //     },\n      //     // The responsing function for node:click defined in getEvents\n      //     onClick(ev) {\n      //         // console.log(1111)\n      //         // console.log(this)\n      //         const self = this;\n      //         const node = ev.item;\n      //         const graph = self.graph;\n      //         // The position where the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         const model = node.getModel();\n      //         if (self.addingEdge && self.edge) {\n      //         graph.updateItem(self.edge, {\n      //             target: model.id,\n      //         });\n\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         } else {\n      //         // Add anew edge, the end node is the current node user clicks\n      //         self.edge = graph.addItem('edge', {\n      //             source: model.id,\n      //             target: model.id,\n      //         });\n      //         self.addingEdge = true;\n      //         }\n      //     },\n      //     // The responsing function for mousemove defined in getEvents\n      //     onMousemove(ev) {\n      //         const self = this;\n      //         // The current position the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         if (self.addingEdge && self.edge) {\n      //         // Update the end node to the current node the mouse clicks\n      //         self.graph.updateItem(self.edge, {\n      //             target: point,\n      //         });\n      //         }\n      //     },\n      //     // The responsing function for edge:click defined in getEvents\n      //     onEdgeClick(ev) {\n      //         const self = this;\n      //         const currentEdge = ev.item;\n      //         if (self.addingEdge && self.edge === currentEdge) {\n      //         self.graph.removeItem(self.edge);\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         }\n      //     },\n      // });\n      // // Initial data\n      // const data = {\n      //     nodes: [\n      //         {\n      //         id: 'node1',\n      //         x: 100,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node2',\n      //         x: 300,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node3',\n      //         x: 300,\n      //         y: 300,\n      //         },\n      //     ],\n      //     edges: [\n      //         {\n      //         id: 'edge1',\n      //         target: 'node2',\n      //         source: 'node1',\n      //         },\n      //     ],\n      // };\n\n      // const container = document.getElementById('container');\n      // // Add a layout 及子元素\n      // const layoutBox = document.createElement('div');\n      // layoutBox.id = 'layoutBox';\n      // const layoutLeft = document.createElement('div');\n      // layoutLeft.id = 'layoutLeft';\n      // const layoutRight = document.createElement('div');\n      // layoutRight.id = 'layoutRight';\n      // // 设置layout样式\n      // layoutBox.style = \"height:100%;display:flex\"\n      // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n      // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n      // // 添加左侧元素\n      // const node = document.createElement('div');\n      // node.value = 'addNode'\n      // node.id = 'nodeId';\n      // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n      // // 添加样式元素到container\n      // layoutBox.appendChild(layoutLeft);\n      // layoutBox.appendChild(layoutRight);\n      // // container.appendChild(layoutBox);\n      // // 添加子元素到左侧\n      // layoutLeft.appendChild(node);\n      // // Add a selector to DOM\n      // const selector = document.createElement('select');\n      // selector.id = 'selector';\n      // selector.style.border = 'none';\n      // const selection1 = document.createElement('option');\n      // selection1.value = 'default';\n      // selection1.innerHTML = 'Default Mode';\n      // const selection2 = document.createElement('option');\n      // selection2.value = 'addNode';\n      // selection2.innerHTML = 'Add Node (By clicking canvas)';\n      // const selection3 = document.createElement('option');\n      // selection3.value = 'addEdge';\n      // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n      // selector.appendChild(selection1);\n      // selector.appendChild(selection2);\n      // selector.appendChild(selection3);\n      // container.appendChild(selector);\n\n      // const width = container.scrollWidth;\n      // const height = (container.scrollHeight || 500) - 30;\n      // const graph = new G6.Graph({\n      // container: 'container',\n      // width,\n      // height,\n      // // The sets of behavior modes\n      // modes: {\n      //     // Defualt mode\n      //     default: ['drag-node', 'click-select'],\n      //     // Adding node mode\n      //     addNode: ['click-add-node', 'click-select'],\n      //     // Adding edge mode\n      //     addEdge: ['click-add-edge', 'click-select'],\n      // },\n      // // The node styles in different states\n      // nodeStateStyles: {\n      //     // The node styles in selected state\n      //     selected: {\n      //         stroke: '#666',\n      //         lineWidth: 2,\n      //         fill: 'steelblue',\n      //     },\n      // },\n      // });\n      // graph.data(data);\n      // graph.render();\n\n      // // Listen to the selector, change the mode when the selector is changed\n      // selector.addEventListener('change', (e) => {\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // // 左侧长方形node元素点击事件\n      // node.addEventListener('click', (e) => {\n      //     console.log(e.target.value)\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n\n      // if (typeof window !== 'undefined')\n      // window.onresize = () => {\n      //     if (!graph || graph.get('destroyed')) return;\n      //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n      //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n      // };\n      // ---------------------------------------------------------------------------------------\n      // G6.Util.processParallelEdges processes the edges with same source node and target node,\n      // on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\n    //   边设置\n      const processParallelEdgesOnAnchorPoint = (\n        edges,\n        offsetDiff = 15,\n        multiEdgeType = \"quadratic\",\n        singleEdgeType = undefined,\n        loopEdgeType = undefined\n      ) => {\n        const len = edges.length;\n        const cod = offsetDiff * 2;\n        const loopPosition = [\n          \"top\",\n          \"top-right\",\n          \"right\",\n          \"bottom-right\",\n          \"bottom\",\n          \"bottom-left\",\n          \"left\",\n          \"top-left\",\n          \"center\"\n        ];\n        const edgeMap = {};\n        const tags = [];\n        const reverses = {};\n        for (let i = 0; i < len; i++) {\n          const edge = edges[i];\n          const { source, target, sourceAnchor, targetAnchor } = edge;\n          const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n\n          if (tags[i]) continue;\n          if (!edgeMap[sourceTarget]) {\n            edgeMap[sourceTarget] = [];\n          }\n          tags[i] = true;\n          edgeMap[sourceTarget].push(edge);\n          for (let j = 0; j < len; j++) {\n            if (i === j) continue;\n            const sedge = edges[j];\n            const {\n              source: src,\n              target: dst,\n              sourceAnchor: srcAnchor,\n              targetAnchor: dstAnchor,\n            } = sedge;\n\n            // 两个节点之间共同的边\n            // 第一条的source = 第二条的target\n            // 第一条的target = 第二条的source\n            if (!tags[j]) {\n              if (\n                source === dst &&\n                sourceAnchor === dstAnchor &&\n                target === src &&\n                targetAnchor === srcAnchor\n              ) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n                reverses[\n                  `${src}|${srcAnchor}|${dst}|${dstAnchor}|${\n                    edgeMap[sourceTarget].length - 1\n                  }`\n                ] = true;\n              } else if (\n                source === src &&\n                sourceAnchor === srcAnchor &&\n                target === dst &&\n                targetAnchor === dstAnchor\n              ) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n              }\n            }\n          }\n        }\n\n        for (const key in edgeMap) {\n          const arcEdges = edgeMap[key];\n          const { length } = arcEdges;\n          for (let k = 0; k < length; k++) {\n            const current = arcEdges[k];\n            if (current.source === current.target) {\n              if (loopEdgeType) current.type = loopEdgeType;\n              // 超过8条自环边，则需要重新处理\n              current.loopCfg = {\n                position: loopPosition[k % 8],\n                dist: Math.floor(k / 8) * 20 + 50,\n              };\n              continue;\n            }\n            if (\n              length === 1 &&\n              singleEdgeType &&\n              (current.source !== current.target ||\n                current.sourceAnchor !== current.targetAnchor)\n            ) {\n              current.type = singleEdgeType;\n              continue;\n            }\n            current.type = multiEdgeType;\n            const sign =\n              (k % 2 === 0 ? 1 : -1) *\n              (reverses[\n                `${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`\n              ]\n                ? -1\n                : 1);\n            if (length % 2 === 1) {\n              current.curveOffset = sign * Math.ceil(k / 2) * cod;\n            } else {\n              current.curveOffset =\n                sign * (Math.floor(k / 2) * cod + offsetDiff);\n            }\n          }\n        }\n        return edges;\n      };\n\n      const data = {\n        // 节点数据\n        nodes: [\n          { id: \"node1\", x: 350, y: 100,label: 'A' },\n          { id: \"node2\", x: 350, y: 250,label: 'B' }\n        ]\n      };\n      // 新增节点按钮\n      const descriptionDiv = document.createElement(\"div\");\n      const container = document.getElementById(\"container\");\n      descriptionDiv.innerText = \"新增节点\";\n      descriptionDiv.style =\n        \"width: 80px;height:34px;line-height:34px;text-align:center;border:1px solid #5ab4be;border-radius:4px;background:#5ab4be;color:#fff;cursor:pointer;margin:0 auto\";\n      container.appendChild(descriptionDiv);\n\n      // custom a node with anchor-point shapes\n      G6.registerNode(\n        \"rect-node\",\n        {\n          // draw anchor-point circles according to the anchorPoints in afterDraw\n          afterDraw(cfg, group) {\n            const bbox = group.getBBox();\n            const anchorPoints = this.getAnchorPoints(cfg);//设置锚点\n            anchorPoints.forEach((anchorPos, i) => {\n              group.addShape(\"circle\", {\n                attrs: {\n                  r: 5,\n                  x: bbox.x + bbox.width * anchorPos[0],\n                  y: bbox.y + bbox.height * anchorPos[1],\n                  fill: \"#fff\",\n                  stroke: \"#5ab4be\",\n                },\n                name: `anchor-point`, // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n                anchorPointIdx: i, // flag the idx of the anchor-point circle\n                links: 0, // cache the number of edges connected to this shape\n                visible: false, // invisible by default, shows up when links > 1 or the node is in showAnchors state\n              });\n            });\n          },\n          getAnchorPoints(cfg) {\n            return (\n              cfg.anchorPoints || [\n                // [0, 0.5],\n                // [0.33, 0],\n                // [0.66, 0],\n                // [1, 0.5],\n                // [0.33, 1],\n                // [0.66, 1],\n              ]\n            );\n          },\n          // response the state changes and show/hide the link-point circles\n          setState(name, value, item) {\n            if (name === \"showAnchors\") {\n              const anchorPoints = item\n                .getContainer()\n                .findAll((ele) => ele.get(\"name\") === \"anchor-point\");\n              anchorPoints.forEach((point) => {\n                if (value || point.get(\"links\") > 0) point.show();\n                else point.hide();\n              });\n            }\n          },\n        },\n        \"rect\"\n      );\n\n      let sourceAnchorIdx, targetAnchorIdx;\n\n      const width = container.scrollWidth;\n      const height = (container.scrollHeight || 500) - 120;\n    //   let beginDom;\n      const graph = new G6.Graph({\n        container: \"container\",\n        width,\n        height,\n        modes: {\n          default: [\n            \"drag-node\",\n            // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n            {\n              type: \"create-edge\",\n            //   点击开始链接\n              shouldBegin: (e) => {\n                console.log('begin',e)\n                // beginDom = e.target;\n                const edges = graph.save().edges;\n                if(edges.length!=0) return false\n                // 避免从节点上的其他形状开始----只点击锚点触发，非锚点终止\n                // if (e.target && e.target.get(\"name\") !== \"anchor-point\")\n                //   return false;\n                sourceAnchorIdx = e.target.get(\"anchorPointIdx\");\n                e.target.set(\"links\", e.target.get(\"links\") + 1); // cache the number of edge connected to this anchor-point circle\n                return true;\n              },\n            //   点击结束链接----只点击锚点触发，非锚点终止\n              shouldEnd: (e) => {\n                console.log('end',e.target)\n                const edges = graph.save().edges;\n                // if(edges.length!=0) return false\n                edges.push({\n                    source: 'node1',\n                    target: 'node2',\n                    label: 'default arrow',\n                    style: {\n                        endArrow: true,\n                    },\n                });\n                processParallelEdgesOnAnchorPoint(edges);\n                //避免在节点上的其他形状处结束\n                // if (e.target && e.target.get(\"name\") !== \"anchor-point\")\n                //   return false;\n                if (e.target) {\n                  targetAnchorIdx = e.target.get(\"anchorPointIdx\");\n                  e.target.set(\"links\", e.target.get(\"links\") + 1); // cache the number of edge connected to this anchor-point circle\n                  return true;\n                }\n                targetAnchorIdx = undefined;\n                return true;\n              },\n              // update the sourceAnchor\n              // getEdgeConfig: () => {\n              //   return {\n              //     sourceAnchor: sourceAnchorIdx\n              //   }\n              // }\n            },\n          ],\n        },\n        defaultNode: {\n          type: \"rect-node\",\n          style: {\n            fill: \"#eee\",\n            stroke: \"#ccc\",\n          },\n        },\n        defaultEdge: {\n          type: \"quadratic\",\n          style: {\n            stroke: \"#F6BD16\",\n            lineWidth: 2,\n          },\n        },\n      });\n\n      graph.data(data);\n      graph.render();\n      // 新增节点按钮事件----新增事件\n      descriptionDiv.addEventListener(\"click\", (e) => {\n          data.nodes.push({ \n              id: \"node\" + data.nodes.length+1,\n            x: data.nodes[data.nodes.length - 1].x,\n            y:  data.nodes[data.nodes.length - 1].y + 50\n        });\n        // 重新绘制\n        graph.data(data);\n        graph.render();\n      });\n      //链接完成事件\n      graph.on(\"aftercreateedge\", (e) => {\n        // update the sourceAnchor and targetAnchor for the newly added edge\n        graph.updateItem(e.edge, {\n          sourceAnchor: sourceAnchorIdx,\n          targetAnchor: targetAnchorIdx,\n        });\n\n        // 更新平行边的curveOffset\n        //设置边(不重叠)\n        const edges = graph.save().edges;\n        processParallelEdgesOnAnchorPoint(edges);\n        graph.getEdges().forEach((edge, i) => {\n          graph.updateItem(edge, {\n            curveOffset: edges[i].curveOffset,\n            curvePosition: edges[i].curvePosition,\n          });\n        });\n      });\n\n      // 如果创建边缘在结束前被取消，更新锚点圆圈上的“链接”\n      graph.on(\"afterremoveitem\", (e) => {\n        if (e.item && e.item.source && e.item.target) {\n          const sourceNode = graph.findById(e.item.source);\n          const targetNode = graph.findById(e.item.target);\n          const { sourceAnchor, targetAnchor } = e.item;\n          if (sourceNode && !isNaN(sourceAnchor)) {\n            const sourceAnchorShape = sourceNode\n              .getContainer()\n              .find(\n                (ele) =>\n                  ele.get(\"name\") === \"anchor-point\" &&\n                  ele.get(\"anchorPointIdx\") === sourceAnchor\n              );\n            sourceAnchorShape.set(\"links\", sourceAnchorShape.get(\"links\") - 1);\n          }\n          if (targetNode && !isNaN(targetAnchor)) {\n            const targetAnchorShape = targetNode\n              .getContainer()\n              .find(\n                (ele) =>\n                  ele.get(\"name\") === \"anchor-point\" &&\n                  ele.get(\"anchorPointIdx\") === targetAnchor\n              );\n            targetAnchorShape.set(\"links\", targetAnchorShape.get(\"links\") - 1);\n          }\n        }\n      });\n\n      // 单击第一个节点后，创建边缘，更新 sourceAnchor(点击第一个⭕️锚点即触发)\n      graph.on(\"afteradditem\", (e) => {\n        if (e.item && e.item.getType() === \"edge\") {\n          graph.updateItem(e.item, {\n            sourceAnchor: sourceAnchorIdx,\n          });\n        }\n      });\n\n      // 一些监听器来控制节点的状态以显示和隐藏锚点圆---鼠标进入节点事件\n      graph.on(\"node:mouseenter\", (e) => {\n        graph.setItemState(e.item, \"showAnchors\", true);\n      });\n    //   鼠标离开事件-隐藏锚点\n      graph.on(\"node:mouseleave\", (e) => {\n        graph.setItemState(e.item, \"showAnchors\", false);\n      });\n\n      if (typeof window !== \"undefined\")\n        window.onresize = () => {\n          if (!graph || graph.get(\"destroyed\")) return;\n          if (!container || !container.scrollWidth || !container.scrollHeight)\n            return;\n          graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n        };\n    });\n  },\n});\n</script>\n<style lang=\"less\" scoped>\n.antv {\n  height: 100%;\n  // border: 1px solid #ddd;\n  border-radius: 6px;\n  #container {\n    height: 100%;\n  }\n}\n</style>\n","/Users/wawalike/Desktop/ggProject/src/components/layout/index.vue",["55","56","57"],"<template>\n  <div class=\"layout\">\n    <div class=\"layout_nav\">\n      <div v-for=\"item in data.navDataList\" :key=\"item.code\" @click=\"tabNav(item)\" :class=\"{selected: item.code == data.currentActive}\">{{item.name}}</div>\n    </div>\n    <div class=\"layout_content\">\n      <slot name=\"content\"></slot>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, onMounted, reactive, ref } from 'vue';\nimport { useRouter} from 'vue-router'\nexport default defineComponent({\n  name: 'layoutWorld',\n  /**\n   * @description props 外部传入数据说明\n   * @param navData {array} 头部导航菜单数据 {name:string,code:string} name 菜单展示名称 code对应菜单组件router路由name\n   * @param navHeight {string | number} 传入头部导航栏高度 例如 200 ｜ '200'\n  */\n  props: {\n    navData:{\n      type: Array,\n      default: function() {\n        return [{\n          name: '开发中，敬请期待',\n          code: 'mainView'\n        }]\n      }\n    },\n    navHeight: {\n      type:String || Number,\n      default: 60\n    }\n  },\n  setup(props:any, ctx) {\n    const router = useRouter();//router\n    // 定义DOM\n    type  HTMLElementTagNameMap = {\n      div: HTMLDivElement\n    }\n    // reactive 定义响应式数据\n    const data = reactive({\n      currentActive: 'Builder',\n      navDataList: []\n    });\n    data.navDataList = ref(props.navData)\n    // 类型设置\n    type tabNavP = {\n      name: string,\n      code: string\n    }\n    /**\n     * @description 导航栏菜单点击跳转相应组件\n     * @param item {tabNavP} 当前点击菜单数据信息\n     * @returns\n    */\n    const tabNav = (item:tabNavP) => {\n      console.log(item)\n      data.currentActive = item.code;//设置当前活动菜单，用于设置样式\n      router.push({\n        name: item.code\n      })\n    };\n    /**\n     * @description 钩子函数\n    */\n    onMounted(()=> {\n      // 根据引用组件者 传入值进行修改页面头部菜单样式默认值\n      let divObj = document.querySelectorAll<HTMLDivElement>('div.layout_nav');\n      if(divObj !== null) {\n        // 设置自定义高度\n        divObj[0].style.height = props.navHeight + 'px';\n        divObj[0].style.lineHeight = props.navHeight + 'px';\n        // 设置自定义颜色\n      }\n      // 初始化设置头部菜单活动页及样式\n      data.currentActive = props.navData[0].code;\n      router.push({\n        name: data.currentActive\n      })\n    });\n    return {\n      data,\n      tabNav\n    }\n  }\n});\n</script>\n<style lang=\"less\" scoped>\n@import \"@/assets/css/variable.less\";\n.layout {\n  height:100%;\n  position: relative;\n  .layout_nav {\n    display: flex;\n    height: 60px;\n    line-height: 60px;\n    padding: 0 20px;\n    box-sizing: border-box;\n    background-color: @mainColor;\n    >div {\n      padding: 0 10px;\n      box-sizing: border-box;\n      margin-right: 10px;\n      cursor: pointer;\n      color: #fff;\n    }\n    .selected {\n      background-color:@mainMatchColor;\n    }\n  }\n  .layout_content {\n    height: calc(100vh - 60px);\n    padding: 20px;\n    box-sizing: border-box;\n  }\n}\n</style>\n",{"ruleId":"58","severity":1,"message":"59","line":19,"column":20,"nodeType":"60","messageId":"61","endLine":19,"endColumn":63},{"ruleId":"58","severity":1,"message":"59","line":110,"column":7,"nodeType":"60","messageId":"61","endLine":110,"endColumn":42,"suggestions":"62"},{"ruleId":"58","severity":1,"message":"59","line":189,"column":27,"nodeType":"60","messageId":"61","endLine":189,"endColumn":70},{"ruleId":"58","severity":1,"message":"59","line":197,"column":27,"nodeType":"60","messageId":"61","endLine":197,"endColumn":70},{"ruleId":"63","severity":1,"message":"64","line":411,"column":26,"nodeType":"65","messageId":"66","endLine":411,"endColumn":29,"suggestions":"67"},{"ruleId":"58","severity":1,"message":"59","line":428,"column":27,"nodeType":"60","messageId":"61","endLine":428,"endColumn":64},{"ruleId":"68","severity":1,"message":"69","line":44,"column":47,"nodeType":"70","messageId":"71","endLine":44,"endColumn":53},{"ruleId":"68","severity":1,"message":"72","line":47,"column":11,"nodeType":"70","messageId":"71","endLine":47,"endColumn":17},{"ruleId":"68","severity":1,"message":"73","line":47,"column":18,"nodeType":"70","messageId":"71","endLine":47,"endColumn":22},{"ruleId":"63","severity":1,"message":"64","line":75,"column":34,"nodeType":"65","messageId":"66","endLine":75,"endColumn":37,"suggestions":"74"},{"ruleId":"63","severity":1,"message":"64","line":96,"column":33,"nodeType":"65","messageId":"66","endLine":96,"endColumn":36,"suggestions":"75"},{"ruleId":"68","severity":1,"message":"76","line":483,"column":49,"nodeType":"70","messageId":"71","endLine":483,"endColumn":50},{"ruleId":"63","severity":1,"message":"64","line":37,"column":15,"nodeType":"65","messageId":"66","endLine":37,"endColumn":18,"suggestions":"77"},{"ruleId":"68","severity":1,"message":"78","line":37,"column":20,"nodeType":"70","messageId":"71","endLine":37,"endColumn":23},{"ruleId":"68","severity":1,"message":"79","line":40,"column":11,"nodeType":"70","messageId":"71","endLine":40,"endColumn":32},"@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull",["80"],"@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["81","82"],"@typescript-eslint/no-unused-vars","'toRefs' is defined but never used.","Identifier","unusedVar","'_props' is defined but never used.","'_ctx' is defined but never used.",["83","84"],["85","86"],"'e' is defined but never used.",["87","88"],"'ctx' is defined but never used.","'HTMLElementTagNameMap' is defined but never used.",{"messageId":"89","fix":"90","desc":"91"},{"messageId":"92","fix":"93","desc":"94"},{"messageId":"95","fix":"96","desc":"97"},{"messageId":"92","fix":"98","desc":"94"},{"messageId":"95","fix":"99","desc":"97"},{"messageId":"92","fix":"100","desc":"94"},{"messageId":"95","fix":"101","desc":"97"},{"messageId":"92","fix":"102","desc":"94"},{"messageId":"95","fix":"103","desc":"97"},"suggestOptionalChain",{"range":"104","text":"105"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.","suggestUnknown",{"range":"106","text":"107"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"106","text":"108"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"109","text":"107"},{"range":"109","text":"108"},{"range":"110","text":"107"},{"range":"110","text":"108"},{"range":"111","text":"107"},{"range":"111","text":"108"},[2609,2610],"?",[9715,9718],"unknown","never",[2052,2055],[2672,2675],[976,979]]