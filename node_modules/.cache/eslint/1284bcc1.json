[{"/Users/wawalike/Desktop/ggProject/src/main.ts":"1","/Users/wawalike/Desktop/ggProject/src/App.vue":"2","/Users/wawalike/Desktop/ggProject/src/router/index.ts":"3","/Users/wawalike/Desktop/ggProject/src/store/index.ts":"4","/Users/wawalike/Desktop/ggProject/src/views/wait/index.vue":"5","/Users/wawalike/Desktop/ggProject/src/views/builderView/index.vue":"6","/Users/wawalike/Desktop/ggProject/src/components/layout/index.vue":"7","/Users/wawalike/Desktop/ggProject/src/views/antv/index.vue":"8","/Users/wawalike/Desktop/ggProject/src/views/antx/index.vue":"9","/Users/wawalike/Desktop/ggProject/src/views/personalise/index.vue":"10","/Users/wawalike/Desktop/ggProject/src/views/animationX6/index.vue":"11","/Users/wawalike/Desktop/ggProject/src/views/animationX6/components/step.vue":"12"},{"size":205,"mtime":1660722308937,"results":"13","hashOfConfig":"14"},{"size":1255,"mtime":1661998299913,"results":"15","hashOfConfig":"14"},{"size":1221,"mtime":1661998263382,"results":"16","hashOfConfig":"14"},{"size":157,"mtime":1656660965482,"results":"17","hashOfConfig":"14"},{"size":353,"mtime":1661998098571,"results":"18","hashOfConfig":"14"},{"size":14754,"mtime":1661310214084,"results":"19","hashOfConfig":"14"},{"size":3109,"mtime":1660787650014,"results":"20","hashOfConfig":"14"},{"size":21378,"mtime":1661313265348,"results":"21","hashOfConfig":"14"},{"size":19137,"mtime":1661311678229,"results":"22","hashOfConfig":"14"},{"size":427,"mtime":1661740113846,"results":"23","hashOfConfig":"14"},{"size":13983,"mtime":1662024757499,"results":"24","hashOfConfig":"14"},{"size":1853,"mtime":1662025628748,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"8phdmv",{"filePath":"29","messages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"35","messages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"40"},{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"40"},{"filePath":"44","messages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"40"},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"40"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/wawalike/Desktop/ggProject/src/main.ts",[],[],"/Users/wawalike/Desktop/ggProject/src/App.vue",[],"/Users/wawalike/Desktop/ggProject/src/router/index.ts",[],"/Users/wawalike/Desktop/ggProject/src/store/index.ts",[],"/Users/wawalike/Desktop/ggProject/src/views/wait/index.vue",[],"/Users/wawalike/Desktop/ggProject/src/views/builderView/index.vue",["56","57","58","59","60","61","62","63","64"],"<template>\n  <div class=\"builderView\">\n    <div class=\"builderView_left\">\n      <div\n        v-for=\"item in data.leftData\"\n        :key=\"item.code\"\n        :class=\"{\n          rectangleStyle: item.code == 'rectangle',\n          prismaticStyle: item.code == 'prismatic',\n        }\"\n        @dragstart=\"dragDiv($event, item)\"\n        draggable=\"true\"\n      ></div>\n    </div>\n    <!-- @drop=\"dropEvent(data.currentData)\" -->\n    <div\n      class=\"builderView_right\"\n      \n      @dragover.prevent\n    >\n      <!--  @mousedown=\"mousedownDiv\" -->\n      <!-- <div\n        v-for=\"(right, $index) in rightData\"\n        :key=\"$index\"\n        :style=\"{\n          'margin-top': right.code == 'rectangle' && $index != 0 ? '-6px' : '0',\n        }\"\n        :class=\"{\n          rectangleStyle: right.code == 'rectangle',\n          prismaticStyle: right.code == 'prismatic',\n          lineStyle: right.code == 'line',\n          arrowStyle: right.code == 'arrow',\n        }\"\n      >\n        <input\n          type=\"text\"\n          class=\"rightInput\"\n          v-if=\"right.code == 'rectangle'\"\n        />\n      </div> -->\n\n      <!-- X6 -->\n      <div id=\"container\"></div>\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent, onMounted, reactive, ref, Ref, toRefs } from 'vue';\nimport { Graph, Edge, Shape, NodeView } from '@antv/x6'\nexport default defineComponent({\n    name: 'builderView',\n    setup(_props,_ctx) {\n      onMounted(()=> {\n        // X6----开始\n        // 定义节点\n        class MyShape extends Shape.Rect {\n          getInPorts() {\n            return this.getPortsByGroup('in')\n          }\n\n          getOutPorts() {\n            return this.getPortsByGroup('out')\n          }\n\n          getUsedInPorts(graph: Graph) {\n            const incomingEdges = graph.getIncomingEdges(this) || []\n            return incomingEdges.map((edge: Edge) => {\n              const portId = edge.getTargetPortId()\n              return this.getPort(portId!)\n            })\n          }\n\n          getNewInPorts(length: number) {\n            return Array.from(\n              {\n                length,\n              },\n              () => {\n                return {\n                  group: 'in',\n                }\n              },\n            )\n          }\n\n          updateInPorts(graph: Graph) {\n            const minNumberOfPorts = 2\n            const ports = this.getInPorts()\n            const usedPorts = this.getUsedInPorts(graph)\n            const newPorts = this.getNewInPorts(\n              Math.max(minNumberOfPorts - usedPorts.length, 1),\n            )\n\n            if (\n              ports.length === minNumberOfPorts &&\n              ports.length - usedPorts.length > 0\n            ) {\n              // noop\n            } else if (ports.length === usedPorts.length) {\n              this.addPorts(newPorts)\n            } else if (ports.length + 1 > usedPorts.length) {\n              this.prop(\n                ['ports', 'items'],\n                this.getOutPorts().concat(usedPorts).concat(newPorts),\n                {\n                  rewrite: true,\n                },\n              )\n            }\n\n            return this\n          }\n        }\n\n        MyShape.config({\n          attrs: {\n            root: {\n              magnet: false,\n            },\n            body: {\n              fill: '#EFF4FF',\n              stroke: '#5F95FF',\n              strokeWidth: 1,\n            },\n          },\n          ports: {\n            items: [\n              {\n                group: 'out',\n              },\n            ],\n            groups: {\n              in: {\n                position: {\n                  name: 'top',\n                },\n                attrs: {\n                  portBody: {\n                    magnet: 'passive',\n                    r: 6,\n                    stroke: '#5F95FF',\n                    fill: '#fff',\n                    strokeWidth: 1,\n                  },\n                },\n              },\n              out: {\n                position: {\n                  name: 'bottom',\n                },\n                attrs: {\n                  portBody: {\n                    magnet: true,\n                    r: 6,\n                    fill: '#fff',\n                    stroke: '#5F95FF',\n                    strokeWidth: 1,\n                  },\n                },\n              },\n            },\n          },\n          portMarkup: [\n            {\n              tagName: 'circle',\n              selector: 'portBody',\n            },\n          ],\n        })\n\n        // 高亮\n        const magnetAvailabilityHighlighter = {\n          name: 'stroke',\n          args: {\n            attrs: {\n              fill: '#fff',\n              stroke: '#47C769',\n            },\n          },\n        }\n\n        // 画布\n        const graph = new Graph({\n          container: document.getElementById('container')!||'',\n          grid: true,\n          highlighting: {\n            magnetAvailable: magnetAvailabilityHighlighter,\n            magnetAdsorbed: {\n              name: 'stroke',\n              args: {\n                attrs: {\n                  fill: '#fff',\n                  stroke: '#31d0c6',\n                },\n              },\n            },\n          },\n          connecting: {\n            snap: true,\n            allowBlank: false,\n            allowLoop: false,\n            highlight: true,\n            connector: 'rounded',\n            connectionPoint: 'boundary',\n            router: {\n              name: 'er',\n              args: {\n                direction: 'V',\n              },\n            },\n            createEdge() {\n              return new Shape.Edge({\n                attrs: {\n                  line: {\n                    stroke: '#A2B1C3',\n                    strokeWidth: 1,\n                    targetMarker: {\n                      name: 'classic',\n                      size: 7,\n                    },\n                  },\n                },\n              })\n            },\n            validateConnection({ sourceView, targetView, targetMagnet }) {\n              if (!targetMagnet) {\n                return false\n              }\n\n              if (targetMagnet.getAttribute('port-group') !== 'in') {\n                return false\n              }\n\n              if (targetView) {\n                const node = targetView.cell\n                if (node instanceof MyShape) {\n                  const portId = targetMagnet.getAttribute('port')\n                  const usedInPorts = node.getUsedInPorts(graph)\n                  if (usedInPorts.find((port) => port && port.id === portId)) {\n                    return false\n                  }\n                }\n              }\n\n              return true\n            },\n          },\n        })\n        function update(view: NodeView) {\n          const cell = view.cell\n          if (cell instanceof MyShape) {\n            cell.getInPorts().forEach((port) => {\n              const portNode = view.findPortElem(port.id!, 'portBody')\n              view.unhighlight(portNode, {\n                highlighter: magnetAvailabilityHighlighter,\n              })\n            })\n            cell.updateInPorts(graph)\n          }\n        }\n\n        graph.on('edge:connected', ({ previousView, currentView }) => {\n          if (previousView) {\n            update(previousView as NodeView)\n          }\n          if (currentView) {\n            update(currentView as NodeView)\n          }\n        })\n\n        graph.on('edge:removed', ({ edge, options }) => {\n          if (!options.ui) {\n            return\n          }\n\n          const target = edge.getTargetCell()\n          if (target instanceof MyShape) {\n            target.updateInPorts(graph)\n          }\n        })\n\n        graph.on('edge:mouseenter', ({ edge }) => {\n          edge.addTools([\n            'source-arrowhead',\n            'target-arrowhead',\n            {\n              name: 'button-remove',\n              args: {\n                distance: -30,\n              },\n            },\n          ])\n        })\n\n        graph.on('edge:mouseleave', ({ edge }) => {\n          edge.removeTools()\n        })\n        //编辑\n        graph.on(\"cell:dblclick\", ({ cell, e }) => {\n          const isNode = cell.isNode();\n          const name = cell.isNode() ? \"node-editor\" : \"edge-editor\";\n          cell.removeTool(name);\n          cell.addTools({\n            name,\n            args: {\n              event: e,\n              attrs: {\n                backgroundColor: isNode ? \"#EFF4FF\" : \"#FFF\",\n              },\n            },\n          });\n        });\n        graph.on('node:mouseenter', ({ node }) => {\n          node.addTools({\n            name: \"button-remove\",\n            args: {\n              x: 0,\n              y: 0,\n              offset: { x: 0, y: 0 },\n            },\n          });\n        })\n        // X6············结束\n        // 绑定事件\n        const builderViewRight = document.getElementsByClassName('builderView_right')[0];\n        builderViewRight.addEventListener('drop', function() {\n          const num:number = Math.random() * 10;\n          graph.addNode(\n            new MyShape().resize(120, 40).position(200 + num, 50 + num).updateInPorts(graph),\n          )\n        })\n      })\n        type P = {\n            name: string,\n            code: string,\n            value: string\n        }\n        \n        //reactive设置响应式数据\n        const data = reactive({\n            leftData: [{\n                name: '长方形',\n                code: 'rectangle',\n                value: ''\n            }\n            // ,{\n            //     name: '棱形',\n            //     code: 'prismatic',\n            //     value: ''\n            // }\n            ],\n            clientX: '',//鼠标水平坐标\n            clientY: '',//鼠标垂直坐标\n            offsetLeft: '',//当前拖拽元素左侧偏移距离\n            offsetTop: '',//当前拖拽元素上方偏移距离\n            currentDragDom: '',\n            currentData: {},//当前拖拽数据\n        })\n        //ref设置响应式数据\n        const rightData: Ref<P[]> = ref([]);\n        const dragDiv = (_event: any, item: never) => {\n            data.currentData = item;\n        }\n        const dropEvent = (item:P) => {\n            // if(rightData.value.length!=0) {\n            //     rightData.value.push({\n            //         name: '线',\n            //         code: 'line',\n            //         value: ''\n            //     },{\n            //         name: '箭头',\n            //         code: 'arrow',\n            //         value: ''\n            //     })\n            // }\n            // rightData.value.push(item);\n            // console.log(rightData.value);\n            // X6\n            // graph.addNode(\n            //   new MyShape().resize(120, 40).position(200, 50).updateInPorts(graph),\n            // )\n        }\n        /**\n         * @description js实现元素拖拽移动\n        */\n        // const mousedownDiv = (e:any) => {\n        //     let offsetWidth = e.target.clientWidth;\n        //     let offsetHeight = e.target.clientHeight;\n        //     let parentNodeTop = e.target.parentNode.offsetTop + 20;//父元素上边距离上部距离\n        //     let parentNodeLeft = e.target.parentNode.offsetLeft + 20;//父元素左边距离左侧距离\n        //     let parentNodeBottomTop = e.target.parentNode.offsetTop + e.target.parentNode.offsetHeight - offsetHeight - 20;//父元素下边距离上部距离\n        //     let parentNodeRightLeft = e.target.parentNode.offsetLeft + e.target.parentNode.offsetWidth - offsetWidth - 20;//父元素右边距离左侧距离\n        //     let clientX = 0;\n        //     let clientY = 0;\n        //     document.onmousemove = function(event){\n        //         clientX = event.clientX;\n        //         clientY = event.clientY;\n        //         e.target.style.position = 'absolute';\n        //         e.target.style.left = ((clientX - offsetWidth/2) < parentNodeLeft)? (parentNodeLeft + \"px\") : ((clientX - offsetWidth/2)>parentNodeRightLeft)?(parentNodeRightLeft + 'px'):((clientX - offsetWidth/2) + \"px\")\n        //         e.target.style.top = ((clientY - offsetHeight/2) < parentNodeTop)? (parentNodeTop + \"px\") : ((clientY - offsetHeight/2)>parentNodeBottomTop?(parentNodeBottomTop+ 'px'):(clientY - offsetHeight/2) + \"px\")\n        //     };\n        //     document.onmouseup = function(){\n        //         //取消鼠标移动事件\n        //         document.onmousemove = null;\n        //         document.onmouseup = null;\n        //     }\n        // }\n        return {\n            data,//reactive定义响应式数据\n            rightData,//ref定义响应式数据：右侧渲染数据\n            dragDiv,//开始拖拽\n            dropEvent,//拖拽接收元素松开被拖拽元素事件\n            // mousedownDiv,//js实现元素拖拽（鼠标按下事件）\n        }\n    }\n})\n</script>\n<style lang=\"less\" scoped>\n.builderView {\n  display: flex;\n  height: 100%;\n  .builderView_left {\n    width: 300px;\n    height: 100%;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 20px 0;\n    box-sizing: border-box;\n    .rectangleStyle {\n      width: 100px;\n      height: 50px;\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      margin: 0 auto;\n      cursor: pointer;\n      background-color: #fff;\n    }\n    .prismaticStyle {\n      width: 80px;\n      height: 80px;\n      transform: rotate(45deg);\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      margin: 0 auto;\n      cursor: pointer;\n      background-color: #fff;\n      margin-top: 50px;\n    }\n  }\n  .builderView_right {\n    flex: 1;\n    height: 100%;\n    margin-left: 10px;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 20px;\n    box-sizing: border-box;\n    overflow: auto;\n    #container {\n      height: 100%;\n    }\n    .rectangleStyle {\n      width: 100px;\n      min-height: 30px;\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      margin: 0 auto;\n      cursor: pointer;\n      background-color: #fff;\n      // padding: 10px 20px;\n      text-align: center;\n    }\n    .prismaticStyle {\n      width: 100px;\n      height: 100px;\n      transform: rotate(45deg);\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      margin: 0 auto;\n      cursor: pointer;\n      background-color: #fff;\n      text-align: center;\n      margin-top: 13px !important;\n    }\n    .lineStyle {\n      width: 2px;\n      height: 50px;\n      background-color: lightBlue;\n      margin: 0 auto;\n    }\n    .arrowStyle {\n      width: 0;\n      height: 0;\n      border: 6px solid;\n      border-color: lightBlue transparent transparent transparent;\n      margin: 0 auto;\n    }\n    .rightInput {\n      width: 98%;\n      min-height: 30px;\n      border: none;\n      text-align: center;\n    }\n  }\n}\n</style>\n",[],"/Users/wawalike/Desktop/ggProject/src/components/layout/index.vue",["65","66","67"],"<template>\n  <div class=\"layout\">\n    <div class=\"layout_nav\">\n      <div v-for=\"item in data.navDataList\" :key=\"item.code\" @click=\"tabNav(item)\" :class=\"{selected: item.code == data.currentActive}\">{{item.name}}</div>\n    </div>\n    <div class=\"layout_content\">\n      <slot name=\"content\"></slot>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, onMounted, reactive, ref } from 'vue';\nimport { useRouter} from 'vue-router'\nexport default defineComponent({\n  name: 'layoutWorld',\n  /**\n   * @description props 外部传入数据说明\n   * @param navData {array} 头部导航菜单数据 {name:string,code:string} name 菜单展示名称 code对应菜单组件router路由name\n   * @param navHeight {string | number} 传入头部导航栏高度 例如 200 ｜ '200'\n  */\n  props: {\n    navData:{\n      type: Array,\n      default: function() {\n        return [{\n          name: '开发中，敬请期待',\n          code: 'mainView'\n        }]\n      }\n    },\n    navHeight: {\n      type:String || Number,\n      default: 60\n    }\n  },\n  setup(props:any, ctx) {\n    const router = useRouter();//router\n    // 定义DOM\n    type  HTMLElementTagNameMap = {\n      div: HTMLDivElement\n    }\n    // reactive 定义响应式数据\n    const data = reactive({\n      currentActive: 'Builder',\n      navDataList: []\n    });\n    data.navDataList = ref(props.navData)\n    // 类型设置\n    type tabNavP = {\n      name: string,\n      code: string\n    }\n    /**\n     * @description 导航栏菜单点击跳转相应组件\n     * @param item {tabNavP} 当前点击菜单数据信息\n     * @returns\n    */\n    const tabNav = (item:tabNavP) => {\n      console.log(item)\n      data.currentActive = item.code;//设置当前活动菜单，用于设置样式\n      router.push({\n        name: item.code\n      })\n    };\n    /**\n     * @description 钩子函数\n    */\n    onMounted(()=> {\n      // 根据引用组件者 传入值进行修改页面头部菜单样式默认值\n      let divObj = document.querySelectorAll<HTMLDivElement>('div.layout_nav');\n      if(divObj !== null) {\n        // 设置自定义高度\n        divObj[0].style.height = props.navHeight + 'px';\n        divObj[0].style.lineHeight = props.navHeight + 'px';\n        // 设置自定义颜色\n      }\n      // 初始化设置头部菜单活动页及样式\n      data.currentActive = props.navData[0].code;\n      router.push({\n        name: data.currentActive\n      })\n    });\n    return {\n      data,\n      tabNav\n    }\n  }\n});\n</script>\n<style lang=\"less\" scoped>\n@import \"@/assets/css/variable.less\";\n.layout {\n  height:100%;\n  position: relative;\n  .layout_nav {\n    display: flex;\n    height: 60px;\n    line-height: 60px;\n    padding: 0 20px;\n    box-sizing: border-box;\n    background-color: @mainColor;\n    >div {\n      padding: 0 10px;\n      box-sizing: border-box;\n      margin-right: 10px;\n      cursor: pointer;\n      color: #fff;\n    }\n    .selected {\n      background-color:@mainMatchColor;\n    }\n  }\n  .layout_content {\n    height: calc(100vh - 60px);\n    padding: 20px;\n    box-sizing: border-box;\n  }\n}\n</style>\n","/Users/wawalike/Desktop/ggProject/src/views/antv/index.vue",["68"],"<template>\n  <div class=\"antv\">\n    <div id=\"containers\"></div>\n  </div>\n</template>\n<script>\nimport { defineComponent, onMounted } from \"vue\";\nimport G6 from \"@antv/g6\";\nexport default defineComponent({\n  name: \"antV\",\n  setup() {\n    onMounted(() => {\n      /**\n       * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n       */\n      // let addedCount = 0;\n      // // Register a custom behavior: add a node when user click the blank part of canvas\n      // G6.registerBehavior('click-add-node', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         // The event is canvas:click, the responsing function is onClick\n      //         return {\n      //         'canvas:click': 'onClick',\n      //         };\n      //     },\n      //     // Click event\n      //     onClick(ev) {\n      //         const self = this;\n      //         const graph = self.graph;\n      //         // Add a new node\n      //         graph.addItem('node', {\n      //         x: ev.canvasX,\n      //         y: ev.canvasY,\n      //         id: `node-${addedCount}`, // Generate the unique id\n      //         });\n      //         addedCount++;\n      //     },\n      // });\n      // // Register a custom behavior: click two end nodes to add an edge\n      // G6.registerBehavior('click-add-edge', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         return {\n      //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n      //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n      //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n      //         };\n      //     },\n      //     // The responsing function for node:click defined in getEvents\n      //     onClick(ev) {\n      //         // console.log(1111)\n      //         // console.log(this)\n      //         const self = this;\n      //         const node = ev.item;\n      //         const graph = self.graph;\n      //         // The position where the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         const model = node.getModel();\n      //         if (self.addingEdge && self.edge) {\n      //         graph.updateItem(self.edge, {\n      //             target: model.id,\n      //         });\n\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         } else {\n      //         // Add anew edge, the end node is the current node user clicks\n      //         self.edge = graph.addItem('edge', {\n      //             source: model.id,\n      //             target: model.id,\n      //         });\n      //         self.addingEdge = true;\n      //         }\n      //     },\n      //     // The responsing function for mousemove defined in getEvents\n      //     onMousemove(ev) {\n      //         const self = this;\n      //         // The current position the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         if (self.addingEdge && self.edge) {\n      //         // Update the end node to the current node the mouse clicks\n      //         self.graph.updateItem(self.edge, {\n      //             target: point,\n      //         });\n      //         }\n      //     },\n      //     // The responsing function for edge:click defined in getEvents\n      //     onEdgeClick(ev) {\n      //         const self = this;\n      //         const currentEdge = ev.item;\n      //         if (self.addingEdge && self.edge === currentEdge) {\n      //         self.graph.removeItem(self.edge);\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         }\n      //     },\n      // });\n      // // Initial data\n      // const data = {\n      //     nodes: [\n      //         {\n      //         id: 'node1',\n      //         x: 100,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node2',\n      //         x: 300,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node3',\n      //         x: 300,\n      //         y: 300,\n      //         },\n      //     ],\n      //     edges: [\n      //         {\n      //         id: 'edge1',\n      //         target: 'node2',\n      //         source: 'node1',\n      //         },\n      //     ],\n      // };\n\n      // const container = document.getElementById('container');\n      // // Add a layout 及子元素\n      // const layoutBox = document.createElement('div');\n      // layoutBox.id = 'layoutBox';\n      // const layoutLeft = document.createElement('div');\n      // layoutLeft.id = 'layoutLeft';\n      // const layoutRight = document.createElement('div');\n      // layoutRight.id = 'layoutRight';\n      // // 设置layout样式\n      // layoutBox.style = \"height:100%;display:flex\"\n      // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n      // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n      // // 添加左侧元素\n      // const node = document.createElement('div');\n      // node.value = 'addNode'\n      // node.id = 'nodeId';\n      // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n      // // 添加样式元素到container\n      // layoutBox.appendChild(layoutLeft);\n      // layoutBox.appendChild(layoutRight);\n      // // container.appendChild(layoutBox);\n      // // 添加子元素到左侧\n      // layoutLeft.appendChild(node);\n      // // Add a selector to DOM\n      // const selector = document.createElement('select');\n      // selector.id = 'selector';\n      // selector.style.border = 'none';\n      // const selection1 = document.createElement('option');\n      // selection1.value = 'default';\n      // selection1.innerHTML = 'Default Mode';\n      // const selection2 = document.createElement('option');\n      // selection2.value = 'addNode';\n      // selection2.innerHTML = 'Add Node (By clicking canvas)';\n      // const selection3 = document.createElement('option');\n      // selection3.value = 'addEdge';\n      // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n      // selector.appendChild(selection1);\n      // selector.appendChild(selection2);\n      // selector.appendChild(selection3);\n      // container.appendChild(selector);\n\n      // const width = container.scrollWidth;\n      // const height = (container.scrollHeight || 500) - 30;\n      // const graph = new G6.Graph({\n      // container: 'container',\n      // width,\n      // height,\n      // // The sets of behavior modes\n      // modes: {\n      //     // Defualt mode\n      //     default: ['drag-node', 'click-select'],\n      //     // Adding node mode\n      //     addNode: ['click-add-node', 'click-select'],\n      //     // Adding edge mode\n      //     addEdge: ['click-add-edge', 'click-select'],\n      // },\n      // // The node styles in different states\n      // nodeStateStyles: {\n      //     // The node styles in selected state\n      //     selected: {\n      //         stroke: '#666',\n      //         lineWidth: 2,\n      //         fill: 'steelblue',\n      //     },\n      // },\n      // });\n      // graph.data(data);\n      // graph.render();\n\n      // // Listen to the selector, change the mode when the selector is changed\n      // selector.addEventListener('change', (e) => {\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // // 左侧长方形node元素点击事件\n      // node.addEventListener('click', (e) => {\n      //     console.log(e.target.value)\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n\n      // if (typeof window !== 'undefined')\n      // window.onresize = () => {\n      //     if (!graph || graph.get('destroyed')) return;\n      //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n      //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n      // };\n      // ---------------------------------------------------------------------------------------\n      // G6.Util.processParallelEdges processes the edges with same source node and target node,\n      // on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\n    //   边设置\n      const processParallelEdgesOnAnchorPoint = (\n        edges,\n        offsetDiff = 15,\n        multiEdgeType = \"quadratic\",\n        singleEdgeType = undefined,\n        loopEdgeType = undefined\n      ) => {\n        const len = edges.length;\n        const cod = offsetDiff * 2;\n        const loopPosition = [\n          \"top\",\n          \"top-right\",\n          \"right\",\n          \"bottom-right\",\n          \"bottom\",\n          \"bottom-left\",\n          \"left\",\n          \"top-left\",\n          \"center\"\n        ];\n        const edgeMap = {};\n        const tags = [];\n        const reverses = {};\n        for (let i = 0; i < len; i++) {\n          const edge = edges[i];\n          const { source, target, sourceAnchor, targetAnchor } = edge;\n          const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n\n          if (tags[i]) continue;\n          if (!edgeMap[sourceTarget]) {\n            edgeMap[sourceTarget] = [];\n          }\n          tags[i] = true;\n          edgeMap[sourceTarget].push(edge);\n          for (let j = 0; j < len; j++) {\n            if (i === j) continue;\n            const sedge = edges[j];\n            const {\n              source: src,\n              target: dst,\n              sourceAnchor: srcAnchor,\n              targetAnchor: dstAnchor,\n            } = sedge;\n\n            // 两个节点之间共同的边\n            // 第一条的source = 第二条的target\n            // 第一条的target = 第二条的source\n            if (!tags[j]) {\n              if (\n                source === dst &&\n                sourceAnchor === dstAnchor &&\n                target === src &&\n                targetAnchor === srcAnchor\n              ) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n                reverses[\n                  `${src}|${srcAnchor}|${dst}|${dstAnchor}|${\n                    edgeMap[sourceTarget].length - 1\n                  }`\n                ] = true;\n              } else if (\n                source === src &&\n                sourceAnchor === srcAnchor &&\n                target === dst &&\n                targetAnchor === dstAnchor\n              ) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n              }\n            }\n          }\n        }\n\n        for (const key in edgeMap) {\n          const arcEdges = edgeMap[key];\n          const { length } = arcEdges;\n          for (let k = 0; k < length; k++) {\n            const current = arcEdges[k];\n            if (current.source === current.target) {\n              if (loopEdgeType) current.type = loopEdgeType;\n              // 超过8条自环边，则需要重新处理\n              current.loopCfg = {\n                position: loopPosition[k % 8],\n                dist: Math.floor(k / 8) * 20 + 50,\n              };\n              continue;\n            }\n            if (\n              length === 1 &&\n              singleEdgeType &&\n              (current.source !== current.target ||\n                current.sourceAnchor !== current.targetAnchor)\n            ) {\n              current.type = singleEdgeType;\n              continue;\n            }\n            current.type = multiEdgeType;\n            const sign =\n              (k % 2 === 0 ? 1 : -1) *\n              (reverses[\n                `${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`\n              ]\n                ? -1\n                : 1);\n            if (length % 2 === 1) {\n              current.curveOffset = sign * Math.ceil(k / 2) * cod;\n            } else {\n              current.curveOffset =\n                sign * (Math.floor(k / 2) * cod + offsetDiff);\n            }\n          }\n        }\n        return edges;\n      };\n\n      const data = {\n        // 节点数据\n        nodes: [\n          { id: \"node1\", x: 350, y: 100,label: 'A' },\n          { id: \"node2\", x: 350, y: 250,label: 'B' }\n        ]\n      };\n      // 新增节点按钮\n      const descriptionDiv = document.createElement(\"div\");\n      const container = document.getElementById(\"containers\");\n      descriptionDiv.innerText = \"新增节点\";\n      descriptionDiv.style =\n        \"width: 80px;height:34px;line-height:34px;text-align:center;border:1px solid #5ab4be;border-radius:4px;background:#5ab4be;color:#fff;cursor:pointer;margin:0 auto\";\n      container.appendChild(descriptionDiv);\n\n      // custom a node with anchor-point shapes\n      G6.registerNode(\n        \"rect-node\",\n        {\n          // draw anchor-point circles according to the anchorPoints in afterDraw\n          afterDraw(cfg, group) {\n            const bbox = group.getBBox();\n            const anchorPoints = this.getAnchorPoints(cfg);//设置锚点\n            anchorPoints.forEach((anchorPos, i) => {\n              group.addShape(\"circle\", {\n                attrs: {\n                  r: 5,\n                  x: bbox.x + bbox.width * anchorPos[0],\n                  y: bbox.y + bbox.height * anchorPos[1],\n                  fill: \"#fff\",\n                  stroke: \"#5ab4be\",\n                },\n                name: `anchor-point`, // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n                anchorPointIdx: i, // flag the idx of the anchor-point circle\n                links: 0, // cache the number of edges connected to this shape\n                visible: false, // invisible by default, shows up when links > 1 or the node is in showAnchors state\n              });\n            });\n          },\n          getAnchorPoints(cfg) {\n            return (\n              cfg.anchorPoints || [\n                // [0, 0.5],\n                // [0.33, 0],\n                // [0.66, 0],\n                // [1, 0.5],\n                // [0.33, 1],\n                // [0.66, 1],\n              ]\n            );\n          },\n          // response the state changes and show/hide the link-point circles\n          setState(name, value, item) {\n            if (name === \"showAnchors\") {\n              const anchorPoints = item\n                .getContainer()\n                .findAll((ele) => ele.get(\"name\") === \"anchor-point\");\n              anchorPoints.forEach((point) => {\n                if (value || point.get(\"links\") > 0) point.show();\n                else point.hide();\n              });\n            }\n          },\n        },\n        \"rect\"\n      );\n\n      let sourceAnchorIdx, targetAnchorIdx;\n\n      const width = container.scrollWidth;\n      const height = (container.scrollHeight || 500) - 120;\n    //   let beginDom;\n      const graph = new G6.Graph({\n        container: \"containers\",\n        width,\n        height,\n        modes: {\n          default: [\n            \"drag-node\",\n            // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n            {\n              type: \"create-edge\",\n            //   点击开始链接\n              shouldBegin: (e) => {\n                console.log('begin',e)\n                // beginDom = e.target;\n                const edges = graph.save().edges;\n                if(edges.length!=0) return false\n                // 避免从节点上的其他形状开始----只点击锚点触发，非锚点终止\n                // if (e.target && e.target.get(\"name\") !== \"anchor-point\")\n                //   return false;\n                sourceAnchorIdx = e.target.get(\"anchorPointIdx\");\n                e.target.set(\"links\", e.target.get(\"links\") + 1); // cache the number of edge connected to this anchor-point circle\n                return true;\n              },\n            //   点击结束链接----只点击锚点触发，非锚点终止\n              shouldEnd: (e) => {\n                console.log('end',e.target)\n                const edges = graph.save().edges;\n                // if(edges.length!=0) return false\n                edges.push({\n                    source: 'node1',\n                    target: 'node2',\n                    label: 'default arrow',\n                    style: {\n                        endArrow: true,\n                    },\n                });\n                processParallelEdgesOnAnchorPoint(edges);\n                //避免在节点上的其他形状处结束\n                // if (e.target && e.target.get(\"name\") !== \"anchor-point\")\n                //   return false;\n                if (e.target) {\n                  targetAnchorIdx = e.target.get(\"anchorPointIdx\");\n                  e.target.set(\"links\", e.target.get(\"links\") + 1); // cache the number of edge connected to this anchor-point circle\n                  return true;\n                }\n                targetAnchorIdx = undefined;\n                return true;\n              },\n              // update the sourceAnchor\n              // getEdgeConfig: () => {\n              //   return {\n              //     sourceAnchor: sourceAnchorIdx\n              //   }\n              // }\n            },\n          ],\n        },\n        defaultNode: {\n          type: \"rect-node\",\n          style: {\n            fill: \"#eee\",\n            stroke: \"#ccc\",\n          },\n        },\n        defaultEdge: {\n          type: \"quadratic\",\n          style: {\n            stroke: \"#F6BD16\",\n            lineWidth: 2,\n          },\n        },\n      });\n\n      graph.data(data);\n      graph.render();\n      // 新增节点按钮事件----新增事件\n      descriptionDiv.addEventListener(\"click\", (e) => {\n          data.nodes.push({ \n              id: \"node\" + data.nodes.length+1,\n            x: data.nodes[data.nodes.length - 1].x,\n            y:  data.nodes[data.nodes.length - 1].y + 50\n        });\n        // 重新绘制\n        graph.data(data);\n        graph.render();\n      });\n      //链接完成事件\n      graph.on(\"aftercreateedge\", (e) => {\n        // update the sourceAnchor and targetAnchor for the newly added edge\n        graph.updateItem(e.edge, {\n          sourceAnchor: sourceAnchorIdx,\n          targetAnchor: targetAnchorIdx,\n        });\n\n        // 更新平行边的curveOffset\n        //设置边(不重叠)\n        const edges = graph.save().edges;\n        processParallelEdgesOnAnchorPoint(edges);\n        graph.getEdges().forEach((edge, i) => {\n          graph.updateItem(edge, {\n            curveOffset: edges[i].curveOffset,\n            curvePosition: edges[i].curvePosition,\n          });\n        });\n      });\n\n      // 如果创建边缘在结束前被取消，更新锚点圆圈上的“链接”\n      graph.on(\"afterremoveitem\", (e) => {\n        if (e.item && e.item.source && e.item.target) {\n          const sourceNode = graph.findById(e.item.source);\n          const targetNode = graph.findById(e.item.target);\n          const { sourceAnchor, targetAnchor } = e.item;\n          if (sourceNode && !isNaN(sourceAnchor)) {\n            const sourceAnchorShape = sourceNode\n              .getContainer()\n              .find(\n                (ele) =>\n                  ele.get(\"name\") === \"anchor-point\" &&\n                  ele.get(\"anchorPointIdx\") === sourceAnchor\n              );\n            sourceAnchorShape.set(\"links\", sourceAnchorShape.get(\"links\") - 1);\n          }\n          if (targetNode && !isNaN(targetAnchor)) {\n            const targetAnchorShape = targetNode\n              .getContainer()\n              .find(\n                (ele) =>\n                  ele.get(\"name\") === \"anchor-point\" &&\n                  ele.get(\"anchorPointIdx\") === targetAnchor\n              );\n            targetAnchorShape.set(\"links\", targetAnchorShape.get(\"links\") - 1);\n          }\n        }\n      });\n\n      // 单击第一个节点后，创建边缘，更新 sourceAnchor(点击第一个⭕️锚点即触发)\n      graph.on(\"afteradditem\", (e) => {\n        if (e.item && e.item.getType() === \"edge\") {\n          graph.updateItem(e.item, {\n            sourceAnchor: sourceAnchorIdx,\n          });\n        }\n      });\n\n      // 一些监听器来控制节点的状态以显示和隐藏锚点圆---鼠标进入节点事件\n      graph.on(\"node:mouseenter\", (e) => {\n        graph.setItemState(e.item, \"showAnchors\", true);\n      });\n    //   鼠标离开事件-隐藏锚点\n      graph.on(\"node:mouseleave\", (e) => {\n        graph.setItemState(e.item, \"showAnchors\", false);\n      });\n\n      if (typeof window !== \"undefined\")\n        window.onresize = () => {\n          if (!graph || graph.get(\"destroyed\")) return;\n          if (!container || !container.scrollWidth || !container.scrollHeight)\n            return;\n          graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n        };\n    });\n  },\n});\n</script>\n<style lang=\"less\" scoped>\n.antv {\n  height: 100%;\n  // border: 1px solid #ddd;\n  border-radius: 6px;\n  #containers {\n    height: 100%;\n  }\n}\n</style>\n","/Users/wawalike/Desktop/ggProject/src/views/antx/index.vue",["69","70","71","72","73","74","75","76","77","78"],"<template>\n  <div class=\"antx\">\n    <div id=\"container\"></div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport {insertCss} from 'insert-css';\nimport { defineComponent, onMounted } from \"vue\";\nimport { Graph, Shape, Addon, Edge, NodeView} from '@antv/x6'\nexport default defineComponent({\n  name: \"antX\",\n  setup() {\n    onMounted(() => {\n      // 为了协助代码演示\n      preWork()\n      //定义输入输出锚点开始\n      // 定义节点\n      class MyShape extends Shape.Rect {\n        getInPorts() {\n          return this.getPortsByGroup('in')\n        }\n\n        getOutPorts() {\n          return this.getPortsByGroup('out')\n        }\n\n        getUsedInPorts(graph: Graph) {\n          const incomingEdges = graph.getIncomingEdges(this) || []\n          return incomingEdges.map((edge: Edge) => {\n            const portId = edge.getTargetPortId()\n            return this.getPort(portId!)\n          })\n        }\n        // 获取新的in链接桩\n        getNewInPorts(length: number) {\n          return Array.from(\n            {\n              length,\n            },\n            () => {\n              return {\n                group: 'in'\n              }\n            },\n          )\n        }\n        // 新增out输出链接桩\n        getNewOutPorts(length: number) {\n          return Array.from(\n            {\n              length,\n            },\n            () => {\n              return {\n                group: 'out'\n              }\n            },\n          )\n        }\n        updateInPorts(graph: Graph) {\n          const minNumberOfPorts = 2\n          const ports = this.getInPorts()\n          const usedPorts = this.getUsedInPorts(graph)\n          // 新增in链接桩\n          const newPorts = this.getNewInPorts(\n            Math.max(minNumberOfPorts - usedPorts.length, 1),\n          )\n          // 新增out链接桩\n          const newOutPorts = this.getNewOutPorts(1);\n\n          if (\n            ports.length === minNumberOfPorts &&\n            ports.length - usedPorts.length > 0\n          ) {\n            // noop\n          } else if (ports.length === usedPorts.length) {\n            debugger\n            newPorts.push(newOutPorts[0]);\n            console.log(newPorts,'new')\n            this.addPorts(newPorts)\n          } else if (ports.length + 1 > usedPorts.length) {\n            this.prop(\n              ['ports', 'items'],\n              this.getOutPorts().concat(usedPorts).concat(newPorts),\n              {\n                rewrite: true,\n              },\n            )\n          }\n\n          return this\n        }\n      }\n\n      MyShape.config({\n        attrs: {\n          root: {\n            magnet: false,\n          },\n          body: {\n            fill: '#EFF4FF',\n            stroke: '#5F95FF',\n            strokeWidth: 1,\n          },\n        },\n        ports: {\n          items: [\n            {\n              group: 'out',\n            },\n          ],\n          groups: {\n            in: {\n              position: {\n                name: 'top',\n              },\n              attrs: {\n                portBody: {\n                  magnet: 'passive',\n                  r: 6,\n                  stroke: '#5F95FF',\n                  fill: '#fff',\n                  strokeWidth: 1,\n                },\n              },\n            },\n            out: {\n              position: {\n                name: 'bottom',\n              },\n              attrs: {\n                portBody: {\n                  magnet: true,\n                  r: 6,\n                  fill: '#fff',\n                  stroke: '#5F95FF',\n                  strokeWidth: 1,\n                },\n              },\n            },\n          },\n        },\n        portMarkup: [\n          {\n            tagName: 'circle',\n            selector: 'portBody',\n          }\n        ],\n      })\n\n      // 高亮\n      const magnetAvailabilityHighlighter = {\n        name: 'stroke',\n        args: {\n          attrs: {\n            fill: '#fff',\n            stroke: '#47C769',\n          },\n        },\n      }\n\n      //定义输入输出锚点结束\n\n      // #region 初始化画布\n      const graph = new Graph({\n        container: document.getElementById('graph-container')!,\n        grid: true,\n          highlighting: {\n            magnetAvailable: magnetAvailabilityHighlighter,\n            magnetAdsorbed: {\n              name: 'stroke',\n              args: {\n                attrs: {\n                  fill: '#fff',\n                  stroke: '#31d0c6',\n                },\n              },\n            },\n          },\n          connecting: {\n            snap: true,\n            allowBlank: false,\n            allowLoop: false,\n            highlight: true,\n            connector: 'rounded',\n            connectionPoint: 'boundary',\n            router: {\n              name: 'er',\n              args: {\n                direction: 'V',\n              },\n            },\n            createEdge() {\n              return new Shape.Edge({\n                // attrs: {\n                //   line: {\n                //     stroke: '#A2B1C3',\n                //     strokeWidth: 1,\n                //     targetMarker: {\n                //       name: 'classic',\n                //       size: 7,\n                //     },\n                //   },\n                // },\n                attrs: {\n                        line: {\n                          stroke: '#1890ff',\n                          strokeWidth: 1,\n                          targetMarker: {\n                            name: 'classic',\n                            size: 8\n                          },\n                          strokeDasharray: 0, //虚线\n                          style: {\n                            animation: 'ant-line 30s infinite linear',\n                          },\n                        },\n                      },\n                      label: {\n                        text:''\n                      },\n                      connector: '',//折线\n                      router: {\n                        name: 'manhattan'\n                      },\n                      zIndex: 0\n              })\n            },\n          validateConnection({ sourceView, targetView, targetMagnet }) {//锚点是否可连接\n            if (!targetMagnet) {\n              return false\n            }\n\n            if (targetMagnet.getAttribute('port-group') !== 'in') {\n              return false\n            }\n\n            if (targetView) {\n              const node = targetView.cell\n              if (node instanceof MyShape) {\n                const portId = targetMagnet.getAttribute('port')\n                const usedInPorts = node.getUsedInPorts(graph)\n                if (usedInPorts.find((port) => port && port.id === portId)) {\n                  return false\n                }\n              }\n            }\n\n            return true\n          },\n          \n        },\n        resizing: true,\n        rotating: true,\n        selecting: {\n          enabled: true,\n          rubberband: true,\n          showNodeSelectionBox: true,\n        },\n        snapline: true,\n        keyboard: true,\n        clipboard: true,\n      })\n      //编辑\n      graph.on('cell:dblclick', ({ cell, e }) => {\n        const isNode = cell.isNode()\n        const name = cell.isNode() ? 'node-editor' : 'edge-editor'\n        cell.removeTool(name)\n        cell.addTools({\n          name,\n          args: { \n            event: e,\n            attrs: {\n              backgroundColor: isNode ? '#EFF4FF' : '#FFF',\n            },\n          },\n        })\n      })\n      //鼠标悬停在边上显示删除边\n      graph.on('edge:mouseenter', ({ edge }) => {\n        edge.addTools([\n          'source-arrowhead',\n          'target-arrowhead',\n          {\n            name: 'button-remove',\n            args: {\n              distance: -30,\n            },\n          },\n        ])\n      })\n      // 设置边选中样式\n      graph.on('selection:changed', (args) => {\n              args.added.forEach(cell => {\n                if(cell.isEdge()){\n                 cell.isEdge() && cell.attr('line/strokeDasharray', 5) //虚线蚂蚁线\n                 cell.addTools([\n                    {\n                      name: 'vertices',\n                      args: {\n                        padding: 4,\n                        attrs: {\n                          strokeWidth: 0.1,\n                          stroke: '#2d8cf0',\n                          fill: '#ffffff',\n                        }\n                      },\n                    },\n                  ])\n                }\n              })\n              args.removed.forEach(cell => {\n                cell.isEdge() && cell.attr('line/strokeDasharray', 0)  //正常线\n                cell.removeTools()\n              })\n          })\n      // 鼠标离开边恢复进入前状态\n      graph.on('edge:mouseleave', ({ edge }) => {\n        edge.removeTools()\n      })\n      function update(view: NodeView) {\n          const cell = view.cell\n          if (cell instanceof MyShape) {\n            cell.getInPorts().forEach((port) => {\n              const portNode = view.findPortElem(port.id!, 'portBody')\n              view.unhighlight(portNode, {\n                highlighter: magnetAvailabilityHighlighter,\n              })\n            })\n            cell.updateInPorts(graph)\n          }\n        }\n\n        graph.on('edge:connected', ({ previousView, currentView }) => {\n          if (previousView) {\n            update(previousView as NodeView)\n          }\n          if (currentView) {\n            update(currentView as NodeView)\n          }\n        })\n// graph.addNode(\n//   new MyShape().resize(120, 40).position(200, 50).updateInPorts(graph),\n// )\n\n// graph.addNode(\n//   new MyShape().resize(120, 40).position(400, 50).updateInPorts(graph),\n// )\n\n// graph.addNode(\n//   new MyShape().resize(120, 40).position(300, 250).updateInPorts(graph),\n// )\n      // #endregion\n      // #region 初始化 stencil\n      const stencil = new Addon.Stencil({\n        title: '流程图',\n        target: graph,\n        stencilGraphWidth: 200,\n        stencilGraphHeight: 180,\n        collapsable: true,\n        groups: [\n          {\n            title: '基础流程图',\n            name: 'group1',\n          }\n        ],\n        layoutOptions: {\n          columns: 2,\n          columnWidth: 80,\n          rowHeight: 55,\n        },\n      })\n      document.getElementById('stencil')!.appendChild(stencil.container)\n      // #endregion\n\n      // #region 快捷键与事件\n      // copy cut paste\n      graph.bindKey(['meta+c', 'ctrl+c'], () => {\n        console.log('bindkey:+c')\n        const cells = graph.getSelectedCells()\n        if (cells.length) {\n          graph.copy(cells)\n        }\n        return false\n      })\n      graph.bindKey(['meta+x', 'ctrl+x'], () => {\n        console.log('bindkey+X')\n        const cells = graph.getSelectedCells()\n        if (cells.length) {\n          graph.cut(cells)\n        }\n        return false\n      })\n      graph.bindKey(['meta+v', 'ctrl+v'], () => {\n        console.log('bindkey+V')\n        if (!graph.isClipboardEmpty()) {\n          const cells = graph.paste({ offset: 32 })\n          graph.cleanSelection()\n          graph.select(cells)\n        }\n        return false\n      })\n\n      //undo redo\n      graph.bindKey(['meta+z', 'ctrl+z'], () => {\n        console.log('bindkey:+Z')\n        if (graph.history.canUndo()) {\n          graph.history.undo()\n        }\n        return false\n      })\n      graph.bindKey(['meta+shift+z', 'ctrl+shift+z'], () => {\n        if (graph.history.canRedo()) {\n          graph.history.redo()\n        }\n        return false\n      })\n\n      // select all\n      graph.bindKey(['meta+a', 'ctrl+a'], () => {\n        const nodes = graph.getNodes()\n        if (nodes) {\n          graph.select(nodes)\n        }\n      })\n\n      //delete\n      // graph.bindKey('backspace', () => {\n      //   const cells = graph.getSelectedCells()\n      //   if (cells.length) {\n      //     graph.removeCells(cells)\n      //   }\n      // })\n\n      // zoom\n      graph.bindKey(['ctrl+1', 'meta+1'], () => {\n        const zoom = graph.zoom()\n        if (zoom < 1.5) {\n          graph.zoom(0.1)\n        }\n      })\n      graph.bindKey(['ctrl+2', 'meta+2'], () => {\n        const zoom = graph.zoom()\n        if (zoom > 0.5) {\n          graph.zoom(-0.1)\n        }\n      })\n      // 控制连接桩显示/隐藏\n      const showPorts = (ports: NodeListOf<SVGElement>, show: boolean) => {\n        for (let i = 0, len = ports.length; i < len; i = i + 1) {\n          ports[i].style.visibility = show ? 'visible' : 'hidden'\n        }\n      }\n      graph.on('node:mouseenter', ({node}) => {\n        console.log('mouseenter')\n        const container = document.getElementById('graph-container')!\n        const ports = container.querySelectorAll(\n          '.x6-port-body',\n        ) as NodeListOf<SVGElement>\n        showPorts(ports, true);\n        node.addTools({\n          name: 'button-remove',\n          args: {\n            x: 0,\n            y: 0,\n            offset: { x: 0, y: 0 },\n          },\n        })\n      })\n      graph.on('node:mouseleave', ({node}) => {\n        console.log('mouseleave')\n        const container = document.getElementById('graph-container')!\n        const ports = container.querySelectorAll(\n          '.x6-port-body',\n        ) as NodeListOf<SVGElement>\n        showPorts(ports, false);\n        node.removeTools()\n      })\n      // #endregion\n      // 点击保存按钮获取流程数据\n      const obj = document.getElementById('spanBtn');\n      console.log(obj,'obj');\n      obj?.addEventListener('click', function() {\n        console.log(graph.model.getNodes())\n        console.log(graph.model.getEdges())\n      })\n\n      // #region 初始化图形\n      const ports = {\n        groups: {\n          // 上下左右锚点样式\n          top: {\n            position: 'top',\n            attrs: {\n              circle: {\n                r: 4,\n                magnet: true,\n                stroke: '#5F95FF',\n                strokeWidth: 1,\n                fill: '#fff',\n                style: {\n                  visibility: 'hidden',\n                },\n              },\n            },\n          },\n          right: {\n            position: 'right',\n            attrs: {\n              circle: {\n                r: 4,\n                magnet: true,\n                stroke: '#5F95FF',\n                strokeWidth: 1,\n                fill: '#fff',\n                style: {\n                  visibility: 'hidden',\n                },\n              },\n            },\n          },\n          bottom: {\n            position: 'bottom',\n            attrs: {\n              circle: {\n                r: 4,\n                magnet: true,\n                stroke: '#5F95FF',\n                strokeWidth: 1,\n                fill: '#fff',\n                style: {\n                  visibility: 'hidden',\n                },\n              },\n            },\n          },\n          left: {\n            position: 'left',\n            attrs: {\n              circle: {\n                r: 4,\n                magnet: true,\n                stroke: '#5F95FF',\n                strokeWidth: 1,\n                fill: '#fff',\n                style: {\n                  visibility: 'hidden',\n                },\n              },\n            },\n          },\n        },\n        items: [\n          {\n            group: 'top',\n          },\n          {\n            group: 'right',\n          },\n          {\n            group: 'bottom',\n          },\n          {\n            group: 'left',\n          },\n        ],\n      }\n\n      Graph.registerNode(\n        'custom-rect',\n        {\n          inherit: 'rect',\n          width: 66,\n          height: 36,\n          attrs: {\n            body: {\n              strokeWidth: 1,\n              stroke: '#5F95FF',\n              fill: '#EFF4FF',\n            },\n            text: {\n              fontSize: 12,\n              fill: '#262626',\n            },\n          },\n          ports: { ...ports },//渲染锚点\n        },\n        true,\n      )\n\n\n      const r2 = graph.createNode({\n        shape: 'custom-rect',\n        label: '过程'\n      })\n      const r3 = new MyShape().resize(80, 40).updateInPorts(graph);\n      stencil.load([r3], 'group1')\n\n      const imageShapes: any[] = []\n      const imageNodes = imageShapes.map((item) =>\n        graph.createNode({\n          shape: 'custom-image',\n          label: item.label,\n          attrs: {\n            image: {\n              'xlink:href': item.image,\n            },\n          },\n        }),\n      )\n      stencil.load(imageNodes, 'group2')\n      // #endregion\n\n      function preWork() {\n        // 这里协助演示的代码，在实际项目中根据实际情况进行调整\n        const container = document.getElementById('container')!\n        const stencilContainer = document.createElement('div')\n        stencilContainer.id = 'stencil'\n        const graphContainer = document.createElement('div')\n        graphContainer.id = 'graph-container'\n        container.appendChild(stencilContainer)\n        container.appendChild(graphContainer)\n        const spanBtn = document.createElement('span');\n        spanBtn.id = 'spanBtn';\n        container.appendChild(spanBtn);\n        spanBtn.innerText = '保存';\n        insertCss(`\n          #container {\n            display: flex;\n            border: 1px solid #dfe3e8;\n            position: relative;\n          }\n          #stencil {\n            width: 180px;\n            height: 100%;\n            position: relative;\n            border-right: 1px solid #dfe3e8; \n          }\n          #graph-container {\n            width: calc(100% - 180px);\n            height: 100%;\n          }\n          #spanBtn {\n            display: inline-block;\n            color: #fff;\n            cursor: pointer;\n            border: 1px solid #5ab4be;\n            border-radius: 4px;\n            width: 80px;\n            height: 34px;\n            line-height: 34px;\n            text-align: center;\n            background: #5ab4be;\n            position: absolute;\n            right: 0;\n          }\n          .x6-widget-stencil  {\n            background-color: #fff;\n          }\n          .x6-widget-stencil-title {\n            background-color: #fff;\n          }\n          .x6-widget-stencil-group-title {\n            background-color: #fff !important;\n          }\n          .x6-widget-transform {\n            margin: -1px 0 0 -1px;\n            padding: 0px;\n            border: 1px solid #239edd;\n          }\n          .x6-widget-transform > div {\n            border: 1px solid #239edd;\n          }\n          .x6-widget-transform > div:hover {\n            background-color: #3dafe4;\n          }\n          .x6-widget-transform-active-handle {\n            background-color: #3dafe4;\n          }\n          .x6-widget-transform-resize {\n            border-radius: 0;\n          }\n          .x6-widget-selection-inner {\n            border: 1px solid #239edd;\n          }\n          .x6-widget-selection-box {\n            opacity: 0;\n          }\n        `)\n      }\n\n\n    })\n  },\n});\n</script>\n<style lang=\"less\" scoped>\n.antx {\n  height: 100%;\n  // border: 1px solid #ddd;\n  border-radius: 6px;\n  #container {\n    height: 100%;\n  }\n}\n</style>\n","/Users/wawalike/Desktop/ggProject/src/views/personalise/index.vue",[],"/Users/wawalike/Desktop/ggProject/src/views/animationX6/index.vue",["79","80","81","82","83"],"/Users/wawalike/Desktop/ggProject/src/views/animationX6/components/step.vue",["84"],{"ruleId":"85","severity":1,"message":"86","line":48,"column":58,"nodeType":"87","messageId":"88","endLine":48,"endColumn":64},{"ruleId":"85","severity":1,"message":"89","line":52,"column":11,"nodeType":"87","messageId":"88","endLine":52,"endColumn":17},{"ruleId":"85","severity":1,"message":"90","line":52,"column":18,"nodeType":"87","messageId":"88","endLine":52,"endColumn":22},{"ruleId":"91","severity":1,"message":"92","line":69,"column":35,"nodeType":"93","messageId":"94","endLine":69,"endColumn":42},{"ruleId":"91","severity":1,"message":"92","line":184,"column":22,"nodeType":"93","messageId":"94","endLine":184,"endColumn":59},{"ruleId":"85","severity":1,"message":"95","line":225,"column":34,"nodeType":"87","messageId":"88","endLine":225,"endColumn":44},{"ruleId":"91","severity":1,"message":"92","line":253,"column":50,"nodeType":"93","messageId":"94","endLine":253,"endColumn":58},{"ruleId":"96","severity":1,"message":"97","line":361,"column":34,"nodeType":"98","messageId":"99","endLine":361,"endColumn":37,"suggestions":"100"},{"ruleId":"85","severity":1,"message":"101","line":364,"column":28,"nodeType":"87","messageId":"88","endLine":364,"endColumn":34},{"ruleId":"96","severity":1,"message":"97","line":37,"column":15,"nodeType":"98","messageId":"99","endLine":37,"endColumn":18,"suggestions":"102"},{"ruleId":"85","severity":1,"message":"103","line":37,"column":20,"nodeType":"87","messageId":"88","endLine":37,"endColumn":23},{"ruleId":"85","severity":1,"message":"104","line":40,"column":11,"nodeType":"87","messageId":"88","endLine":40,"endColumn":32},{"ruleId":"85","severity":1,"message":"105","line":483,"column":49,"nodeType":"87","messageId":"88","endLine":483,"endColumn":50},{"ruleId":"91","severity":1,"message":"92","line":31,"column":33,"nodeType":"93","messageId":"94","endLine":31,"endColumn":40},{"ruleId":"91","severity":1,"message":"92","line":166,"column":20,"nodeType":"93","messageId":"94","endLine":166,"endColumn":63},{"ruleId":"85","severity":1,"message":"95","line":229,"column":32,"nodeType":"87","messageId":"88","endLine":229,"endColumn":42},{"ruleId":"91","severity":1,"message":"92","line":325,"column":50,"nodeType":"93","messageId":"94","endLine":325,"endColumn":58},{"ruleId":"91","severity":1,"message":"92","line":373,"column":7,"nodeType":"93","messageId":"94","endLine":373,"endColumn":42,"suggestions":"106"},{"ruleId":"91","severity":1,"message":"92","line":456,"column":27,"nodeType":"93","messageId":"94","endLine":456,"endColumn":70},{"ruleId":"91","severity":1,"message":"92","line":472,"column":27,"nodeType":"93","messageId":"94","endLine":472,"endColumn":70},{"ruleId":"85","severity":1,"message":"107","line":592,"column":13,"nodeType":"87","messageId":"88","endLine":592,"endColumn":15},{"ruleId":"96","severity":1,"message":"97","line":599,"column":26,"nodeType":"98","messageId":"99","endLine":599,"endColumn":29,"suggestions":"108"},{"ruleId":"91","severity":1,"message":"92","line":616,"column":27,"nodeType":"93","messageId":"94","endLine":616,"endColumn":64},{"ruleId":"85","severity":1,"message":"109","line":9,"column":23,"nodeType":"87","messageId":"88","endLine":9,"endColumn":27},{"ruleId":"85","severity":1,"message":"110","line":11,"column":8,"nodeType":"87","messageId":"88","endLine":11,"endColumn":17},{"ruleId":"85","severity":1,"message":"111","line":150,"column":19,"nodeType":"87","messageId":"88","endLine":150,"endColumn":33},{"ruleId":"91","severity":1,"message":"92","line":308,"column":28,"nodeType":"93","messageId":"94","endLine":308,"endColumn":65},{"ruleId":"85","severity":1,"message":"112","line":412,"column":21,"nodeType":"87","messageId":"88","endLine":412,"endColumn":35},{"ruleId":"85","severity":1,"message":"113","line":19,"column":12,"nodeType":"87","messageId":"88","endLine":19,"endColumn":17},"@typescript-eslint/no-unused-vars","'toRefs' is defined but never used.","Identifier","unusedVar","'_props' is defined but never used.","'_ctx' is defined but never used.","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull","'sourceView' is defined but never used.","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["114","115"],"'item' is defined but never used.",["116","117"],"'ctx' is defined but never used.","'HTMLElementTagNameMap' is defined but never used.","'e' is defined but never used.",["118"],"'r2' is assigned a value but never used.",["119","120"],"'Node' is defined but never used.","'insertCss' is defined but never used.","'nodeStatusList' is assigned a value but never used.","'showNodeStatus' is assigned a value but never used.","'Graph' is defined but never used.",{"messageId":"121","fix":"122","desc":"123"},{"messageId":"124","fix":"125","desc":"126"},{"messageId":"121","fix":"127","desc":"123"},{"messageId":"124","fix":"128","desc":"126"},{"messageId":"129","fix":"130","desc":"131"},{"messageId":"121","fix":"132","desc":"123"},{"messageId":"124","fix":"133","desc":"126"},"suggestUnknown",{"range":"134","text":"135"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"134","text":"136"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"137","text":"135"},{"range":"137","text":"136"},"suggestOptionalChain",{"range":"138","text":"139"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",{"range":"140","text":"135"},{"range":"140","text":"136"},[9900,9903],"unknown","never",[976,979],[10077,10078],"?",[15847,15850]]