{"ast":null,"code":"import { defineComponent, onMounted } from \"vue\";\nimport G6 from \"@antv/g6\";\nexport default defineComponent({\n  name: \"antV\",\n\n  setup() {\n    onMounted(() => {\n      /**\n       * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n       */\n      // let addedCount = 0;\n      // // Register a custom behavior: add a node when user click the blank part of canvas\n      // G6.registerBehavior('click-add-node', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         // The event is canvas:click, the responsing function is onClick\n      //         return {\n      //         'canvas:click': 'onClick',\n      //         };\n      //     },\n      //     // Click event\n      //     onClick(ev) {\n      //         const self = this;\n      //         const graph = self.graph;\n      //         // Add a new node\n      //         graph.addItem('node', {\n      //         x: ev.canvasX,\n      //         y: ev.canvasY,\n      //         id: `node-${addedCount}`, // Generate the unique id\n      //         });\n      //         addedCount++;\n      //     },\n      // });\n      // // Register a custom behavior: click two end nodes to add an edge\n      // G6.registerBehavior('click-add-edge', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         return {\n      //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n      //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n      //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n      //         };\n      //     },\n      //     // The responsing function for node:click defined in getEvents\n      //     onClick(ev) {\n      //         // console.log(1111)\n      //         // console.log(this)\n      //         const self = this;\n      //         const node = ev.item;\n      //         const graph = self.graph;\n      //         // The position where the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         const model = node.getModel();\n      //         if (self.addingEdge && self.edge) {\n      //         graph.updateItem(self.edge, {\n      //             target: model.id,\n      //         });\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         } else {\n      //         // Add anew edge, the end node is the current node user clicks\n      //         self.edge = graph.addItem('edge', {\n      //             source: model.id,\n      //             target: model.id,\n      //         });\n      //         self.addingEdge = true;\n      //         }\n      //     },\n      //     // The responsing function for mousemove defined in getEvents\n      //     onMousemove(ev) {\n      //         const self = this;\n      //         // The current position the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         if (self.addingEdge && self.edge) {\n      //         // Update the end node to the current node the mouse clicks\n      //         self.graph.updateItem(self.edge, {\n      //             target: point,\n      //         });\n      //         }\n      //     },\n      //     // The responsing function for edge:click defined in getEvents\n      //     onEdgeClick(ev) {\n      //         const self = this;\n      //         const currentEdge = ev.item;\n      //         if (self.addingEdge && self.edge === currentEdge) {\n      //         self.graph.removeItem(self.edge);\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         }\n      //     },\n      // });\n      // // Initial data\n      // const data = {\n      //     nodes: [\n      //         {\n      //         id: 'node1',\n      //         x: 100,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node2',\n      //         x: 300,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node3',\n      //         x: 300,\n      //         y: 300,\n      //         },\n      //     ],\n      //     edges: [\n      //         {\n      //         id: 'edge1',\n      //         target: 'node2',\n      //         source: 'node1',\n      //         },\n      //     ],\n      // };\n      // const container = document.getElementById('container');\n      // // Add a layout 及子元素\n      // const layoutBox = document.createElement('div');\n      // layoutBox.id = 'layoutBox';\n      // const layoutLeft = document.createElement('div');\n      // layoutLeft.id = 'layoutLeft';\n      // const layoutRight = document.createElement('div');\n      // layoutRight.id = 'layoutRight';\n      // // 设置layout样式\n      // layoutBox.style = \"height:100%;display:flex\"\n      // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n      // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n      // // 添加左侧元素\n      // const node = document.createElement('div');\n      // node.value = 'addNode'\n      // node.id = 'nodeId';\n      // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n      // // 添加样式元素到container\n      // layoutBox.appendChild(layoutLeft);\n      // layoutBox.appendChild(layoutRight);\n      // // container.appendChild(layoutBox);\n      // // 添加子元素到左侧\n      // layoutLeft.appendChild(node);\n      // // Add a selector to DOM\n      // const selector = document.createElement('select');\n      // selector.id = 'selector';\n      // selector.style.border = 'none';\n      // const selection1 = document.createElement('option');\n      // selection1.value = 'default';\n      // selection1.innerHTML = 'Default Mode';\n      // const selection2 = document.createElement('option');\n      // selection2.value = 'addNode';\n      // selection2.innerHTML = 'Add Node (By clicking canvas)';\n      // const selection3 = document.createElement('option');\n      // selection3.value = 'addEdge';\n      // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n      // selector.appendChild(selection1);\n      // selector.appendChild(selection2);\n      // selector.appendChild(selection3);\n      // container.appendChild(selector);\n      // const width = container.scrollWidth;\n      // const height = (container.scrollHeight || 500) - 30;\n      // const graph = new G6.Graph({\n      // container: 'container',\n      // width,\n      // height,\n      // // The sets of behavior modes\n      // modes: {\n      //     // Defualt mode\n      //     default: ['drag-node', 'click-select'],\n      //     // Adding node mode\n      //     addNode: ['click-add-node', 'click-select'],\n      //     // Adding edge mode\n      //     addEdge: ['click-add-edge', 'click-select'],\n      // },\n      // // The node styles in different states\n      // nodeStateStyles: {\n      //     // The node styles in selected state\n      //     selected: {\n      //         stroke: '#666',\n      //         lineWidth: 2,\n      //         fill: 'steelblue',\n      //     },\n      // },\n      // });\n      // graph.data(data);\n      // graph.render();\n      // // Listen to the selector, change the mode when the selector is changed\n      // selector.addEventListener('change', (e) => {\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // // 左侧长方形node元素点击事件\n      // node.addEventListener('click', (e) => {\n      //     console.log(e.target.value)\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // if (typeof window !== 'undefined')\n      // window.onresize = () => {\n      //     if (!graph || graph.get('destroyed')) return;\n      //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n      //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n      // };\n      // ---------------------------------------------------------------------------------------\n      // G6.Util.processParallelEdges processes the edges with same source node and target node,\n      // on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\n      const processParallelEdgesOnAnchorPoint = (edges, offsetDiff = 15, multiEdgeType = \"quadratic\", singleEdgeType = undefined, loopEdgeType = undefined) => {\n        debugger;\n        const len = edges.length;\n        const cod = offsetDiff * 2;\n        const loopPosition = [\"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\", \"top-left\"];\n        const edgeMap = {};\n        const tags = [];\n        const reverses = {};\n\n        for (let i = 0; i < len; i++) {\n          const edge = edges[i];\n          const {\n            source,\n            target,\n            sourceAnchor,\n            targetAnchor\n          } = edge;\n          const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n          if (tags[i]) continue;\n\n          if (!edgeMap[sourceTarget]) {\n            edgeMap[sourceTarget] = [];\n          }\n\n          tags[i] = true;\n          edgeMap[sourceTarget].push(edge);\n\n          for (let j = 0; j < len; j++) {\n            if (i === j) continue;\n            const sedge = edges[j];\n            const {\n              source: src,\n              target: dst,\n              sourceAnchor: srcAnchor,\n              targetAnchor: dstAnchor\n            } = sedge; // 两个节点之间共同的边\n            // 第一条的source = 第二条的target\n            // 第一条的target = 第二条的source\n\n            if (!tags[j]) {\n              if (source === dst && sourceAnchor === dstAnchor && target === src && targetAnchor === srcAnchor) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n                reverses[`${src}|${srcAnchor}|${dst}|${dstAnchor}|${edgeMap[sourceTarget].length - 1}`] = true;\n              } else if (source === src && sourceAnchor === srcAnchor && target === dst && targetAnchor === dstAnchor) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n              }\n            }\n          }\n        }\n\n        for (const key in edgeMap) {\n          const arcEdges = edgeMap[key];\n          const {\n            length\n          } = arcEdges;\n\n          for (let k = 0; k < length; k++) {\n            const current = arcEdges[k];\n\n            if (current.source === current.target) {\n              if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n              current.loopCfg = {\n                position: loopPosition[k % 8],\n                dist: Math.floor(k / 8) * 20 + 50\n              };\n              continue;\n            }\n\n            if (length === 1 && singleEdgeType && (current.source !== current.target || current.sourceAnchor !== current.targetAnchor)) {\n              current.type = singleEdgeType;\n              continue;\n            }\n\n            current.type = multiEdgeType;\n            const sign = (k % 2 === 0 ? 1 : -1) * (reverses[`${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`] ? -1 : 1);\n\n            if (length % 2 === 1) {\n              current.curveOffset = sign * Math.ceil(k / 2) * cod;\n            } else {\n              current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n            }\n          }\n        }\n\n        return edges;\n      };\n\n      const data = {\n        // 节点数据\n        nodes: [{\n          id: \"node1\",\n          x: 350,\n          y: 100\n        }, {\n          id: \"node2\",\n          x: 350,\n          y: 250\n        }]\n      }; // 新增节点按钮\n\n      const descriptionDiv = document.createElement(\"div\");\n      const container = document.getElementById(\"container\");\n      descriptionDiv.innerText = \"新增节点\";\n      descriptionDiv.style = \"width: 80px;height:34px;line-height:34px;text-align:center;border:1px solid #5ab4be;border-radius:4px;background:#5ab4be;color:#fff;cursor:pointer;margin:0 auto\";\n      container.appendChild(descriptionDiv); // custom a node with anchor-point shapes\n\n      G6.registerNode(\"rect-node\", {\n        // draw anchor-point circles according to the anchorPoints in afterDraw\n        afterDraw(cfg, group) {\n          const bbox = group.getBBox();\n          const anchorPoints = this.getAnchorPoints(cfg);\n          anchorPoints.forEach((anchorPos, i) => {\n            group.addShape(\"circle\", {\n              attrs: {\n                r: 5,\n                x: bbox.x + bbox.width * anchorPos[0],\n                y: bbox.y + bbox.height * anchorPos[1],\n                fill: \"#fff\",\n                stroke: \"#5F95FF\"\n              },\n              name: `anchor-point`,\n              // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n              anchorPointIdx: i,\n              // flag the idx of the anchor-point circle\n              links: 0,\n              // cache the number of edges connected to this shape\n              visible: false // invisible by default, shows up when links > 1 or the node is in showAnchors state\n\n            });\n          });\n        },\n\n        getAnchorPoints(cfg) {\n          return cfg.anchorPoints || [[0, 0.5], [0.33, 0], [0.66, 0], [1, 0.5], [0.33, 1], [0.66, 1]];\n        },\n\n        // response the state changes and show/hide the link-point circles\n        setState(name, value, item) {\n          if (name === \"showAnchors\") {\n            const anchorPoints = item.getContainer().findAll(ele => ele.get(\"name\") === \"anchor-point\");\n            anchorPoints.forEach(point => {\n              if (value || point.get(\"links\") > 0) point.show();else point.hide();\n            });\n          }\n        }\n\n      }, \"rect\");\n      let sourceAnchorIdx, targetAnchorIdx;\n      const width = container.scrollWidth;\n      const height = (container.scrollHeight || 500) - 20;\n      const graph = new G6.Graph({\n        container: \"container\",\n        width,\n        height,\n        modes: {\n          default: [\"drag-node\", // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n          {\n            type: \"create-edge\",\n            shouldBegin: e => {\n              // avoid beginning at other shapes on the node\n              if (e.target && e.target.get(\"name\") !== \"anchor-point\") return false;\n              sourceAnchorIdx = e.target.get(\"anchorPointIdx\");\n              e.target.set(\"links\", e.target.get(\"links\") + 1); // cache the number of edge connected to this anchor-point circle\n\n              return true;\n            },\n            shouldEnd: e => {\n              // avoid ending at other shapes on the node\n              if (e.target && e.target.get(\"name\") !== \"anchor-point\") return false;\n\n              if (e.target) {\n                targetAnchorIdx = e.target.get(\"anchorPointIdx\");\n                e.target.set(\"links\", e.target.get(\"links\") + 1); // cache the number of edge connected to this anchor-point circle\n\n                return true;\n              }\n\n              targetAnchorIdx = undefined;\n              return true;\n            } // update the sourceAnchor\n            // getEdgeConfig: () => {\n            //   return {\n            //     sourceAnchor: sourceAnchorIdx\n            //   }\n            // }\n\n          }]\n        },\n        defaultNode: {\n          type: \"rect-node\",\n          style: {\n            fill: \"#eee\",\n            stroke: \"#ccc\"\n          }\n        },\n        defaultEdge: {\n          type: \"quadratic\",\n          style: {\n            stroke: \"#F6BD16\",\n            lineWidth: 2\n          }\n        }\n      });\n      graph.data(data);\n      graph.render(); // 新增节点按钮事件\n\n      descriptionDiv.addEventListener(\"click\", e => {\n        data.nodes.push({\n          id: \"node\" + data.nodes.length + 1,\n          x: data.nodes[data.nodes.length - 1].x,\n          y: data.nodes[data.nodes.length - 1].y + 50\n        }); // chong hui\n\n        graph.data(data);\n        graph.render();\n      });\n      graph.on(\"aftercreateedge\", e => {\n        // update the sourceAnchor and targetAnchor for the newly added edge\n        graph.updateItem(e.edge, {\n          sourceAnchor: sourceAnchorIdx,\n          targetAnchor: targetAnchorIdx\n        }); // update the curveOffset for parallel edges\n\n        const edges = graph.save().edges;\n        processParallelEdgesOnAnchorPoint(edges);\n        graph.getEdges().forEach((edge, i) => {\n          graph.updateItem(edge, {\n            curveOffset: edges[i].curveOffset,\n            curvePosition: edges[i].curvePosition\n          });\n        });\n      }); // if create-edge is canceled before ending, update the 'links' on the anchor-point circles\n\n      graph.on(\"afterremoveitem\", e => {\n        if (e.item && e.item.source && e.item.target) {\n          const sourceNode = graph.findById(e.item.source);\n          const targetNode = graph.findById(e.item.target);\n          const {\n            sourceAnchor,\n            targetAnchor\n          } = e.item;\n\n          if (sourceNode && !isNaN(sourceAnchor)) {\n            const sourceAnchorShape = sourceNode.getContainer().find(ele => ele.get(\"name\") === \"anchor-point\" && ele.get(\"anchorPointIdx\") === sourceAnchor);\n            sourceAnchorShape.set(\"links\", sourceAnchorShape.get(\"links\") - 1);\n          }\n\n          if (targetNode && !isNaN(targetAnchor)) {\n            const targetAnchorShape = targetNode.getContainer().find(ele => ele.get(\"name\") === \"anchor-point\" && ele.get(\"anchorPointIdx\") === targetAnchor);\n            targetAnchorShape.set(\"links\", targetAnchorShape.get(\"links\") - 1);\n          }\n        }\n      }); // after clicking on the first node, the edge is created, update the sourceAnchor\n\n      graph.on(\"afteradditem\", e => {\n        if (e.item && e.item.getType() === \"edge\") {\n          graph.updateItem(e.item, {\n            sourceAnchor: sourceAnchorIdx\n          });\n        }\n      }); // some listeners to control the state of nodes to show and hide anchor-point circles\n\n      graph.on(\"node:mouseenter\", e => {\n        graph.setItemState(e.item, \"showAnchors\", true);\n      });\n      graph.on(\"node:mouseleave\", e => {\n        graph.setItemState(e.item, \"showAnchors\", false);\n      });\n      if (typeof window !== \"undefined\") window.onresize = () => {\n        if (!graph || graph.get(\"destroyed\")) return;\n        if (!container || !container.scrollWidth || !container.scrollHeight) return;\n        graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n      };\n    });\n  }\n\n});","map":{"version":3,"mappings":"AAMA,SAASA,eAAT,EAA0BC,SAA1B,QAA2C,KAA3C;AACA,OAAOC,EAAP,MAAe,UAAf;AACA,eAAeF,eAAe,CAAC;EAC7BG,IAAI,EAAE,MADuB;;EAE7BC,KAAK,GAAG;IACNH,SAAS,CAAC,MAAM;MACd;;;MAGA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMI,iCAAgC,GAAI,CACxCC,KADwC,EAExCC,UAAS,GAAI,EAF2B,EAGxCC,aAAY,GAAI,WAHwB,EAIxCC,cAAa,GAAIC,SAJuB,EAKxCC,YAAW,GAAID,SALyB,KAMrC;QACH;QACA,MAAME,GAAE,GAAIN,KAAK,CAACO,MAAlB;QACA,MAAMC,GAAE,GAAIP,UAAS,GAAI,CAAzB;QACA,MAAMQ,YAAW,GAAI,CACnB,KADmB,EAEnB,WAFmB,EAGnB,OAHmB,EAInB,cAJmB,EAKnB,QALmB,EAMnB,aANmB,EAOnB,MAPmB,EAQnB,UARmB,CAArB;QAUA,MAAMC,OAAM,GAAI,EAAhB;QACA,MAAMC,IAAG,GAAI,EAAb;QACA,MAAMC,QAAO,GAAI,EAAjB;;QACA,KAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIP,GAApB,EAAyBO,CAAC,EAA1B,EAA8B;UAC5B,MAAMC,IAAG,GAAId,KAAK,CAACa,CAAD,CAAlB;UACA,MAAM;YAAEE,MAAF;YAAUC,MAAV;YAAkBC,YAAlB;YAAgCC;UAAhC,IAAiDJ,IAAvD;UACA,MAAMK,YAAW,GAAK,GAAEJ,MAAO,IAAGE,YAAa,IAAGD,MAAO,IAAGE,YAAa,EAAzE;UAEA,IAAIP,IAAI,CAACE,CAAD,CAAR,EAAa;;UACb,IAAI,CAACH,OAAO,CAACS,YAAD,CAAZ,EAA4B;YAC1BT,OAAO,CAACS,YAAD,CAAP,GAAwB,EAAxB;UACF;;UACAR,IAAI,CAACE,CAAD,CAAJ,GAAU,IAAV;UACAH,OAAO,CAACS,YAAD,CAAP,CAAsBC,IAAtB,CAA2BN,IAA3B;;UACA,KAAK,IAAIO,IAAI,CAAb,EAAgBA,IAAIf,GAApB,EAAyBe,CAAC,EAA1B,EAA8B;YAC5B,IAAIR,MAAMQ,CAAV,EAAa;YACb,MAAMC,KAAI,GAAItB,KAAK,CAACqB,CAAD,CAAnB;YACA,MAAM;cACJN,MAAM,EAAEQ,GADJ;cAEJP,MAAM,EAAEQ,GAFJ;cAGJP,YAAY,EAAEQ,SAHV;cAIJP,YAAY,EAAEQ;YAJV,IAKFJ,KALJ,CAH4B,CAU5B;YACA;YACA;;YACA,IAAI,CAACX,IAAI,CAACU,CAAD,CAAT,EAAc;cACZ,IACEN,MAAK,KAAMS,GAAX,IACAP,YAAW,KAAMS,SADjB,IAEAV,MAAK,KAAMO,GAFX,IAGAL,YAAW,KAAMO,SAJnB,EAKE;gBACAf,OAAO,CAACS,YAAD,CAAP,CAAsBC,IAAtB,CAA2BE,KAA3B;gBACAX,IAAI,CAACU,CAAD,CAAJ,GAAU,IAAV;gBACAT,QAAQ,CACL,GAAEW,GAAI,IAAGE,SAAU,IAAGD,GAAI,IAAGE,SAAU,IACtChB,OAAO,CAACS,YAAD,CAAP,CAAsBZ,MAAtB,GAA+B,CAChC,EAHK,CAAR,GAII,IAJJ;cAKF,CAbA,MAaO,IACLQ,MAAK,KAAMQ,GAAX,IACAN,YAAW,KAAMQ,SADjB,IAEAT,MAAK,KAAMQ,GAFX,IAGAN,YAAW,KAAMQ,SAJZ,EAKL;gBACAhB,OAAO,CAACS,YAAD,CAAP,CAAsBC,IAAtB,CAA2BE,KAA3B;gBACAX,IAAI,CAACU,CAAD,CAAJ,GAAU,IAAV;cACF;YACF;UACF;QACF;;QAEA,KAAK,MAAMM,GAAX,IAAkBjB,OAAlB,EAA2B;UACzB,MAAMkB,QAAO,GAAIlB,OAAO,CAACiB,GAAD,CAAxB;UACA,MAAM;YAAEpB;UAAF,IAAaqB,QAAnB;;UACA,KAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAItB,MAApB,EAA4BsB,CAAC,EAA7B,EAAiC;YAC/B,MAAMC,OAAM,GAAIF,QAAQ,CAACC,CAAD,CAAxB;;YACA,IAAIC,OAAO,CAACf,MAAR,KAAmBe,OAAO,CAACd,MAA/B,EAAuC;cACrC,IAAIX,YAAJ,EAAkByB,OAAO,CAACC,IAAR,GAAe1B,YAAf,CADmB,CAErC;;cACAyB,OAAO,CAACE,OAAR,GAAkB;gBAChBC,QAAQ,EAAExB,YAAY,CAACoB,IAAI,CAAL,CADN;gBAEhBK,IAAI,EAAEC,IAAI,CAACC,KAAL,CAAWP,IAAI,CAAf,IAAoB,EAApB,GAAyB;cAFf,CAAlB;cAIA;YACF;;YACA,IACEtB,MAAK,KAAM,CAAX,IACAJ,cADA,KAEC2B,OAAO,CAACf,MAAR,KAAmBe,OAAO,CAACd,MAA3B,IACCc,OAAO,CAACb,YAAR,KAAyBa,OAAO,CAACZ,YAHnC,CADF,EAKE;cACAY,OAAO,CAACC,IAAR,GAAe5B,cAAf;cACA;YACF;;YACA2B,OAAO,CAACC,IAAR,GAAe7B,aAAf;YACA,MAAMmC,IAAG,GACP,CAACR,IAAI,CAAJ,KAAU,CAAV,GAAc,CAAd,GAAkB,CAAC,CAApB,KACCjB,QAAQ,CACN,GAAEkB,OAAO,CAACf,MAAO,IAAGe,OAAO,CAACb,YAAa,IAAGa,OAAO,CAACd,MAAO,IAAGc,OAAO,CAACZ,YAAa,IAAGW,CAAE,EADlF,CAAR,GAGG,CAAC,CAHJ,GAIG,CALJ,CADF;;YAOA,IAAItB,MAAK,GAAI,CAAT,KAAe,CAAnB,EAAsB;cACpBuB,OAAO,CAACQ,WAAR,GAAsBD,IAAG,GAAIF,IAAI,CAACI,IAAL,CAAUV,IAAI,CAAd,CAAP,GAA0BrB,GAAhD;YACF,CAFA,MAEO;cACLsB,OAAO,CAACQ,WAAR,GACED,IAAG,IAAKF,IAAI,CAACC,KAAL,CAAWP,IAAI,CAAf,IAAoBrB,GAApB,GAA0BP,UAA/B,CADL;YAEF;UACF;QACF;;QACA,OAAOD,KAAP;MACD,CAlHD;;MAoHA,MAAMwC,IAAG,GAAI;QACX;QACAC,KAAK,EAAE,CACL;UAAEC,EAAE,EAAE,OAAN;UAAeC,CAAC,EAAE,GAAlB;UAAuBC,CAAC,EAAE;QAA1B,CADK,EAEL;UAAEF,EAAE,EAAE,OAAN;UAAeC,CAAC,EAAE,GAAlB;UAAuBC,CAAC,EAAE;QAA1B,CAFK;MAFI,CAAb,CAlUc,CAyUd;;MACA,MAAMC,cAAa,GAAIC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAvB;MACA,MAAMC,SAAQ,GAAIF,QAAQ,CAACG,cAAT,CAAwB,WAAxB,CAAlB;MACAJ,cAAc,CAACK,SAAf,GAA2B,MAA3B;MACAL,cAAc,CAACM,KAAf,GACE,kKADF;MAEAH,SAAS,CAACI,WAAV,CAAsBP,cAAtB,EA/Uc,CAiVd;;MACAjD,EAAE,CAACyD,YAAH,CACE,WADF,EAEE;QACE;QACAC,SAAS,CAACC,GAAD,EAAMC,KAAN,EAAa;UACpB,MAAMC,IAAG,GAAID,KAAK,CAACE,OAAN,EAAb;UACA,MAAMC,YAAW,GAAI,KAAKC,eAAL,CAAqBL,GAArB,CAArB;UACAI,YAAY,CAACE,OAAb,CAAqB,CAACC,SAAD,EAAYjD,CAAZ,KAAkB;YACrC2C,KAAK,CAACO,QAAN,CAAe,QAAf,EAAyB;cACvBC,KAAK,EAAE;gBACLC,CAAC,EAAE,CADE;gBAELtB,CAAC,EAAEc,IAAI,CAACd,CAAL,GAASc,IAAI,CAACS,KAAL,GAAaJ,SAAS,CAAC,CAAD,CAF7B;gBAGLlB,CAAC,EAAEa,IAAI,CAACb,CAAL,GAASa,IAAI,CAACU,MAAL,GAAcL,SAAS,CAAC,CAAD,CAH9B;gBAILM,IAAI,EAAE,MAJD;gBAKLC,MAAM,EAAE;cALH,CADgB;cAQvBxE,IAAI,EAAG,cARgB;cAQD;cACtByE,cAAc,EAAEzD,CATO;cASJ;cACnB0D,KAAK,EAAE,CAVgB;cAUb;cACVC,OAAO,EAAE,KAXc,CAWP;;YAXO,CAAzB;UAaD,CAdD;QAeD,CApBH;;QAqBEZ,eAAe,CAACL,GAAD,EAAM;UACnB,OACEA,GAAG,CAACI,YAAJ,IAAoB,CAClB,CAAC,CAAD,EAAI,GAAJ,CADkB,EAElB,CAAC,IAAD,EAAO,CAAP,CAFkB,EAGlB,CAAC,IAAD,EAAO,CAAP,CAHkB,EAIlB,CAAC,CAAD,EAAI,GAAJ,CAJkB,EAKlB,CAAC,IAAD,EAAO,CAAP,CALkB,EAMlB,CAAC,IAAD,EAAO,CAAP,CANkB,CADtB;QAUD,CAhCH;;QAiCE;QACAc,QAAQ,CAAC5E,IAAD,EAAO6E,KAAP,EAAcC,IAAd,EAAoB;UAC1B,IAAI9E,IAAG,KAAM,aAAb,EAA4B;YAC1B,MAAM8D,YAAW,GAAIgB,IAAG,CACrBC,YADkB,GAElBC,OAFkB,CAETC,GAAD,IAASA,GAAG,CAACC,GAAJ,CAAQ,MAAR,MAAoB,cAFnB,CAArB;YAGApB,YAAY,CAACE,OAAb,CAAsBmB,KAAD,IAAW;cAC9B,IAAIN,KAAI,IAAKM,KAAK,CAACD,GAAN,CAAU,OAAV,IAAqB,CAAlC,EAAqCC,KAAK,CAACC,IAAN,GAArC,KACKD,KAAK,CAACE,IAAN;YACN,CAHD;UAIF;QACD;;MA5CH,CAFF,EAgDE,MAhDF;MAmDA,IAAIC,eAAJ,EAAqBC,eAArB;MAEA,MAAMlB,KAAI,GAAIlB,SAAS,CAACqC,WAAxB;MACA,MAAMlB,MAAK,GAAI,CAACnB,SAAS,CAACsC,YAAV,IAA0B,GAA3B,IAAkC,EAAjD;MACA,MAAMC,KAAI,GAAI,IAAI3F,EAAE,CAAC4F,KAAP,CAAa;QACzBxC,SAAS,EAAE,WADc;QAEzBkB,KAFyB;QAGzBC,MAHyB;QAIzBsB,KAAK,EAAE;UACLC,OAAO,EAAE,CACP,WADO,EAEP;UACA;YACE3D,IAAI,EAAE,aADR;YAEE4D,WAAW,EAAGC,CAAD,IAAO;cAClB;cACA,IAAIA,CAAC,CAAC5E,MAAF,IAAY4E,CAAC,CAAC5E,MAAF,CAAS+D,GAAT,CAAa,MAAb,MAAyB,cAAzC,EACE,OAAO,KAAP;cACFI,eAAc,GAAIS,CAAC,CAAC5E,MAAF,CAAS+D,GAAT,CAAa,gBAAb,CAAlB;cACAa,CAAC,CAAC5E,MAAF,CAAS6E,GAAT,CAAa,OAAb,EAAsBD,CAAC,CAAC5E,MAAF,CAAS+D,GAAT,CAAa,OAAb,IAAwB,CAA9C,EALkB,CAKgC;;cAClD,OAAO,IAAP;YACD,CATH;YAUEe,SAAS,EAAGF,CAAD,IAAO;cAChB;cACA,IAAIA,CAAC,CAAC5E,MAAF,IAAY4E,CAAC,CAAC5E,MAAF,CAAS+D,GAAT,CAAa,MAAb,MAAyB,cAAzC,EACE,OAAO,KAAP;;cACF,IAAIa,CAAC,CAAC5E,MAAN,EAAc;gBACZoE,eAAc,GAAIQ,CAAC,CAAC5E,MAAF,CAAS+D,GAAT,CAAa,gBAAb,CAAlB;gBACAa,CAAC,CAAC5E,MAAF,CAAS6E,GAAT,CAAa,OAAb,EAAsBD,CAAC,CAAC5E,MAAF,CAAS+D,GAAT,CAAa,OAAb,IAAwB,CAA9C,EAFY,CAEsC;;gBAClD,OAAO,IAAP;cACF;;cACAK,eAAc,GAAIhF,SAAlB;cACA,OAAO,IAAP;YACD,CArBH,CAsBE;YACA;YACA;YACA;YACA;YACA;;UA3BF,CAHO;QADJ,CAJkB;QAuCzB2F,WAAW,EAAE;UACXhE,IAAI,EAAE,WADK;UAEXoB,KAAK,EAAE;YACLiB,IAAI,EAAE,MADD;YAELC,MAAM,EAAE;UAFH;QAFI,CAvCY;QA8CzB2B,WAAW,EAAE;UACXjE,IAAI,EAAE,WADK;UAEXoB,KAAK,EAAE;YACLkB,MAAM,EAAE,SADH;YAEL4B,SAAS,EAAE;UAFN;QAFI;MA9CY,CAAb,CAAd;MAuDAV,KAAK,CAAC/C,IAAN,CAAWA,IAAX;MACA+C,KAAK,CAACW,MAAN,GAjcc,CAkcd;;MACArD,cAAc,CAACsD,gBAAf,CAAgC,OAAhC,EAA0CP,CAAD,IAAO;QAC5CpD,IAAI,CAACC,KAAL,CAAWrB,IAAX,CAAgB;UACZsB,EAAE,EAAE,SAASF,IAAI,CAACC,KAAL,CAAWlC,MAApB,GAA2B,CADnB;UAEdoC,CAAC,EAAEH,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACC,KAAL,CAAWlC,MAAX,GAAoB,CAA/B,EAAkCoC,CAFvB;UAGdC,CAAC,EAAGJ,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACC,KAAL,CAAWlC,MAAX,GAAoB,CAA/B,EAAkCqC,CAAlC,GAAsC;QAH5B,CAAhB,EAD4C,CAM9C;;QACA2C,KAAK,CAAC/C,IAAN,CAAWA,IAAX;QACA+C,KAAK,CAACW,MAAN;MACD,CATD;MAUAX,KAAK,CAACa,EAAN,CAAS,iBAAT,EAA6BR,CAAD,IAAO;QACjC;QACAL,KAAK,CAACc,UAAN,CAAiBT,CAAC,CAAC9E,IAAnB,EAAyB;UACvBG,YAAY,EAAEkE,eADS;UAEvBjE,YAAY,EAAEkE;QAFS,CAAzB,EAFiC,CAOjC;;QACA,MAAMpF,KAAI,GAAIuF,KAAK,CAACe,IAAN,GAAatG,KAA3B;QACAD,iCAAiC,CAACC,KAAD,CAAjC;QACAuF,KAAK,CAACgB,QAAN,GAAiB1C,OAAjB,CAAyB,CAAC/C,IAAD,EAAOD,CAAP,KAAa;UACpC0E,KAAK,CAACc,UAAN,CAAiBvF,IAAjB,EAAuB;YACrBwB,WAAW,EAAEtC,KAAK,CAACa,CAAD,CAAL,CAASyB,WADD;YAErBkE,aAAa,EAAExG,KAAK,CAACa,CAAD,CAAL,CAAS2F;UAFH,CAAvB;QAID,CALD;MAMD,CAhBD,EA7cc,CA+dd;;MACAjB,KAAK,CAACa,EAAN,CAAS,iBAAT,EAA6BR,CAAD,IAAO;QACjC,IAAIA,CAAC,CAACjB,IAAF,IAAUiB,CAAC,CAACjB,IAAF,CAAO5D,MAAjB,IAA2B6E,CAAC,CAACjB,IAAF,CAAO3D,MAAtC,EAA8C;UAC5C,MAAMyF,UAAS,GAAIlB,KAAK,CAACmB,QAAN,CAAed,CAAC,CAACjB,IAAF,CAAO5D,MAAtB,CAAnB;UACA,MAAM4F,UAAS,GAAIpB,KAAK,CAACmB,QAAN,CAAed,CAAC,CAACjB,IAAF,CAAO3D,MAAtB,CAAnB;UACA,MAAM;YAAEC,YAAF;YAAgBC;UAAhB,IAAiC0E,CAAC,CAACjB,IAAzC;;UACA,IAAI8B,UAAS,IAAK,CAACG,KAAK,CAAC3F,YAAD,CAAxB,EAAwC;YACtC,MAAM4F,iBAAgB,GAAIJ,UAAS,CAChC7B,YADuB,GAEvBkC,IAFuB,CAGrBhC,GAAD,IACEA,GAAG,CAACC,GAAJ,CAAQ,MAAR,MAAoB,cAApB,IACAD,GAAG,CAACC,GAAJ,CAAQ,gBAAR,MAA8B9D,YALV,CAA1B;YAOA4F,iBAAiB,CAAChB,GAAlB,CAAsB,OAAtB,EAA+BgB,iBAAiB,CAAC9B,GAAlB,CAAsB,OAAtB,IAAiC,CAAhE;UACF;;UACA,IAAI4B,UAAS,IAAK,CAACC,KAAK,CAAC1F,YAAD,CAAxB,EAAwC;YACtC,MAAM6F,iBAAgB,GAAIJ,UAAS,CAChC/B,YADuB,GAEvBkC,IAFuB,CAGrBhC,GAAD,IACEA,GAAG,CAACC,GAAJ,CAAQ,MAAR,MAAoB,cAApB,IACAD,GAAG,CAACC,GAAJ,CAAQ,gBAAR,MAA8B7D,YALV,CAA1B;YAOA6F,iBAAiB,CAAClB,GAAlB,CAAsB,OAAtB,EAA+BkB,iBAAiB,CAAChC,GAAlB,CAAsB,OAAtB,IAAiC,CAAhE;UACF;QACF;MACD,CA1BD,EAhec,CA4fd;;MACAQ,KAAK,CAACa,EAAN,CAAS,cAAT,EAA0BR,CAAD,IAAO;QAC9B,IAAIA,CAAC,CAACjB,IAAF,IAAUiB,CAAC,CAACjB,IAAF,CAAOqC,OAAP,OAAqB,MAAnC,EAA2C;UACzCzB,KAAK,CAACc,UAAN,CAAiBT,CAAC,CAACjB,IAAnB,EAAyB;YACvB1D,YAAY,EAAEkE;UADS,CAAzB;QAGF;MACD,CAND,EA7fc,CAqgBd;;MACAI,KAAK,CAACa,EAAN,CAAS,iBAAT,EAA6BR,CAAD,IAAO;QACjCL,KAAK,CAAC0B,YAAN,CAAmBrB,CAAC,CAACjB,IAArB,EAA2B,aAA3B,EAA0C,IAA1C;MACD,CAFD;MAGAY,KAAK,CAACa,EAAN,CAAS,iBAAT,EAA6BR,CAAD,IAAO;QACjCL,KAAK,CAAC0B,YAAN,CAAmBrB,CAAC,CAACjB,IAArB,EAA2B,aAA3B,EAA0C,KAA1C;MACD,CAFD;MAIA,IAAI,OAAOuC,MAAP,KAAkB,WAAtB,EACEA,MAAM,CAACC,QAAP,GAAkB,MAAM;QACtB,IAAI,CAAC5B,KAAD,IAAUA,KAAK,CAACR,GAAN,CAAU,WAAV,CAAd,EAAsC;QACtC,IAAI,CAAC/B,SAAD,IAAc,CAACA,SAAS,CAACqC,WAAzB,IAAwC,CAACrC,SAAS,CAACsC,YAAvD,EACE;QACFC,KAAK,CAAC6B,UAAN,CAAiBpE,SAAS,CAACqC,WAA3B,EAAwCrC,SAAS,CAACsC,YAAV,GAAyB,EAAjE;MACD,CALD;IAMH,CAphBQ,CAAT;EAqhBD;;AAxhB4B,CAAD,CAA9B","names":["defineComponent","onMounted","G6","name","setup","processParallelEdgesOnAnchorPoint","edges","offsetDiff","multiEdgeType","singleEdgeType","undefined","loopEdgeType","len","length","cod","loopPosition","edgeMap","tags","reverses","i","edge","source","target","sourceAnchor","targetAnchor","sourceTarget","push","j","sedge","src","dst","srcAnchor","dstAnchor","key","arcEdges","k","current","type","loopCfg","position","dist","Math","floor","sign","curveOffset","ceil","data","nodes","id","x","y","descriptionDiv","document","createElement","container","getElementById","innerText","style","appendChild","registerNode","afterDraw","cfg","group","bbox","getBBox","anchorPoints","getAnchorPoints","forEach","anchorPos","addShape","attrs","r","width","height","fill","stroke","anchorPointIdx","links","visible","setState","value","item","getContainer","findAll","ele","get","point","show","hide","sourceAnchorIdx","targetAnchorIdx","scrollWidth","scrollHeight","graph","Graph","modes","default","shouldBegin","e","set","shouldEnd","defaultNode","defaultEdge","lineWidth","render","addEventListener","on","updateItem","save","getEdges","curvePosition","sourceNode","findById","targetNode","isNaN","sourceAnchorShape","find","targetAnchorShape","getType","setItemState","window","onresize","changeSize"],"sourceRoot":"","sources":["/Users/wawalike/Desktop/ggProject/src/views/antv/index.vue"],"sourcesContent":["<template>\n  <div class=\"antv\">\n    <div id=\"container\"></div>\n  </div>\n</template>\n<script>\nimport { defineComponent, onMounted } from \"vue\";\nimport G6 from \"@antv/g6\";\nexport default defineComponent({\n  name: \"antV\",\n  setup() {\n    onMounted(() => {\n      /**\n       * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n       */\n      // let addedCount = 0;\n      // // Register a custom behavior: add a node when user click the blank part of canvas\n      // G6.registerBehavior('click-add-node', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         // The event is canvas:click, the responsing function is onClick\n      //         return {\n      //         'canvas:click': 'onClick',\n      //         };\n      //     },\n      //     // Click event\n      //     onClick(ev) {\n      //         const self = this;\n      //         const graph = self.graph;\n      //         // Add a new node\n      //         graph.addItem('node', {\n      //         x: ev.canvasX,\n      //         y: ev.canvasY,\n      //         id: `node-${addedCount}`, // Generate the unique id\n      //         });\n      //         addedCount++;\n      //     },\n      // });\n      // // Register a custom behavior: click two end nodes to add an edge\n      // G6.registerBehavior('click-add-edge', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         return {\n      //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n      //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n      //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n      //         };\n      //     },\n      //     // The responsing function for node:click defined in getEvents\n      //     onClick(ev) {\n      //         // console.log(1111)\n      //         // console.log(this)\n      //         const self = this;\n      //         const node = ev.item;\n      //         const graph = self.graph;\n      //         // The position where the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         const model = node.getModel();\n      //         if (self.addingEdge && self.edge) {\n      //         graph.updateItem(self.edge, {\n      //             target: model.id,\n      //         });\n\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         } else {\n      //         // Add anew edge, the end node is the current node user clicks\n      //         self.edge = graph.addItem('edge', {\n      //             source: model.id,\n      //             target: model.id,\n      //         });\n      //         self.addingEdge = true;\n      //         }\n      //     },\n      //     // The responsing function for mousemove defined in getEvents\n      //     onMousemove(ev) {\n      //         const self = this;\n      //         // The current position the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         if (self.addingEdge && self.edge) {\n      //         // Update the end node to the current node the mouse clicks\n      //         self.graph.updateItem(self.edge, {\n      //             target: point,\n      //         });\n      //         }\n      //     },\n      //     // The responsing function for edge:click defined in getEvents\n      //     onEdgeClick(ev) {\n      //         const self = this;\n      //         const currentEdge = ev.item;\n      //         if (self.addingEdge && self.edge === currentEdge) {\n      //         self.graph.removeItem(self.edge);\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         }\n      //     },\n      // });\n      // // Initial data\n      // const data = {\n      //     nodes: [\n      //         {\n      //         id: 'node1',\n      //         x: 100,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node2',\n      //         x: 300,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node3',\n      //         x: 300,\n      //         y: 300,\n      //         },\n      //     ],\n      //     edges: [\n      //         {\n      //         id: 'edge1',\n      //         target: 'node2',\n      //         source: 'node1',\n      //         },\n      //     ],\n      // };\n\n      // const container = document.getElementById('container');\n      // // Add a layout 及子元素\n      // const layoutBox = document.createElement('div');\n      // layoutBox.id = 'layoutBox';\n      // const layoutLeft = document.createElement('div');\n      // layoutLeft.id = 'layoutLeft';\n      // const layoutRight = document.createElement('div');\n      // layoutRight.id = 'layoutRight';\n      // // 设置layout样式\n      // layoutBox.style = \"height:100%;display:flex\"\n      // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n      // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n      // // 添加左侧元素\n      // const node = document.createElement('div');\n      // node.value = 'addNode'\n      // node.id = 'nodeId';\n      // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n      // // 添加样式元素到container\n      // layoutBox.appendChild(layoutLeft);\n      // layoutBox.appendChild(layoutRight);\n      // // container.appendChild(layoutBox);\n      // // 添加子元素到左侧\n      // layoutLeft.appendChild(node);\n      // // Add a selector to DOM\n      // const selector = document.createElement('select');\n      // selector.id = 'selector';\n      // selector.style.border = 'none';\n      // const selection1 = document.createElement('option');\n      // selection1.value = 'default';\n      // selection1.innerHTML = 'Default Mode';\n      // const selection2 = document.createElement('option');\n      // selection2.value = 'addNode';\n      // selection2.innerHTML = 'Add Node (By clicking canvas)';\n      // const selection3 = document.createElement('option');\n      // selection3.value = 'addEdge';\n      // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n      // selector.appendChild(selection1);\n      // selector.appendChild(selection2);\n      // selector.appendChild(selection3);\n      // container.appendChild(selector);\n\n      // const width = container.scrollWidth;\n      // const height = (container.scrollHeight || 500) - 30;\n      // const graph = new G6.Graph({\n      // container: 'container',\n      // width,\n      // height,\n      // // The sets of behavior modes\n      // modes: {\n      //     // Defualt mode\n      //     default: ['drag-node', 'click-select'],\n      //     // Adding node mode\n      //     addNode: ['click-add-node', 'click-select'],\n      //     // Adding edge mode\n      //     addEdge: ['click-add-edge', 'click-select'],\n      // },\n      // // The node styles in different states\n      // nodeStateStyles: {\n      //     // The node styles in selected state\n      //     selected: {\n      //         stroke: '#666',\n      //         lineWidth: 2,\n      //         fill: 'steelblue',\n      //     },\n      // },\n      // });\n      // graph.data(data);\n      // graph.render();\n\n      // // Listen to the selector, change the mode when the selector is changed\n      // selector.addEventListener('change', (e) => {\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // // 左侧长方形node元素点击事件\n      // node.addEventListener('click', (e) => {\n      //     console.log(e.target.value)\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n\n      // if (typeof window !== 'undefined')\n      // window.onresize = () => {\n      //     if (!graph || graph.get('destroyed')) return;\n      //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n      //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n      // };\n      // ---------------------------------------------------------------------------------------\n      // G6.Util.processParallelEdges processes the edges with same source node and target node,\n      // on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\n      const processParallelEdgesOnAnchorPoint = (\n        edges,\n        offsetDiff = 15,\n        multiEdgeType = \"quadratic\",\n        singleEdgeType = undefined,\n        loopEdgeType = undefined\n      ) => {\n        debugger;\n        const len = edges.length;\n        const cod = offsetDiff * 2;\n        const loopPosition = [\n          \"top\",\n          \"top-right\",\n          \"right\",\n          \"bottom-right\",\n          \"bottom\",\n          \"bottom-left\",\n          \"left\",\n          \"top-left\",\n        ];\n        const edgeMap = {};\n        const tags = [];\n        const reverses = {};\n        for (let i = 0; i < len; i++) {\n          const edge = edges[i];\n          const { source, target, sourceAnchor, targetAnchor } = edge;\n          const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n\n          if (tags[i]) continue;\n          if (!edgeMap[sourceTarget]) {\n            edgeMap[sourceTarget] = [];\n          }\n          tags[i] = true;\n          edgeMap[sourceTarget].push(edge);\n          for (let j = 0; j < len; j++) {\n            if (i === j) continue;\n            const sedge = edges[j];\n            const {\n              source: src,\n              target: dst,\n              sourceAnchor: srcAnchor,\n              targetAnchor: dstAnchor,\n            } = sedge;\n\n            // 两个节点之间共同的边\n            // 第一条的source = 第二条的target\n            // 第一条的target = 第二条的source\n            if (!tags[j]) {\n              if (\n                source === dst &&\n                sourceAnchor === dstAnchor &&\n                target === src &&\n                targetAnchor === srcAnchor\n              ) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n                reverses[\n                  `${src}|${srcAnchor}|${dst}|${dstAnchor}|${\n                    edgeMap[sourceTarget].length - 1\n                  }`\n                ] = true;\n              } else if (\n                source === src &&\n                sourceAnchor === srcAnchor &&\n                target === dst &&\n                targetAnchor === dstAnchor\n              ) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n              }\n            }\n          }\n        }\n\n        for (const key in edgeMap) {\n          const arcEdges = edgeMap[key];\n          const { length } = arcEdges;\n          for (let k = 0; k < length; k++) {\n            const current = arcEdges[k];\n            if (current.source === current.target) {\n              if (loopEdgeType) current.type = loopEdgeType;\n              // 超过8条自环边，则需要重新处理\n              current.loopCfg = {\n                position: loopPosition[k % 8],\n                dist: Math.floor(k / 8) * 20 + 50,\n              };\n              continue;\n            }\n            if (\n              length === 1 &&\n              singleEdgeType &&\n              (current.source !== current.target ||\n                current.sourceAnchor !== current.targetAnchor)\n            ) {\n              current.type = singleEdgeType;\n              continue;\n            }\n            current.type = multiEdgeType;\n            const sign =\n              (k % 2 === 0 ? 1 : -1) *\n              (reverses[\n                `${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`\n              ]\n                ? -1\n                : 1);\n            if (length % 2 === 1) {\n              current.curveOffset = sign * Math.ceil(k / 2) * cod;\n            } else {\n              current.curveOffset =\n                sign * (Math.floor(k / 2) * cod + offsetDiff);\n            }\n          }\n        }\n        return edges;\n      };\n\n      const data = {\n        // 节点数据\n        nodes: [\n          { id: \"node1\", x: 350, y: 100 },\n          { id: \"node2\", x: 350, y: 250 }\n        ],\n      };\n      // 新增节点按钮\n      const descriptionDiv = document.createElement(\"div\");\n      const container = document.getElementById(\"container\");\n      descriptionDiv.innerText = \"新增节点\";\n      descriptionDiv.style =\n        \"width: 80px;height:34px;line-height:34px;text-align:center;border:1px solid #5ab4be;border-radius:4px;background:#5ab4be;color:#fff;cursor:pointer;margin:0 auto\";\n      container.appendChild(descriptionDiv);\n\n      // custom a node with anchor-point shapes\n      G6.registerNode(\n        \"rect-node\",\n        {\n          // draw anchor-point circles according to the anchorPoints in afterDraw\n          afterDraw(cfg, group) {\n            const bbox = group.getBBox();\n            const anchorPoints = this.getAnchorPoints(cfg);\n            anchorPoints.forEach((anchorPos, i) => {\n              group.addShape(\"circle\", {\n                attrs: {\n                  r: 5,\n                  x: bbox.x + bbox.width * anchorPos[0],\n                  y: bbox.y + bbox.height * anchorPos[1],\n                  fill: \"#fff\",\n                  stroke: \"#5F95FF\",\n                },\n                name: `anchor-point`, // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n                anchorPointIdx: i, // flag the idx of the anchor-point circle\n                links: 0, // cache the number of edges connected to this shape\n                visible: false, // invisible by default, shows up when links > 1 or the node is in showAnchors state\n              });\n            });\n          },\n          getAnchorPoints(cfg) {\n            return (\n              cfg.anchorPoints || [\n                [0, 0.5],\n                [0.33, 0],\n                [0.66, 0],\n                [1, 0.5],\n                [0.33, 1],\n                [0.66, 1],\n              ]\n            );\n          },\n          // response the state changes and show/hide the link-point circles\n          setState(name, value, item) {\n            if (name === \"showAnchors\") {\n              const anchorPoints = item\n                .getContainer()\n                .findAll((ele) => ele.get(\"name\") === \"anchor-point\");\n              anchorPoints.forEach((point) => {\n                if (value || point.get(\"links\") > 0) point.show();\n                else point.hide();\n              });\n            }\n          },\n        },\n        \"rect\"\n      );\n\n      let sourceAnchorIdx, targetAnchorIdx;\n\n      const width = container.scrollWidth;\n      const height = (container.scrollHeight || 500) - 20;\n      const graph = new G6.Graph({\n        container: \"container\",\n        width,\n        height,\n        modes: {\n          default: [\n            \"drag-node\",\n            // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n            {\n              type: \"create-edge\",\n              shouldBegin: (e) => {\n                // avoid beginning at other shapes on the node\n                if (e.target && e.target.get(\"name\") !== \"anchor-point\")\n                  return false;\n                sourceAnchorIdx = e.target.get(\"anchorPointIdx\");\n                e.target.set(\"links\", e.target.get(\"links\") + 1); // cache the number of edge connected to this anchor-point circle\n                return true;\n              },\n              shouldEnd: (e) => {\n                // avoid ending at other shapes on the node\n                if (e.target && e.target.get(\"name\") !== \"anchor-point\")\n                  return false;\n                if (e.target) {\n                  targetAnchorIdx = e.target.get(\"anchorPointIdx\");\n                  e.target.set(\"links\", e.target.get(\"links\") + 1); // cache the number of edge connected to this anchor-point circle\n                  return true;\n                }\n                targetAnchorIdx = undefined;\n                return true;\n              },\n              // update the sourceAnchor\n              // getEdgeConfig: () => {\n              //   return {\n              //     sourceAnchor: sourceAnchorIdx\n              //   }\n              // }\n            },\n          ],\n        },\n        defaultNode: {\n          type: \"rect-node\",\n          style: {\n            fill: \"#eee\",\n            stroke: \"#ccc\",\n          },\n        },\n        defaultEdge: {\n          type: \"quadratic\",\n          style: {\n            stroke: \"#F6BD16\",\n            lineWidth: 2,\n          },\n        },\n      });\n\n      graph.data(data);\n      graph.render();\n      // 新增节点按钮事件\n      descriptionDiv.addEventListener(\"click\", (e) => {\n          data.nodes.push({ \n              id: \"node\" + data.nodes.length+1,\n            x: data.nodes[data.nodes.length - 1].x,\n            y:  data.nodes[data.nodes.length - 1].y + 50\n        });\n        // chong hui\n        graph.data(data);\n        graph.render();\n      });\n      graph.on(\"aftercreateedge\", (e) => {\n        // update the sourceAnchor and targetAnchor for the newly added edge\n        graph.updateItem(e.edge, {\n          sourceAnchor: sourceAnchorIdx,\n          targetAnchor: targetAnchorIdx,\n        });\n\n        // update the curveOffset for parallel edges\n        const edges = graph.save().edges;\n        processParallelEdgesOnAnchorPoint(edges);\n        graph.getEdges().forEach((edge, i) => {\n          graph.updateItem(edge, {\n            curveOffset: edges[i].curveOffset,\n            curvePosition: edges[i].curvePosition,\n          });\n        });\n      });\n\n      // if create-edge is canceled before ending, update the 'links' on the anchor-point circles\n      graph.on(\"afterremoveitem\", (e) => {\n        if (e.item && e.item.source && e.item.target) {\n          const sourceNode = graph.findById(e.item.source);\n          const targetNode = graph.findById(e.item.target);\n          const { sourceAnchor, targetAnchor } = e.item;\n          if (sourceNode && !isNaN(sourceAnchor)) {\n            const sourceAnchorShape = sourceNode\n              .getContainer()\n              .find(\n                (ele) =>\n                  ele.get(\"name\") === \"anchor-point\" &&\n                  ele.get(\"anchorPointIdx\") === sourceAnchor\n              );\n            sourceAnchorShape.set(\"links\", sourceAnchorShape.get(\"links\") - 1);\n          }\n          if (targetNode && !isNaN(targetAnchor)) {\n            const targetAnchorShape = targetNode\n              .getContainer()\n              .find(\n                (ele) =>\n                  ele.get(\"name\") === \"anchor-point\" &&\n                  ele.get(\"anchorPointIdx\") === targetAnchor\n              );\n            targetAnchorShape.set(\"links\", targetAnchorShape.get(\"links\") - 1);\n          }\n        }\n      });\n\n      // after clicking on the first node, the edge is created, update the sourceAnchor\n      graph.on(\"afteradditem\", (e) => {\n        if (e.item && e.item.getType() === \"edge\") {\n          graph.updateItem(e.item, {\n            sourceAnchor: sourceAnchorIdx,\n          });\n        }\n      });\n\n      // some listeners to control the state of nodes to show and hide anchor-point circles\n      graph.on(\"node:mouseenter\", (e) => {\n        graph.setItemState(e.item, \"showAnchors\", true);\n      });\n      graph.on(\"node:mouseleave\", (e) => {\n        graph.setItemState(e.item, \"showAnchors\", false);\n      });\n\n      if (typeof window !== \"undefined\")\n        window.onresize = () => {\n          if (!graph || graph.get(\"destroyed\")) return;\n          if (!container || !container.scrollWidth || !container.scrollHeight)\n            return;\n          graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n        };\n    });\n  },\n});\n</script>\n<style lang=\"less\" scoped>\n.antv {\n  height: 100%;\n  // border: 1px solid #ddd;\n  border-radius: 6px;\n  #container {\n    height: 100%;\n  }\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}