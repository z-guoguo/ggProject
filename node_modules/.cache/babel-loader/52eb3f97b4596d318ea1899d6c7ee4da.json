{"ast":null,"code":"import { defineComponent, onMounted } from 'vue';\nimport G6 from '@antv/g6';\nexport default defineComponent({\n  name: 'antV',\n\n  setup() {\n    onMounted(() => {\n      /**\n       * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n       */\n      // let addedCount = 0;\n      // // Register a custom behavior: add a node when user click the blank part of canvas\n      // G6.registerBehavior('click-add-node', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         // The event is canvas:click, the responsing function is onClick\n      //         return {\n      //         'canvas:click': 'onClick',\n      //         };\n      //     },\n      //     // Click event\n      //     onClick(ev) {\n      //         const self = this;\n      //         const graph = self.graph;\n      //         // Add a new node\n      //         graph.addItem('node', {\n      //         x: ev.canvasX,\n      //         y: ev.canvasY,\n      //         id: `node-${addedCount}`, // Generate the unique id\n      //         });\n      //         addedCount++;\n      //     },\n      // });\n      // // Register a custom behavior: click two end nodes to add an edge\n      // G6.registerBehavior('click-add-edge', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         return {\n      //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n      //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n      //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n      //         };\n      //     },\n      //     // The responsing function for node:click defined in getEvents\n      //     onClick(ev) {\n      //         // console.log(1111)\n      //         // console.log(this)\n      //         const self = this;\n      //         const node = ev.item;\n      //         const graph = self.graph;\n      //         // The position where the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         const model = node.getModel();\n      //         if (self.addingEdge && self.edge) {\n      //         graph.updateItem(self.edge, {\n      //             target: model.id,\n      //         });\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         } else {\n      //         // Add anew edge, the end node is the current node user clicks\n      //         self.edge = graph.addItem('edge', {\n      //             source: model.id,\n      //             target: model.id,\n      //         });\n      //         self.addingEdge = true;\n      //         }\n      //     },\n      //     // The responsing function for mousemove defined in getEvents\n      //     onMousemove(ev) {\n      //         const self = this;\n      //         // The current position the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         if (self.addingEdge && self.edge) {\n      //         // Update the end node to the current node the mouse clicks\n      //         self.graph.updateItem(self.edge, {\n      //             target: point,\n      //         });\n      //         }\n      //     },\n      //     // The responsing function for edge:click defined in getEvents\n      //     onEdgeClick(ev) {\n      //         const self = this;\n      //         const currentEdge = ev.item;\n      //         if (self.addingEdge && self.edge === currentEdge) {\n      //         self.graph.removeItem(self.edge);\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         }\n      //     },\n      // });\n      // // Initial data\n      // const data = {\n      //     nodes: [\n      //         {\n      //         id: 'node1',\n      //         x: 100,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node2',\n      //         x: 300,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node3',\n      //         x: 300,\n      //         y: 300,\n      //         },\n      //     ],\n      //     edges: [\n      //         {\n      //         id: 'edge1',\n      //         target: 'node2',\n      //         source: 'node1',\n      //         },\n      //     ],\n      // };\n      // const container = document.getElementById('container');\n      // // Add a layout 及子元素\n      // const layoutBox = document.createElement('div');\n      // layoutBox.id = 'layoutBox';\n      // const layoutLeft = document.createElement('div');\n      // layoutLeft.id = 'layoutLeft';\n      // const layoutRight = document.createElement('div');\n      // layoutRight.id = 'layoutRight';\n      // // 设置layout样式\n      // layoutBox.style = \"height:100%;display:flex\"\n      // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n      // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n      // // 添加左侧元素\n      // const node = document.createElement('div');\n      // node.value = 'addNode'\n      // node.id = 'nodeId';\n      // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n      // // 添加样式元素到container\n      // layoutBox.appendChild(layoutLeft);\n      // layoutBox.appendChild(layoutRight);\n      // // container.appendChild(layoutBox);\n      // // 添加子元素到左侧\n      // layoutLeft.appendChild(node);\n      // // Add a selector to DOM\n      // const selector = document.createElement('select');\n      // selector.id = 'selector';\n      // selector.style.border = 'none';\n      // const selection1 = document.createElement('option');\n      // selection1.value = 'default';\n      // selection1.innerHTML = 'Default Mode';\n      // const selection2 = document.createElement('option');\n      // selection2.value = 'addNode';\n      // selection2.innerHTML = 'Add Node (By clicking canvas)';\n      // const selection3 = document.createElement('option');\n      // selection3.value = 'addEdge';\n      // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n      // selector.appendChild(selection1);\n      // selector.appendChild(selection2);\n      // selector.appendChild(selection3);\n      // container.appendChild(selector);\n      // const width = container.scrollWidth;\n      // const height = (container.scrollHeight || 500) - 30;\n      // const graph = new G6.Graph({\n      // container: 'container',\n      // width,\n      // height,\n      // // The sets of behavior modes\n      // modes: {\n      //     // Defualt mode\n      //     default: ['drag-node', 'click-select'],\n      //     // Adding node mode\n      //     addNode: ['click-add-node', 'click-select'],\n      //     // Adding edge mode\n      //     addEdge: ['click-add-edge', 'click-select'],\n      // },\n      // // The node styles in different states\n      // nodeStateStyles: {\n      //     // The node styles in selected state\n      //     selected: {\n      //         stroke: '#666',\n      //         lineWidth: 2,\n      //         fill: 'steelblue',\n      //     },\n      // },\n      // });\n      // graph.data(data);\n      // graph.render();\n      // // Listen to the selector, change the mode when the selector is changed\n      // selector.addEventListener('change', (e) => {\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // // 左侧长方形node元素点击事件\n      // node.addEventListener('click', (e) => {\n      //     console.log(e.target.value)\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // if (typeof window !== 'undefined')\n      // window.onresize = () => {\n      //     if (!graph || graph.get('destroyed')) return;\n      //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n      //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n      // };\n      // ---------------------------------------------------------------------------------------\n      // G6.Util.processParallelEdges processes the edges with same source node and target node,\n      // on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\n      const processParallelEdgesOnAnchorPoint = (edges, offsetDiff = 15, multiEdgeType = 'quadratic', singleEdgeType = undefined, loopEdgeType = undefined) => {\n        debugger;\n        const len = edges.length;\n        const cod = offsetDiff * 2;\n        const loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n        const edgeMap = {};\n        const tags = [];\n        const reverses = {};\n\n        for (let i = 0; i < len; i++) {\n          const edge = edges[i];\n          const {\n            source,\n            target,\n            sourceAnchor,\n            targetAnchor\n          } = edge;\n          const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n          if (tags[i]) continue;\n\n          if (!edgeMap[sourceTarget]) {\n            edgeMap[sourceTarget] = [];\n          }\n\n          tags[i] = true;\n          edgeMap[sourceTarget].push(edge);\n\n          for (let j = 0; j < len; j++) {\n            if (i === j) continue;\n            const sedge = edges[j];\n            const {\n              source: src,\n              target: dst,\n              sourceAnchor: srcAnchor,\n              targetAnchor: dstAnchor\n            } = sedge; // 两个节点之间共同的边\n            // 第一条的source = 第二条的target\n            // 第一条的target = 第二条的source\n\n            if (!tags[j]) {\n              if (source === dst && sourceAnchor === dstAnchor && target === src && targetAnchor === srcAnchor) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n                reverses[`${src}|${srcAnchor}|${dst}|${dstAnchor}|${edgeMap[sourceTarget].length - 1}`] = true;\n              } else if (source === src && sourceAnchor === srcAnchor && target === dst && targetAnchor === dstAnchor) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n              }\n            }\n          }\n        }\n\n        for (const key in edgeMap) {\n          const arcEdges = edgeMap[key];\n          const {\n            length\n          } = arcEdges;\n\n          for (let k = 0; k < length; k++) {\n            const current = arcEdges[k];\n\n            if (current.source === current.target) {\n              if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n              current.loopCfg = {\n                position: loopPosition[k % 8],\n                dist: Math.floor(k / 8) * 20 + 50\n              };\n              continue;\n            }\n\n            if (length === 1 && singleEdgeType && (current.source !== current.target || current.sourceAnchor !== current.targetAnchor)) {\n              current.type = singleEdgeType;\n              continue;\n            }\n\n            current.type = multiEdgeType;\n            const sign = (k % 2 === 0 ? 1 : -1) * (reverses[`${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`] ? -1 : 1);\n\n            if (length % 2 === 1) {\n              current.curveOffset = sign * Math.ceil(k / 2) * cod;\n            } else {\n              current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n            }\n          }\n        }\n\n        return edges;\n      };\n\n      const data = {\n        // 节点数据\n        nodes: [{\n          id: 'node1',\n          x: 350,\n          y: 100\n        }, {\n          id: 'node2',\n          x: 350,\n          y: 250\n        }, {\n          id: 'node3',\n          x: 350,\n          y: 300\n        }]\n      }; // 新增节点按钮\n\n      const descriptionDiv = document.createElement('div');\n      const container = document.getElementById('container');\n      descriptionDiv.innerText = '新增节点';\n      descriptionDiv.style = \"width: 80px;height:36px;line-height:50px;text-align:center;border:1px solid #5ab4be;border-radius:4px;background:#5ab4be;color:#fff;cursor:pointer;margin:0 auto\";\n      container.appendChild(descriptionDiv); // custom a node with anchor-point shapes\n\n      G6.registerNode('rect-node', {\n        // draw anchor-point circles according to the anchorPoints in afterDraw\n        afterDraw(cfg, group) {\n          const bbox = group.getBBox();\n          const anchorPoints = this.getAnchorPoints(cfg);\n          anchorPoints.forEach((anchorPos, i) => {\n            group.addShape('circle', {\n              attrs: {\n                r: 5,\n                x: bbox.x + bbox.width * anchorPos[0],\n                y: bbox.y + bbox.height * anchorPos[1],\n                fill: '#fff',\n                stroke: '#5F95FF'\n              },\n              name: `anchor-point`,\n              // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n              anchorPointIdx: i,\n              // flag the idx of the anchor-point circle\n              links: 0,\n              // cache the number of edges connected to this shape\n              visible: false // invisible by default, shows up when links > 1 or the node is in showAnchors state\n\n            });\n          });\n        },\n\n        getAnchorPoints(cfg) {\n          return cfg.anchorPoints || [[0, 0.5], [0.33, 0], [0.66, 0], [1, 0.5], [0.33, 1], [0.66, 1]];\n        },\n\n        // response the state changes and show/hide the link-point circles\n        setState(name, value, item) {\n          if (name === 'showAnchors') {\n            const anchorPoints = item.getContainer().findAll(ele => ele.get('name') === 'anchor-point');\n            anchorPoints.forEach(point => {\n              if (value || point.get('links') > 0) point.show();else point.hide();\n            });\n          }\n        }\n\n      }, 'rect');\n      let sourceAnchorIdx, targetAnchorIdx;\n      const width = container.scrollWidth;\n      const height = (container.scrollHeight || 500) - 20;\n      const graph = new G6.Graph({\n        container: 'container',\n        width,\n        height,\n        modes: {\n          default: ['drag-node', // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n          {\n            type: 'create-edge',\n            shouldBegin: e => {\n              // avoid beginning at other shapes on the node\n              if (e.target && e.target.get('name') !== 'anchor-point') return false;\n              sourceAnchorIdx = e.target.get('anchorPointIdx');\n              e.target.set('links', e.target.get('links') + 1); // cache the number of edge connected to this anchor-point circle\n\n              return true;\n            },\n            shouldEnd: e => {\n              // avoid ending at other shapes on the node\n              if (e.target && e.target.get('name') !== 'anchor-point') return false;\n\n              if (e.target) {\n                targetAnchorIdx = e.target.get('anchorPointIdx');\n                e.target.set('links', e.target.get('links') + 1); // cache the number of edge connected to this anchor-point circle\n\n                return true;\n              }\n\n              targetAnchorIdx = undefined;\n              return true;\n            } // update the sourceAnchor\n            // getEdgeConfig: () => {\n            //   return {\n            //     sourceAnchor: sourceAnchorIdx\n            //   }\n            // }\n\n          }]\n        },\n        defaultNode: {\n          type: 'rect-node',\n          style: {\n            fill: '#eee',\n            stroke: '#ccc'\n          }\n        },\n        defaultEdge: {\n          type: 'quadratic',\n          style: {\n            stroke: '#F6BD16',\n            lineWidth: 2\n          }\n        }\n      });\n      graph.data(data);\n      graph.render();\n      graph.on('aftercreateedge', e => {\n        // update the sourceAnchor and targetAnchor for the newly added edge\n        graph.updateItem(e.edge, {\n          sourceAnchor: sourceAnchorIdx,\n          targetAnchor: targetAnchorIdx\n        }); // update the curveOffset for parallel edges\n\n        const edges = graph.save().edges;\n        processParallelEdgesOnAnchorPoint(edges);\n        graph.getEdges().forEach((edge, i) => {\n          graph.updateItem(edge, {\n            curveOffset: edges[i].curveOffset,\n            curvePosition: edges[i].curvePosition\n          });\n        });\n      }); // if create-edge is canceled before ending, update the 'links' on the anchor-point circles\n\n      graph.on('afterremoveitem', e => {\n        if (e.item && e.item.source && e.item.target) {\n          const sourceNode = graph.findById(e.item.source);\n          const targetNode = graph.findById(e.item.target);\n          const {\n            sourceAnchor,\n            targetAnchor\n          } = e.item;\n\n          if (sourceNode && !isNaN(sourceAnchor)) {\n            const sourceAnchorShape = sourceNode.getContainer().find(ele => ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === sourceAnchor);\n            sourceAnchorShape.set('links', sourceAnchorShape.get('links') - 1);\n          }\n\n          if (targetNode && !isNaN(targetAnchor)) {\n            const targetAnchorShape = targetNode.getContainer().find(ele => ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === targetAnchor);\n            targetAnchorShape.set('links', targetAnchorShape.get('links') - 1);\n          }\n        }\n      }); // after clicking on the first node, the edge is created, update the sourceAnchor\n\n      graph.on('afteradditem', e => {\n        if (e.item && e.item.getType() === 'edge') {\n          graph.updateItem(e.item, {\n            sourceAnchor: sourceAnchorIdx\n          });\n        }\n      }); // some listeners to control the state of nodes to show and hide anchor-point circles\n\n      graph.on('node:mouseenter', e => {\n        graph.setItemState(e.item, 'showAnchors', true);\n      });\n      graph.on('node:mouseleave', e => {\n        graph.setItemState(e.item, 'showAnchors', false);\n      });\n      if (typeof window !== 'undefined') window.onresize = () => {\n        if (!graph || graph.get('destroyed')) return;\n        if (!container || !container.scrollWidth || !container.scrollHeight) return;\n        graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n      };\n    });\n  }\n\n});","map":{"version":3,"mappings":"AAMA,SAASA,eAAT,EAA0BC,SAA1B,QAA2C,KAA3C;AACA,OAAOC,EAAP,MAAe,UAAf;AACA,eAAeF,eAAe,CAAC;EAC3BG,IAAI,EAAE,MADqB;;EAE3BC,KAAK,GAAG;IAEJH,SAAS,CAAC,MAAK;MACX;;;MAGA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMI,iCAAgC,GAAI,CACtCC,KADsC,EAEtCC,UAAS,GAAI,EAFyB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","names":["defineComponent","onMounted","G6","name","setup","processParallelEdgesOnAnchorPoint","edges","offsetDiff","multiEdgeType","singleEdgeType","undefined","loopEdgeType","len","length","cod","loopPosition","edgeMap","tags","reverses","i","edge","source","target","sourceAnchor","targetAnchor","sourceTarget","push","j","sedge","src","dst","srcAnchor","dstAnchor","key","arcEdges","k","current","type","loopCfg","position","dist","Math","floor","sign","curveOffset","ceil","data","nodes","id","x","y","descriptionDiv","document","createElement","container","getElementById","innerText","style","appendChild","registerNode","afterDraw","cfg","group","bbox","getBBox","anchorPoints","getAnchorPoints","forEach","anchorPos","addShape","attrs","r","width","height","fill","stroke","anchorPointIdx","links","visible","setState","value","item","getContainer","findAll","ele","get","point","show","hide","sourceAnchorIdx","targetAnchorIdx","scrollWidth","scrollHeight","graph","Graph","modes","default","shouldBegin","e","set","shouldEnd","defaultNode","defaultEdge","lineWidth","render","on","updateItem","save","getEdges","curvePosition","sourceNode","findById","targetNode","isNaN","sourceAnchorShape","find","targetAnchorShape","getType","setItemState","window","onresize","changeSize"],"sourceRoot":"","sources":["/Users/wawalike/Desktop/ggProject/src/views/antv/index.vue"],"sourcesContent":["<template>\n    <div class=\"antv\">\n        <div id=\"container\"></div>\n    </div>\n</template>\n<script>\nimport { defineComponent, onMounted } from 'vue'\nimport G6 from '@antv/g6';\nexport default defineComponent({\n    name: 'antV',\n    setup() {\n        \n        onMounted(()=> {\n            /**\n             * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n             */\n            // let addedCount = 0;\n            // // Register a custom behavior: add a node when user click the blank part of canvas\n            // G6.registerBehavior('click-add-node', {\n            //     // Set the events and the corresponding responsing function for this behavior\n            //     getEvents() {\n            //         // The event is canvas:click, the responsing function is onClick\n            //         return {\n            //         'canvas:click': 'onClick',\n            //         };\n            //     },\n            //     // Click event\n            //     onClick(ev) {\n            //         const self = this;\n            //         const graph = self.graph;\n            //         // Add a new node\n            //         graph.addItem('node', {\n            //         x: ev.canvasX,\n            //         y: ev.canvasY,\n            //         id: `node-${addedCount}`, // Generate the unique id\n            //         });\n            //         addedCount++;\n            //     },\n            // });\n            // // Register a custom behavior: click two end nodes to add an edge\n            // G6.registerBehavior('click-add-edge', {\n            //     // Set the events and the corresponding responsing function for this behavior\n            //     getEvents() {\n            //         return {\n            //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n            //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n            //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n            //         };\n            //     },\n            //     // The responsing function for node:click defined in getEvents\n            //     onClick(ev) {\n            //         // console.log(1111)\n            //         // console.log(this)\n            //         const self = this;\n            //         const node = ev.item;\n            //         const graph = self.graph;\n            //         // The position where the mouse clicks\n            //         const point = { x: ev.x, y: ev.y };\n            //         const model = node.getModel();\n            //         if (self.addingEdge && self.edge) {\n            //         graph.updateItem(self.edge, {\n            //             target: model.id,\n            //         });\n    \n            //         self.edge = null;\n            //         self.addingEdge = false;\n            //         } else {\n            //         // Add anew edge, the end node is the current node user clicks\n            //         self.edge = graph.addItem('edge', {\n            //             source: model.id,\n            //             target: model.id,\n            //         });\n            //         self.addingEdge = true;\n            //         }\n            //     },\n            //     // The responsing function for mousemove defined in getEvents\n            //     onMousemove(ev) {\n            //         const self = this;\n            //         // The current position the mouse clicks\n            //         const point = { x: ev.x, y: ev.y };\n            //         if (self.addingEdge && self.edge) {\n            //         // Update the end node to the current node the mouse clicks\n            //         self.graph.updateItem(self.edge, {\n            //             target: point,\n            //         });\n            //         }\n            //     },\n            //     // The responsing function for edge:click defined in getEvents\n            //     onEdgeClick(ev) {\n            //         const self = this;\n            //         const currentEdge = ev.item;\n            //         if (self.addingEdge && self.edge === currentEdge) {\n            //         self.graph.removeItem(self.edge);\n            //         self.edge = null;\n            //         self.addingEdge = false;\n            //         }\n            //     },\n            // });\n            // // Initial data\n            // const data = {\n            //     nodes: [\n            //         {\n            //         id: 'node1',\n            //         x: 100,\n            //         y: 200,\n            //         },\n            //         {\n            //         id: 'node2',\n            //         x: 300,\n            //         y: 200,\n            //         },\n            //         {\n            //         id: 'node3',\n            //         x: 300,\n            //         y: 300,\n            //         },\n            //     ],\n            //     edges: [\n            //         {\n            //         id: 'edge1',\n            //         target: 'node2',\n            //         source: 'node1',\n            //         },\n            //     ],\n            // };\n    \n            // const container = document.getElementById('container');\n            // // Add a layout 及子元素\n            // const layoutBox = document.createElement('div');\n            // layoutBox.id = 'layoutBox';\n            // const layoutLeft = document.createElement('div');\n            // layoutLeft.id = 'layoutLeft';\n            // const layoutRight = document.createElement('div');\n            // layoutRight.id = 'layoutRight';\n            // // 设置layout样式\n            // layoutBox.style = \"height:100%;display:flex\"\n            // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n            // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n            // // 添加左侧元素\n            // const node = document.createElement('div');\n            // node.value = 'addNode'\n            // node.id = 'nodeId';\n            // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n            // // 添加样式元素到container\n            // layoutBox.appendChild(layoutLeft);\n            // layoutBox.appendChild(layoutRight);\n            // // container.appendChild(layoutBox);\n            // // 添加子元素到左侧\n            // layoutLeft.appendChild(node);\n            // // Add a selector to DOM\n            // const selector = document.createElement('select');\n            // selector.id = 'selector';\n            // selector.style.border = 'none';\n            // const selection1 = document.createElement('option');\n            // selection1.value = 'default';\n            // selection1.innerHTML = 'Default Mode';\n            // const selection2 = document.createElement('option');\n            // selection2.value = 'addNode';\n            // selection2.innerHTML = 'Add Node (By clicking canvas)';\n            // const selection3 = document.createElement('option');\n            // selection3.value = 'addEdge';\n            // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n            // selector.appendChild(selection1);\n            // selector.appendChild(selection2);\n            // selector.appendChild(selection3);\n            // container.appendChild(selector);\n    \n            // const width = container.scrollWidth;\n            // const height = (container.scrollHeight || 500) - 30;\n            // const graph = new G6.Graph({\n            // container: 'container',\n            // width,\n            // height,\n            // // The sets of behavior modes\n            // modes: {\n            //     // Defualt mode\n            //     default: ['drag-node', 'click-select'],\n            //     // Adding node mode\n            //     addNode: ['click-add-node', 'click-select'],\n            //     // Adding edge mode\n            //     addEdge: ['click-add-edge', 'click-select'],\n            // },\n            // // The node styles in different states\n            // nodeStateStyles: {\n            //     // The node styles in selected state\n            //     selected: {\n            //         stroke: '#666',\n            //         lineWidth: 2,\n            //         fill: 'steelblue',\n            //     },\n            // },\n            // });\n            // graph.data(data);\n            // graph.render();\n    \n            // // Listen to the selector, change the mode when the selector is changed\n            // selector.addEventListener('change', (e) => {\n            //     const value = e.target.value;\n            //     // change the behavior mode\n            //     graph.setMode(value);\n            // });\n            // // 左侧长方形node元素点击事件\n            // node.addEventListener('click', (e) => {\n            //     console.log(e.target.value)\n            //     const value = e.target.value;\n            //     // change the behavior mode\n            //     graph.setMode(value);\n            // });\n    \n            // if (typeof window !== 'undefined')\n            // window.onresize = () => {\n            //     if (!graph || graph.get('destroyed')) return;\n            //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n            //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n            // };\n            // ---------------------------------------------------------------------------------------\n            // G6.Util.processParallelEdges processes the edges with same source node and target node,\n            // on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\n            const processParallelEdgesOnAnchorPoint = (\n                edges,\n                offsetDiff = 15,\n                multiEdgeType = 'quadratic',\n                singleEdgeType = undefined,\n                loopEdgeType = undefined\n                ) => {\n                    debugger\n                const len = edges.length;\n                const cod = offsetDiff * 2;\n                const loopPosition = [\n                    'top',\n                    'top-right',\n                    'right',\n                    'bottom-right',\n                    'bottom',\n                    'bottom-left',\n                    'left',\n                    'top-left',\n                ];\n                const edgeMap = {};\n                const tags = [];\n                const reverses = {};\n                for (let i = 0; i < len; i++) {\n                    const edge = edges[i];\n                    const { source, target, sourceAnchor, targetAnchor } = edge;\n                    const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n\n                    if (tags[i]) continue;\n                    if (!edgeMap[sourceTarget]) {\n                    edgeMap[sourceTarget] = [];\n                    }\n                    tags[i] = true;\n                    edgeMap[sourceTarget].push(edge);\n                    for (let j = 0; j < len; j++) {\n                    if (i === j) continue;\n                    const sedge = edges[j];\n                    const { source: src, target: dst, sourceAnchor: srcAnchor, targetAnchor: dstAnchor } = sedge;\n\n                    // 两个节点之间共同的边\n                    // 第一条的source = 第二条的target\n                    // 第一条的target = 第二条的source\n                    if (!tags[j]) {\n                        if (source === dst && sourceAnchor === dstAnchor\n                            && target === src && targetAnchor === srcAnchor) {\n                        edgeMap[sourceTarget].push(sedge);\n                        tags[j] = true;\n                        reverses[`${src}|${srcAnchor}|${dst}|${dstAnchor}|${edgeMap[sourceTarget].length - 1}`] = true;\n                        } else if (source === src && sourceAnchor === srcAnchor\n                        && target === dst  && targetAnchor === dstAnchor) {\n                        edgeMap[sourceTarget].push(sedge);\n                        tags[j] = true;\n                        }\n                    }\n                    }\n                }\n\n                for (const key in edgeMap) {\n                    const arcEdges = edgeMap[key];\n                    const { length } = arcEdges;\n                    for (let k = 0; k < length; k++) {\n                    const current = arcEdges[k];\n                    if (current.source === current.target) {\n                        if (loopEdgeType) current.type = loopEdgeType;\n                        // 超过8条自环边，则需要重新处理\n                        current.loopCfg = {\n                        position: loopPosition[k % 8],\n                        dist: Math.floor(k / 8) * 20 + 50,\n                        };\n                        continue;\n                    }\n                    if (length === 1 && singleEdgeType && (current.source !== current.target || current.sourceAnchor !== current.targetAnchor)) {\n                        current.type = singleEdgeType;\n                        continue;\n                    }\n                    current.type = multiEdgeType;\n                    const sign =\n                        (k % 2 === 0 ? 1 : -1) * (reverses[`${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`] ? -1 : 1);\n                    if (length % 2 === 1) {\n                        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n                    } else {\n                        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n                    }\n                    }\n                }\n                return edges;\n                };\n\n\n                const data = {\n                    // 节点数据\n                    nodes: [\n                        { id: 'node1', x: 350, y: 100 },\n                        { id: 'node2', x: 350, y: 250 },\n                        { id: 'node3', x: 350, y: 300 }\n                    ],\n                };\n                // 新增节点按钮\n                const descriptionDiv = document.createElement('div');\n                const container = document.getElementById('container');\n                descriptionDiv.innerText = '新增节点'\n                descriptionDiv.style = \"width: 80px;height:36px;line-height:50px;text-align:center;border:1px solid #5ab4be;border-radius:4px;background:#5ab4be;color:#fff;cursor:pointer;margin:0 auto\"\n                container.appendChild(descriptionDiv);\n\n                // custom a node with anchor-point shapes\n                G6.registerNode('rect-node', {\n                // draw anchor-point circles according to the anchorPoints in afterDraw\n                afterDraw(cfg, group) {\n                    const bbox = group.getBBox();\n                    const anchorPoints = this.getAnchorPoints(cfg)\n                    anchorPoints.forEach((anchorPos, i) => {\n                    group.addShape('circle', {\n                        attrs: {\n                        r: 5,\n                        x: bbox.x + bbox.width * anchorPos[0],\n                        y: bbox.y + bbox.height * anchorPos[1],\n                        fill: '#fff',\n                        stroke: '#5F95FF'\n                        },\n                        name: `anchor-point`, // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n                        anchorPointIdx: i, // flag the idx of the anchor-point circle\n                        links: 0, // cache the number of edges connected to this shape\n                        visible: false, // invisible by default, shows up when links > 1 or the node is in showAnchors state\n                    })\n                    })\n                },\n            getAnchorPoints(cfg) {\n                return cfg.anchorPoints || [[0, 0.5], [0.33, 0], [0.66, 0], [1, 0.5], [0.33, 1], [0.66, 1]];\n            },\n            // response the state changes and show/hide the link-point circles\n            setState(name, value, item) {\n                if (name === 'showAnchors') {\n                const anchorPoints = item.getContainer().findAll(ele => ele.get('name') === 'anchor-point');\n                anchorPoints.forEach(point => {\n                    if (value || point.get('links') > 0) point.show()\n                    else point.hide()\n                })\n                }\n            }\n            }, 'rect')\n\n            let sourceAnchorIdx, targetAnchorIdx;\n\n            const width = container.scrollWidth;\n            const height = (container.scrollHeight || 500) - 20;\n            const graph = new G6.Graph({\n            container: 'container',\n            width,\n            height,\n            modes: {\n                default: [\n                'drag-node',\n                // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n                {\n                type: 'create-edge',\n                shouldBegin: e => {\n                    // avoid beginning at other shapes on the node\n                    if (e.target && e.target.get('name') !== 'anchor-point') return false;\n                    sourceAnchorIdx = e.target.get('anchorPointIdx');\n                    e.target.set('links', e.target.get('links') + 1); // cache the number of edge connected to this anchor-point circle\n                    return true;\n                },\n                shouldEnd: e => {\n                    // avoid ending at other shapes on the node\n                    if (e.target && e.target.get('name') !== 'anchor-point') return false;\n                    if (e.target) {\n                    targetAnchorIdx = e.target.get('anchorPointIdx');\n                    e.target.set('links', e.target.get('links') + 1);  // cache the number of edge connected to this anchor-point circle\n                    return true;\n                    }\n                    targetAnchorIdx = undefined;\n                    return true;\n                },\n                // update the sourceAnchor\n                // getEdgeConfig: () => {\n                //   return {\n                //     sourceAnchor: sourceAnchorIdx\n                //   }\n                // }\n                }],\n            },\n            defaultNode: {\n                type: 'rect-node',\n                style: {\n                fill: '#eee',\n                stroke: '#ccc',\n                }\n            },\n            defaultEdge: {\n                type: 'quadratic',\n                style: {\n                stroke: '#F6BD16',\n                lineWidth: 2,\n                },\n            },\n            });\n\n            graph.data(data);\n            graph.render();\n\n            graph.on('aftercreateedge', (e) => {\n            // update the sourceAnchor and targetAnchor for the newly added edge\n            graph.updateItem(e.edge, {\n                sourceAnchor: sourceAnchorIdx,\n                targetAnchor: targetAnchorIdx\n            })\n\n            // update the curveOffset for parallel edges\n            const edges = graph.save().edges;\n            processParallelEdgesOnAnchorPoint(edges);\n            graph.getEdges().forEach((edge, i) => {\n                graph.updateItem(edge, {\n                curveOffset: edges[i].curveOffset,\n                curvePosition: edges[i].curvePosition,\n                });\n            });\n            });\n\n            // if create-edge is canceled before ending, update the 'links' on the anchor-point circles\n            graph.on('afterremoveitem', e => {\n            if (e.item && e.item.source && e.item.target) {\n                const sourceNode = graph.findById(e.item.source);\n                const targetNode = graph.findById(e.item.target);\n                const { sourceAnchor, targetAnchor } = e.item;\n                if (sourceNode && !isNaN(sourceAnchor)) {\n                const sourceAnchorShape = sourceNode.getContainer().find(ele => (ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === sourceAnchor));\n                sourceAnchorShape.set('links', sourceAnchorShape.get('links') - 1);\n                }\n                if (targetNode && !isNaN(targetAnchor)) {\n                const targetAnchorShape = targetNode.getContainer().find(ele => (ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === targetAnchor));\n                targetAnchorShape.set('links', targetAnchorShape.get('links') - 1);\n                }\n            }\n            })\n\n            // after clicking on the first node, the edge is created, update the sourceAnchor\n            graph.on('afteradditem', e => {\n            if (e.item && e.item.getType() === 'edge') {\n                graph.updateItem(e.item, {\n                sourceAnchor: sourceAnchorIdx\n                });\n            }\n            })\n\n\n            // some listeners to control the state of nodes to show and hide anchor-point circles\n            graph.on('node:mouseenter', e => {\n            graph.setItemState(e.item, 'showAnchors', true);\n            })\n            graph.on('node:mouseleave', e => {\n            graph.setItemState(e.item, 'showAnchors', false);\n            })\n\n            if (typeof window !== 'undefined')\n            window.onresize = () => {\n                if (!graph || graph.get('destroyed')) return;\n                if (!container || !container.scrollWidth || !container.scrollHeight) return;\n                graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n            };\n        })\n    },\n})\n</script>\n<style lang=\"less\" scoped>\n.antv {\n    height: 100%;\n    // border: 1px solid #ddd;\n    border-radius: 6px;\n    #container {\n        height: 100%;\n    }\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}