{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { __extends } from \"tslib\";\nimport { each, isNil, isNumber } from '@antv/util';\nimport { distance, getCircleIntersectByPoint, getEllipseIntersectByPoint, getRectIntersectByPoint } from '../util/math';\nimport Item from './item';\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\nvar CACHE_BBOX = 'bboxCache';\n\nvar Node =\n/** @class */\nfunction (_super) {\n  __extends(Node, _super);\n\n  function Node() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Node.prototype.getNearestPoint = function (points, curPoint) {\n    var index = 0;\n    var nearestPoint = points[0];\n    var minDistance = distance(points[0], curPoint);\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var dis = distance(point, curPoint);\n\n      if (dis < minDistance) {\n        nearestPoint = point;\n        minDistance = dis;\n        index = i;\n      }\n    }\n\n    nearestPoint.anchorIndex = index;\n    return nearestPoint;\n  };\n\n  Node.prototype.getDefaultCfg = function () {\n    return {\n      type: 'node',\n      edges: []\n    };\n  };\n  /**\n   * 获取从节点关联的所有边\n   */\n\n\n  Node.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取所有的入边\n   */\n\n\n  Node.prototype.getInEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('target') === self;\n    });\n  };\n  /**\n   * 获取所有的出边\n   */\n\n\n  Node.prototype.getOutEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('source') === self;\n    });\n  };\n  /**\n   * 获取节点的邻居节点\n   *\n   * @returns {INode[]}\n   * @memberof Node\n   */\n\n\n  Node.prototype.getNeighbors = function (type) {\n    var _this = this;\n\n    var edges = this.get('edges');\n\n    if (type === 'target') {\n      // 当前节点为 source，它所指向的目标节点\n      var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\n        return edge.getSource() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_1).map(function (edge) {\n        return edge.getTarget();\n      });\n    }\n\n    if (type === 'source') {\n      // 当前节点为 target，它所指向的源节点\n      var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\n        return edge.getTarget() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_2).map(function (edge) {\n        return edge.getSource();\n      });\n    } // 若未指定 type ，则返回所有邻居\n\n\n    var neighhborsConverter = function neighhborsConverter(edge) {\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\n    };\n\n    return edges.map(neighhborsConverter);\n  };\n  /**\n   * 根据锚点的索引获取连接点\n   * @param  {Number} index 索引\n   */\n\n\n  Node.prototype.getLinkPointByAnchor = function (index) {\n    var anchorPoints = this.getAnchorPoints();\n    return anchorPoints[index];\n  };\n  /**\n   * 获取连接点\n   * @param point\n   */\n\n\n  Node.prototype.getLinkPoint = function (point) {\n    var keyShape = this.get('keyShape');\n    var type = keyShape.get('type');\n    var itemType = this.get('type');\n    var centerX;\n    var centerY;\n    var bbox = this.getBBox();\n\n    if (itemType === 'combo') {\n      centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;\n      centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;\n    } else {\n      centerX = bbox.centerX;\n      centerY = bbox.centerY;\n    }\n\n    var anchorPoints = this.getAnchorPoints();\n    var intersectPoint;\n\n    switch (type) {\n      case 'circle':\n        intersectPoint = getCircleIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          r: bbox.width / 2\n        }, point);\n        break;\n\n      case 'ellipse':\n        intersectPoint = getEllipseIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          rx: bbox.width / 2,\n          ry: bbox.height / 2\n        }, point);\n        break;\n\n      default:\n        intersectPoint = getRectIntersectByPoint(bbox, point);\n    }\n\n    var linkPoint = intersectPoint; // 如果存在锚点，则使用交点计算最近的锚点\n\n    if (anchorPoints.length) {\n      if (!linkPoint) {\n        // 如果计算不出交点\n        linkPoint = point;\n      }\n\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\n    }\n\n    if (!linkPoint) {\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\n      linkPoint = {\n        x: centerX,\n        y: centerY\n      };\n    }\n\n    return linkPoint;\n  };\n  /**\n   * 获取锚点的定义\n   * @return {array} anchorPoints\n   */\n\n\n  Node.prototype.getAnchorPoints = function () {\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\n\n    if (!anchorPoints) {\n      anchorPoints = [];\n      var shapeFactory = this.get('shapeFactory');\n      var bbox_1 = this.getBBox();\n      var model = this.get('model');\n      var shapeCfg = this.getShapeCfg(model);\n      var type = model.type;\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\n      each(points, function (pointArr, index) {\n        var point = {\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\n          y: bbox_1.minY + pointArr[1] * bbox_1.height,\n          anchorIndex: index\n        };\n        anchorPoints.push(point);\n      });\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\n    }\n\n    return anchorPoints;\n  };\n  /**\n   * add edge\n   * @param edge Edge instance\n   */\n\n\n  Node.prototype.addEdge = function (edge) {\n    this.get('edges').push(edge);\n  };\n  /**\n   * 锁定节点\n   */\n\n\n  Node.prototype.lock = function () {\n    this.set('locked', true);\n  };\n  /**\n   * 解锁锁定的节点\n   */\n\n\n  Node.prototype.unlock = function () {\n    this.set('locked', false);\n  };\n\n  Node.prototype.hasLocked = function () {\n    return this.get('locked');\n  };\n  /**\n   * 移除边\n   * @param {Edge} edge 边\n   */\n\n\n  Node.prototype.removeEdge = function (edge) {\n    var edges = this.getEdges();\n    var index = edges.indexOf(edge);\n    if (index > -1) edges.splice(index, 1);\n  };\n\n  Node.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n  /**\n   * 判断更新的种类，move 表示仅移动，bbox 表示大小有变化，style 表示仅与大小无关的参数变化\n   * @param cfg 节点数据模型\n   */\n\n\n  Node.prototype.getUpdateType = function (cfg) {\n    var _a, _b, _c, _d, _e;\n\n    if (!cfg) return undefined;\n    var existX = !isNil(cfg.x);\n    var existY = !isNil(cfg.y);\n    var keys = Object.keys(cfg); // 仅有一个字段，包含 x 或者 包含 y\n    // 两个字段，同时有 x，同时有 y\n\n    if (keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY) return 'move';\n    if (isNumber(cfg.x) || isNumber(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size || (cfg === null || cfg === void 0 ? void 0 : cfg.style) && (((_a = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _a === void 0 ? void 0 : _a.r) || ((_b = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _b === void 0 ? void 0 : _b.width) || ((_c = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _d === void 0 ? void 0 : _d.rx) || ((_e = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _e === void 0 ? void 0 : _e.ry))) return 'bbox|label';\n    var updateLabel = keys.includes('label') || keys.includes('labelCfg');\n    return updateLabel ? 'style|label' : 'style';\n  };\n\n  return Node;\n}(Item);\n\nexport default Node;","map":{"version":3,"names":["__extends","each","isNil","isNumber","distance","getCircleIntersectByPoint","getEllipseIntersectByPoint","getRectIntersectByPoint","Item","CACHE_ANCHOR_POINTS","CACHE_BBOX","Node","_super","apply","arguments","prototype","getNearestPoint","points","curPoint","index","nearestPoint","minDistance","i","length","point","dis","anchorIndex","getDefaultCfg","type","edges","getEdges","get","getInEdges","self","filter","edge","getOutEdges","getNeighbors","_this","neighhborsConverter_1","getSource","map","getTarget","neighhborsConverter_2","neighhborsConverter","getLinkPointByAnchor","anchorPoints","getAnchorPoints","getLinkPoint","keyShape","itemType","centerX","centerY","bbox","getBBox","maxX","minX","maxY","minY","intersectPoint","x","y","r","width","rx","ry","height","linkPoint","shapeFactory","bbox_1","model","shapeCfg","getShapeCfg","pointArr","push","set","addEdge","lock","unlock","hasLocked","removeEdge","indexOf","splice","clearCache","getUpdateType","cfg","_a","_b","_c","_d","_e","undefined","existX","existY","keys","Object","size","style","updateLabel","includes"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/g6-core/es/item/node.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { each, isNil, isNumber } from '@antv/util';\nimport { distance, getCircleIntersectByPoint, getEllipseIntersectByPoint, getRectIntersectByPoint } from '../util/math';\nimport Item from './item';\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\nvar CACHE_BBOX = 'bboxCache';\n\nvar Node =\n/** @class */\nfunction (_super) {\n  __extends(Node, _super);\n\n  function Node() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Node.prototype.getNearestPoint = function (points, curPoint) {\n    var index = 0;\n    var nearestPoint = points[0];\n    var minDistance = distance(points[0], curPoint);\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var dis = distance(point, curPoint);\n\n      if (dis < minDistance) {\n        nearestPoint = point;\n        minDistance = dis;\n        index = i;\n      }\n    }\n\n    nearestPoint.anchorIndex = index;\n    return nearestPoint;\n  };\n\n  Node.prototype.getDefaultCfg = function () {\n    return {\n      type: 'node',\n      edges: []\n    };\n  };\n  /**\n   * 获取从节点关联的所有边\n   */\n\n\n  Node.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取所有的入边\n   */\n\n\n  Node.prototype.getInEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('target') === self;\n    });\n  };\n  /**\n   * 获取所有的出边\n   */\n\n\n  Node.prototype.getOutEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('source') === self;\n    });\n  };\n  /**\n   * 获取节点的邻居节点\n   *\n   * @returns {INode[]}\n   * @memberof Node\n   */\n\n\n  Node.prototype.getNeighbors = function (type) {\n    var _this = this;\n\n    var edges = this.get('edges');\n\n    if (type === 'target') {\n      // 当前节点为 source，它所指向的目标节点\n      var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\n        return edge.getSource() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_1).map(function (edge) {\n        return edge.getTarget();\n      });\n    }\n\n    if (type === 'source') {\n      // 当前节点为 target，它所指向的源节点\n      var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\n        return edge.getTarget() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_2).map(function (edge) {\n        return edge.getSource();\n      });\n    } // 若未指定 type ，则返回所有邻居\n\n\n    var neighhborsConverter = function neighhborsConverter(edge) {\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\n    };\n\n    return edges.map(neighhborsConverter);\n  };\n  /**\n   * 根据锚点的索引获取连接点\n   * @param  {Number} index 索引\n   */\n\n\n  Node.prototype.getLinkPointByAnchor = function (index) {\n    var anchorPoints = this.getAnchorPoints();\n    return anchorPoints[index];\n  };\n  /**\n   * 获取连接点\n   * @param point\n   */\n\n\n  Node.prototype.getLinkPoint = function (point) {\n    var keyShape = this.get('keyShape');\n    var type = keyShape.get('type');\n    var itemType = this.get('type');\n    var centerX;\n    var centerY;\n    var bbox = this.getBBox();\n\n    if (itemType === 'combo') {\n      centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;\n      centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;\n    } else {\n      centerX = bbox.centerX;\n      centerY = bbox.centerY;\n    }\n\n    var anchorPoints = this.getAnchorPoints();\n    var intersectPoint;\n\n    switch (type) {\n      case 'circle':\n        intersectPoint = getCircleIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          r: bbox.width / 2\n        }, point);\n        break;\n\n      case 'ellipse':\n        intersectPoint = getEllipseIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          rx: bbox.width / 2,\n          ry: bbox.height / 2\n        }, point);\n        break;\n\n      default:\n        intersectPoint = getRectIntersectByPoint(bbox, point);\n    }\n\n    var linkPoint = intersectPoint; // 如果存在锚点，则使用交点计算最近的锚点\n\n    if (anchorPoints.length) {\n      if (!linkPoint) {\n        // 如果计算不出交点\n        linkPoint = point;\n      }\n\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\n    }\n\n    if (!linkPoint) {\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\n      linkPoint = {\n        x: centerX,\n        y: centerY\n      };\n    }\n\n    return linkPoint;\n  };\n  /**\n   * 获取锚点的定义\n   * @return {array} anchorPoints\n   */\n\n\n  Node.prototype.getAnchorPoints = function () {\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\n\n    if (!anchorPoints) {\n      anchorPoints = [];\n      var shapeFactory = this.get('shapeFactory');\n      var bbox_1 = this.getBBox();\n      var model = this.get('model');\n      var shapeCfg = this.getShapeCfg(model);\n      var type = model.type;\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\n      each(points, function (pointArr, index) {\n        var point = {\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\n          y: bbox_1.minY + pointArr[1] * bbox_1.height,\n          anchorIndex: index\n        };\n        anchorPoints.push(point);\n      });\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\n    }\n\n    return anchorPoints;\n  };\n  /**\n   * add edge\n   * @param edge Edge instance\n   */\n\n\n  Node.prototype.addEdge = function (edge) {\n    this.get('edges').push(edge);\n  };\n  /**\n   * 锁定节点\n   */\n\n\n  Node.prototype.lock = function () {\n    this.set('locked', true);\n  };\n  /**\n   * 解锁锁定的节点\n   */\n\n\n  Node.prototype.unlock = function () {\n    this.set('locked', false);\n  };\n\n  Node.prototype.hasLocked = function () {\n    return this.get('locked');\n  };\n  /**\n   * 移除边\n   * @param {Edge} edge 边\n   */\n\n\n  Node.prototype.removeEdge = function (edge) {\n    var edges = this.getEdges();\n    var index = edges.indexOf(edge);\n    if (index > -1) edges.splice(index, 1);\n  };\n\n  Node.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n  /**\n   * 判断更新的种类，move 表示仅移动，bbox 表示大小有变化，style 表示仅与大小无关的参数变化\n   * @param cfg 节点数据模型\n   */\n\n\n  Node.prototype.getUpdateType = function (cfg) {\n    var _a, _b, _c, _d, _e;\n\n    if (!cfg) return undefined;\n    var existX = !isNil(cfg.x);\n    var existY = !isNil(cfg.y);\n    var keys = Object.keys(cfg); // 仅有一个字段，包含 x 或者 包含 y\n    // 两个字段，同时有 x，同时有 y\n\n    if (keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY) return 'move';\n    if (isNumber(cfg.x) || isNumber(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size || (cfg === null || cfg === void 0 ? void 0 : cfg.style) && (((_a = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _a === void 0 ? void 0 : _a.r) || ((_b = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _b === void 0 ? void 0 : _b.width) || ((_c = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _d === void 0 ? void 0 : _d.rx) || ((_e = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _e === void 0 ? void 0 : _e.ry))) return 'bbox|label';\n    var updateLabel = keys.includes('label') || keys.includes('labelCfg');\n    return updateLabel ? 'style|label' : 'style';\n  };\n\n  return Node;\n}(Item);\n\nexport default Node;"],"mappings":"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"},"metadata":{},"sourceType":"module"}