{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nvar _dec, _class, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { injectable } from 'inversify';\nimport { extractUniforms } from '../../utils/shader-module';\nimport { uniq } from '../../utils/uniq';\n/* babel-plugin-inline-import './shaders/webgl.picking.frag.glsl' */\n\nvar pickingFrag = \"varying vec4 v_PickingResult;\\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\\nuniform float u_PickingStage : 0.0;\\n\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n/*\\n * Returns highlight color if this item is selected.\\n */\\nvec4 filterHighlightColor(vec4 color) {\\n  bool selected = bool(v_PickingResult.a);\\n\\n  if (selected) {\\n    vec4 highLightColor = u_HighlightColor * COLOR_SCALE;\\n\\n    float highLightAlpha = highLightColor.a;\\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\\n\\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\\n    return vec4(resultRGB, color.a);\\n  } else {\\n    return color;\\n  }\\n}\\n\\n/*\\n * Returns picking color if picking enabled else unmodified argument.\\n */\\nvec4 filterPickingColor(vec4 color) {\\n  vec3 pickingColor = v_PickingResult.rgb;\\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\\n    discard;\\n  }\\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\\n}\\n\\n/*\\n * Returns picking color if picking is enabled if not\\n * highlight color if this item is selected, otherwise unmodified argument.\\n */\\nvec4 filterColor(vec4 color) {\\n  return filterPickingColor(filterHighlightColor(color));\\n}\\n\";\n/* babel-plugin-inline-import './shaders/webgl.picking.vert.glsl' */\n\nvar pickingVert = \"attribute vec3 a_PickingColor;\\nvarying vec4 v_PickingResult;\\n\\nuniform vec3 u_PickingColor : [0, 0, 0];\\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\\nuniform float u_PickingStage : 0.0;\\nuniform float u_PickingThreshold : 1.0;\\nuniform float u_PickingBuffer: 0.0;\\n\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return\\n    abs(vertexColor.r - u_PickingColor.r) < u_PickingThreshold &&\\n    abs(vertexColor.g - u_PickingColor.g) < u_PickingThreshold &&\\n    abs(vertexColor.b - u_PickingColor.b) < u_PickingThreshold;\\n}\\n\\nvoid setPickingColor(vec3 pickingColor) {\\n  // compares only in highlight stage\\n  v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && isVertexPicked(pickingColor));\\n\\n  // Stores the picking color so that the fragment shader can render it during picking\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nfloat setPickingSize(float x) {\\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\\n}\";\n/* babel-plugin-inline-import './shaders/webgl.sdf2d.frag.glsl' */\n\nvar sdf2dFrag = \"/**\\n * 2D signed distance field functions\\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\\n */\\n\\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\\n\\nfloat sdCircle(vec2 p, float r) {\\n  return length(p) - r;\\n}\\n\\nfloat sdEquilateralTriangle(vec2 p) {\\n  float k = sqrt(3.0);\\n  p.x = abs(p.x) - 1.0;\\n  p.y = p.y + 1.0/k;\\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\\n  p.x -= clamp( p.x, -2.0, 0.0 );\\n  return -length(p)*sign(p.y);\\n}\\n\\nfloat sdBox(vec2 p, vec2 b) {\\n  vec2 d = abs(p)-b;\\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\\n}\\n\\nfloat sdPentagon(vec2 p, float r) {\\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\\n  p.x = abs(p.x);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagon(vec2 p, float r) {\\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdOctogon(vec2 p, float r) {\\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\\n  p = abs(p);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagram(vec2 p, float r) {\\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdRhombus(vec2 p, vec2 b) {\\n  vec2 q = abs(p);\\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\\n}\\n\\nfloat sdVesica(vec2 p, float r, float d) {\\n  p = abs(p);\\n  float b = sqrt(r*r-d*d); // can delay this sqrt\\n  return ((p.y-b)*d>p.x*b)\\n          ? length(p-vec2(0.0,b))\\n          : length(p-vec2(-d,0.0))-r;\\n}\";\nvar precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nvar globalDefaultprecision = '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nvar includeRegExp = /#pragma include ([\"^+\"]?[\"\\ \"[a-zA-Z_0-9](.*)\"]*?)/g;\nvar ShaderModuleService = (_dec = injectable(), _dec(_class = (_temp = /*#__PURE__*/function () {\n  function ShaderModuleService() {\n    _classCallCheck(this, ShaderModuleService);\n\n    this.moduleCache = {};\n    this.rawContentCache = {};\n  }\n\n  _createClass(ShaderModuleService, [{\n    key: \"registerBuiltinModules\",\n    value: function registerBuiltinModules() {\n      this.destroy();\n      this.registerModule('picking', {\n        vs: pickingVert,\n        fs: pickingFrag\n      });\n      this.registerModule('sdf2d', {\n        vs: '',\n        fs: sdf2dFrag\n      });\n    }\n  }, {\n    key: \"registerModule\",\n    value: function registerModule(moduleName, moduleParams) {\n      // prevent registering the same module multiple times\n      if (this.rawContentCache[moduleName]) {\n        return;\n      }\n\n      var _moduleParams$vs = moduleParams.vs,\n          vs = _moduleParams$vs === void 0 ? '' : _moduleParams$vs,\n          _moduleParams$fs = moduleParams.fs,\n          fs = _moduleParams$fs === void 0 ? '' : _moduleParams$fs,\n          declaredUniforms = moduleParams.uniforms;\n\n      var _extractUniforms = extractUniforms(vs),\n          extractedVS = _extractUniforms.content,\n          vsUniforms = _extractUniforms.uniforms;\n\n      var _extractUniforms2 = extractUniforms(fs),\n          extractedFS = _extractUniforms2.content,\n          fsUniforms = _extractUniforms2.uniforms;\n\n      this.rawContentCache[moduleName] = {\n        fs: extractedFS,\n        uniforms: _objectSpread(_objectSpread(_objectSpread({}, vsUniforms), fsUniforms), declaredUniforms),\n        vs: extractedVS\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.moduleCache = {};\n      this.rawContentCache = {};\n    }\n  }, {\n    key: \"getModule\",\n    value: function getModule(moduleName) {\n      var _this = this;\n\n      if (this.moduleCache[moduleName]) {\n        return this.moduleCache[moduleName];\n      }\n\n      var rawVS = this.rawContentCache[moduleName].vs || '';\n      var rawFS = this.rawContentCache[moduleName].fs || '';\n\n      var _this$processModule = this.processModule(rawVS, [], 'vs'),\n          vs = _this$processModule.content,\n          vsIncludeList = _this$processModule.includeList;\n\n      var _this$processModule2 = this.processModule(rawFS, [], 'fs'),\n          fs = _this$processModule2.content,\n          fsIncludeList = _this$processModule2.includeList;\n\n      var compiledFs = fs; // TODO: extract uniforms and their default values from GLSL\n\n      var uniforms = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(function (prev, cur) {\n        return _objectSpread(_objectSpread({}, prev), _this.rawContentCache[cur].uniforms);\n      }, {});\n      /**\n       * set default precision for fragment shader\n       * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n       */\n\n      if (!precisionRegExp.test(fs)) {\n        compiledFs = globalDefaultprecision + fs;\n      }\n\n      this.moduleCache[moduleName] = {\n        fs: compiledFs.trim(),\n        uniforms: uniforms,\n        vs: vs.trim()\n      };\n      return this.moduleCache[moduleName];\n    }\n  }, {\n    key: \"processModule\",\n    value: function processModule(rawContent, includeList, type) {\n      var _this2 = this;\n\n      var compiled = rawContent.replace(includeRegExp, function (_, strMatch) {\n        var includeOpt = strMatch.split(' ');\n        var includeName = includeOpt[0].replace(/\"/g, '');\n\n        if (includeList.indexOf(includeName) > -1) {\n          return '';\n        }\n\n        var txt = _this2.rawContentCache[includeName][type];\n        includeList.push(includeName);\n\n        var _this2$processModule = _this2.processModule(txt || '', includeList, type),\n            content = _this2$processModule.content;\n\n        return content;\n      });\n      return {\n        content: compiled,\n        includeList: includeList\n      };\n    }\n  }]);\n\n  return ShaderModuleService;\n}(), _temp)) || _class);\nexport { ShaderModuleService as default };","map":{"version":3,"mappings":"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","names":["injectable","extractUniforms","uniq","precisionRegExp","globalDefaultprecision","includeRegExp","ShaderModuleService","moduleCache","rawContentCache","destroy","registerModule","vs","pickingVert","fs","pickingFrag","sdf2dFrag","moduleName","moduleParams","declaredUniforms","uniforms","extractedVS","content","vsUniforms","extractedFS","fsUniforms","rawVS","rawFS","processModule","vsIncludeList","includeList","fsIncludeList","compiledFs","concat","reduce","prev","cur","_this","test","trim","rawContent","type","compiled","replace","_","strMatch","includeOpt","split","includeName","indexOf","txt","_this2","push"],"sources":["../../../src/services/shader-module/ShaderModuleService.ts"],"sourcesContent":["import { injectable } from 'inversify';\nimport { extractUniforms } from '../../utils/shader-module';\nimport { uniq } from '../../utils/uniq';\nimport pickingFrag from './shaders/webgl.picking.frag.glsl';\nimport pickingVert from './shaders/webgl.picking.vert.glsl';\nimport sdf2dFrag from './shaders/webgl.sdf2d.frag.glsl';\n\nconst precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nconst globalDefaultprecision =\n  '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nconst includeRegExp = /#pragma include ([\"^+\"]?[\"\\ \"[a-zA-Z_0-9](.*)\"]*?)/g;\n\nimport { IUniform } from '../../components/renderer/IUniform';\n\n/**\n * 提供 ShaderModule 管理服务\n */\n\nexport interface IModuleParams {\n  vs?: string;\n  fs?: string;\n  uniforms?: {\n    [key: string]: IUniform;\n  };\n}\n\nexport interface IShaderModuleService {\n  registerModule(moduleName: string, moduleParams: IModuleParams): void;\n  getModule(moduleName: string): IModuleParams;\n\n  /**\n   * 注册内置 shader module\n   */\n  registerBuiltinModules(): void;\n  destroy(): void;\n}\n\n@injectable()\nexport default class ShaderModuleService implements IShaderModuleService {\n  private moduleCache: { [key: string]: IModuleParams } = {};\n  private rawContentCache: { [key: string]: IModuleParams } = {};\n\n  public registerBuiltinModules() {\n    this.destroy();\n    this.registerModule('picking', { vs: pickingVert, fs: pickingFrag });\n    this.registerModule('sdf2d', { vs: '', fs: sdf2dFrag });\n  }\n\n  public registerModule(moduleName: string, moduleParams: IModuleParams) {\n    // prevent registering the same module multiple times\n    if (this.rawContentCache[moduleName]) {\n      return;\n    }\n\n    const { vs = '', fs = '', uniforms: declaredUniforms } = moduleParams;\n    const { content: extractedVS, uniforms: vsUniforms } = extractUniforms(vs);\n    const { content: extractedFS, uniforms: fsUniforms } = extractUniforms(fs);\n\n    this.rawContentCache[moduleName] = {\n      fs: extractedFS,\n      uniforms: {\n        ...vsUniforms,\n        ...fsUniforms,\n        ...declaredUniforms,\n      },\n      vs: extractedVS,\n    };\n  }\n  public destroy() {\n    this.moduleCache = {};\n    this.rawContentCache = {};\n  }\n  public getModule(moduleName: string): IModuleParams {\n    if (this.moduleCache[moduleName]) {\n      return this.moduleCache[moduleName];\n    }\n\n    const rawVS = this.rawContentCache[moduleName].vs || '';\n    const rawFS = this.rawContentCache[moduleName].fs || '';\n\n    const { content: vs, includeList: vsIncludeList } = this.processModule(\n      rawVS,\n      [],\n      'vs',\n    );\n    const { content: fs, includeList: fsIncludeList } = this.processModule(\n      rawFS,\n      [],\n      'fs',\n    );\n    let compiledFs = fs;\n    // TODO: extract uniforms and their default values from GLSL\n    const uniforms: {\n      [key: string]: any;\n    } = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(\n      (prev, cur: string) => {\n        return {\n          ...prev,\n          ...this.rawContentCache[cur].uniforms,\n        };\n      },\n      {},\n    );\n\n    /**\n     * set default precision for fragment shader\n     * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n     */\n    if (!precisionRegExp.test(fs)) {\n      compiledFs = globalDefaultprecision + fs;\n    }\n\n    this.moduleCache[moduleName] = {\n      fs: compiledFs.trim(),\n      uniforms,\n      vs: vs.trim(),\n    };\n    return this.moduleCache[moduleName];\n  }\n\n  private processModule(\n    rawContent: string,\n    includeList: string[],\n    type: 'vs' | 'fs',\n  ): {\n    content: string;\n    includeList: string[];\n  } {\n    const compiled = rawContent.replace(includeRegExp, (_, strMatch) => {\n      const includeOpt = strMatch.split(' ');\n      const includeName = includeOpt[0].replace(/\"/g, '');\n\n      if (includeList.indexOf(includeName) > -1) {\n        return '';\n      }\n\n      const txt = this.rawContentCache[includeName][type];\n      includeList.push(includeName);\n\n      const { content } = this.processModule(txt || '', includeList, type);\n      return content;\n    });\n\n    return {\n      content: compiled,\n      includeList,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}