{"ast":null,"code":"/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\nimport { Util } from '@antv/g6-core';\nimport { deepMix } from '@antv/util';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox } from './polyline-util';\n\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  } // top\n  ],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: Math.PI / 4,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.round(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (!item) return;\n    var bbox = getExpandedBBox(item.getBBox(), offset);\n\n    for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n      for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n        map[\"\".concat(x, \"|||\").concat(y)] = true;\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n\n  if (deltaX || deltaY) {\n    return Math.atan2(deltaY, deltaX);\n  }\n\n  return 0;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange; // return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, // 被 gridSize 格式化后的位置（anchorPoint）\noriPoint, // 未被 gridSize 格式化的位置（anchorPoint）\nnode, // 原始节点，用于获取 bbox\nanotherPoint, // 另一端被 gridSize 格式化后的位置\ncfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return [point];\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = getExpandedBBox(bbox, offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP_1 = Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {\n          insterctP_1.id = \"\".concat(insterctP_1.x, \"|||\").concat(insterctP_1.y);\n          points.push(insterctP_1);\n        }\n      }\n    }\n\n    return points;\n  } // 如果 anchorPoint 在节点上，只有一个可选方向\n\n\n  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);\n  insterctP.id = \"\".concat(insterctP.x, \"|||\").concat(insterctP.y);\n  return [insterctP];\n};\n\nvar getDirectionChange = function getDirectionChange(current, neighbor, cameFrom, scaleStartPoint) {\n  var directionAngle = getDirectionAngle(current, neighbor);\n\n  if (!cameFrom[current.id]) {\n    var startAngle = getDirectionAngle(scaleStartPoint, current);\n    return getAngleDiff(startAngle, directionAngle);\n  }\n\n  var prevDirectionAngle = getDirectionAngle({\n    x: cameFrom[current.id].x,\n    y: cameFrom[current.id].y\n  }, current);\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n};\n\nvar getControlPoints = function getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {\n  var controlPoints = [endPoint];\n  var currentId = current.id;\n  var currentX = current.x;\n  var currentY = current.y;\n  var lastPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  };\n\n  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {\n    // if (scaleEndPoint.x === endPoint.x && scaleEndPoint.y === endPoint.y)\n    //   controlPoints.unshift({\n    //     x: endPoint.x,\n    //     y: endPoint.y\n    //   })\n    // else\n    //   controlPoints.unshift({\n    //     x: lastPoint.x * gridSize,\n    //     y: lastPoint.y * gridSize,\n    //   });\n    controlPoints.unshift({\n      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,\n      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize\n    });\n  }\n\n  while (cameFrom[currentId] && cameFrom[currentId].id !== currentId) {\n    var point = {\n      x: currentX,\n      y: currentY,\n      id: currentId\n    };\n    var preId = cameFrom[currentId].id;\n    var preX = cameFrom[currentId].x;\n    var preY = cameFrom[currentId].y;\n    var prePoint = {\n      x: preX,\n      y: preY,\n      id: preId\n    };\n    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n\n    if (directionChange) {\n      // if (prePoint.x === point.x && prePoint.y === point.y)\n      //   controlPoints.unshift({\n      //     x: controlPoints[0].x,\n      //     y: controlPoints[0].y\n      //   })\n      // else\n      //   controlPoints.unshift({\n      //     x: prePoint.x * gridSize,\n      //     y: prePoint.y * gridSize,\n      //   });\n      controlPoints.unshift({\n        x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * gridSize,\n        y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * gridSize\n      });\n    }\n\n    currentId = preId;\n    currentX = preX;\n    currentY = preY;\n  } // 和startNode对齐\n\n\n  var firstPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  }; // if (firstPoint.x === scaleStartPoint.x && firstPoint.y === scaleStartPoint.y) {\n  //   controlPoints[0].x = startPoint.x;\n  //   controlPoints[0].y = startPoint.y;\n  // }\n\n  controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n  controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n  controlPoints.unshift(startPoint);\n  return controlPoints;\n};\n\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  if (isNaN(startPoint.x) || isNaN(endPoint.x)) return [];\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var gridSize = cfg.gridSize;\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, gridSize),\n    y: pos2GridIx(startPoint.y, gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, gridSize),\n    y: pos2GridIx(endPoint.y, gridSize)\n  };\n  startPoint.id = \"\".concat(scaleStartPoint.x, \"|||\").concat(scaleStartPoint.y);\n  endPoint.id = \"\".concat(scaleEndPoint.x, \"|||\").concat(scaleEndPoint.y);\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var remainLoops = cfg.maximumLoops;\n  var penalties = cfg.penalties;\n  var current, curCost, direction, neighbor, neighborCost, costFromStart, directionChange;\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    current = undefined;\n    curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    Object.keys(openSet).forEach(function (key) {\n      var id = openSet[key].id;\n\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    });\n    if (!current) break; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      direction = cfg.directions[i];\n      neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: \"\".concat(Math.round(current.x) + direction.stepX, \"|||\").concat(Math.round(current.y) + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(penalties[directionChange]) ? gridSize : penalties[directionChange]);\n      costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};","map":{"version":3,"names":["Util","deepMix","getExpandedBBox","getExpandedBBoxPoint","getPolylinePoints","simplifyPolyline","isSegmentCrossingBBox","manhattanDist","p1","p2","Math","abs","x","y","eucliDist","sqrt","pow","straightPath","start","end","simplePolyline","startNode","endNode","cfg","offset","defaultCfg","maxAllowedDirectionChange","PI","maximumLoops","gridSize","directions","stepX","stepY","penalties","distFunc","fallbackRoute","octolinearCfg","pos2GridIx","pos","gridIx","round","sign","getObstacleMap","items","map","forEach","item","bbox","getBBox","minX","maxX","minY","maxY","concat","getDirectionAngle","deltaX","deltaY","atan2","getAngleDiff","angle1","angle2","directionChange","estimateCost","from","endPoints","min","Infinity","i","len","length","cost","getBoxPoints","point","oriPoint","node","anotherPoint","points","isInside","expandBBox","_i","directions_1","dir","bounds","boundLine","insterctP_1","getLineIntersect","width","height","id","push","insterctP","getDirectionChange","current","neighbor","cameFrom","scaleStartPoint","directionAngle","startAngle","prevDirectionAngle","getControlPoints","endPoint","startPoint","scaleEndPoint","controlPoints","currentId","currentX","currentY","lastPoint","unshift","preId","preX","preY","prePoint","firstPoint","pathFinder","routerCfg","isNaN","obstacles","startPoints","openSet","closedSet","gScore","fScore","firstStep","remainLoops","curCost","direction","neighborCost","costFromStart","Object","keys","undefined","key","findIndex"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/g6-element/es/edges/router.js"],"sourcesContent":["/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\nimport { Util } from '@antv/g6-core';\nimport { deepMix } from '@antv/util';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox } from './polyline-util';\n\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  } // top\n  ],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: Math.PI / 4,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.round(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (!item) return;\n    var bbox = getExpandedBBox(item.getBBox(), offset);\n\n    for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n      for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n        map[\"\".concat(x, \"|||\").concat(y)] = true;\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n\n  if (deltaX || deltaY) {\n    return Math.atan2(deltaY, deltaX);\n  }\n\n  return 0;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange; // return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, // 被 gridSize 格式化后的位置（anchorPoint）\noriPoint, // 未被 gridSize 格式化的位置（anchorPoint）\nnode, // 原始节点，用于获取 bbox\nanotherPoint, // 另一端被 gridSize 格式化后的位置\ncfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return [point];\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = getExpandedBBox(bbox, offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP_1 = Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {\n          insterctP_1.id = \"\".concat(insterctP_1.x, \"|||\").concat(insterctP_1.y);\n          points.push(insterctP_1);\n        }\n      }\n    }\n\n    return points;\n  } // 如果 anchorPoint 在节点上，只有一个可选方向\n\n\n  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);\n  insterctP.id = \"\".concat(insterctP.x, \"|||\").concat(insterctP.y);\n  return [insterctP];\n};\n\nvar getDirectionChange = function getDirectionChange(current, neighbor, cameFrom, scaleStartPoint) {\n  var directionAngle = getDirectionAngle(current, neighbor);\n\n  if (!cameFrom[current.id]) {\n    var startAngle = getDirectionAngle(scaleStartPoint, current);\n    return getAngleDiff(startAngle, directionAngle);\n  }\n\n  var prevDirectionAngle = getDirectionAngle({\n    x: cameFrom[current.id].x,\n    y: cameFrom[current.id].y\n  }, current);\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n};\n\nvar getControlPoints = function getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {\n  var controlPoints = [endPoint];\n  var currentId = current.id;\n  var currentX = current.x;\n  var currentY = current.y;\n  var lastPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  };\n\n  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {\n    // if (scaleEndPoint.x === endPoint.x && scaleEndPoint.y === endPoint.y)\n    //   controlPoints.unshift({\n    //     x: endPoint.x,\n    //     y: endPoint.y\n    //   })\n    // else\n    //   controlPoints.unshift({\n    //     x: lastPoint.x * gridSize,\n    //     y: lastPoint.y * gridSize,\n    //   });\n    controlPoints.unshift({\n      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,\n      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize\n    });\n  }\n\n  while (cameFrom[currentId] && cameFrom[currentId].id !== currentId) {\n    var point = {\n      x: currentX,\n      y: currentY,\n      id: currentId\n    };\n    var preId = cameFrom[currentId].id;\n    var preX = cameFrom[currentId].x;\n    var preY = cameFrom[currentId].y;\n    var prePoint = {\n      x: preX,\n      y: preY,\n      id: preId\n    };\n    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n\n    if (directionChange) {\n      // if (prePoint.x === point.x && prePoint.y === point.y)\n      //   controlPoints.unshift({\n      //     x: controlPoints[0].x,\n      //     y: controlPoints[0].y\n      //   })\n      // else\n      //   controlPoints.unshift({\n      //     x: prePoint.x * gridSize,\n      //     y: prePoint.y * gridSize,\n      //   });\n      controlPoints.unshift({\n        x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * gridSize,\n        y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * gridSize\n      });\n    }\n\n    currentId = preId;\n    currentX = preX;\n    currentY = preY;\n  } // 和startNode对齐\n\n\n  var firstPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  }; // if (firstPoint.x === scaleStartPoint.x && firstPoint.y === scaleStartPoint.y) {\n  //   controlPoints[0].x = startPoint.x;\n  //   controlPoints[0].y = startPoint.y;\n  // }\n\n  controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n  controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n  controlPoints.unshift(startPoint);\n  return controlPoints;\n};\n\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  if (isNaN(startPoint.x) || isNaN(endPoint.x)) return [];\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var gridSize = cfg.gridSize;\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, gridSize),\n    y: pos2GridIx(startPoint.y, gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, gridSize),\n    y: pos2GridIx(endPoint.y, gridSize)\n  };\n  startPoint.id = \"\".concat(scaleStartPoint.x, \"|||\").concat(scaleStartPoint.y);\n  endPoint.id = \"\".concat(scaleEndPoint.x, \"|||\").concat(scaleEndPoint.y);\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var remainLoops = cfg.maximumLoops;\n  var penalties = cfg.penalties;\n  var current, curCost, direction, neighbor, neighborCost, costFromStart, directionChange;\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    current = undefined;\n    curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    Object.keys(openSet).forEach(function (key) {\n      var id = openSet[key].id;\n\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    });\n    if (!current) break; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      direction = cfg.directions[i];\n      neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: \"\".concat(Math.round(current.x) + direction.stepX, \"|||\").concat(Math.round(current.y) + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(penalties[directionChange]) ? gridSize : penalties[directionChange]);\n      costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAT,QAAqB,eAArB;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,SAASC,eAAT,EAA0BC,oBAA1B,EAAgDC,iBAAhD,EAAmEC,gBAAnE,EAAqFC,qBAArF,QAAkH,iBAAlH;;AAEA,IAAIC,aAAa,GAAG,SAASA,aAAT,CAAuBC,EAAvB,EAA2BC,EAA3B,EAA+B;EACjD,OAAOC,IAAI,CAACC,GAAL,CAASH,EAAE,CAACI,CAAH,GAAOH,EAAE,CAACG,CAAnB,IAAwBF,IAAI,CAACC,GAAL,CAASH,EAAE,CAACK,CAAH,GAAOJ,EAAE,CAACI,CAAnB,CAA/B;AACD,CAFD;;AAIA,IAAIC,SAAS,GAAG,SAASA,SAAT,CAAmBN,EAAnB,EAAuBC,EAAvB,EAA2B;EACzC,OAAOC,IAAI,CAACK,IAAL,CAAUL,IAAI,CAACM,GAAL,CAASR,EAAE,CAACI,CAAH,GAAOH,EAAE,CAACG,CAAnB,EAAsB,CAAtB,IAA2BF,IAAI,CAACM,GAAL,CAASR,EAAE,CAACK,CAAH,GAAOJ,EAAE,CAACI,CAAnB,EAAsB,CAAtB,CAArC,CAAP;AACD,CAFD;;AAIA,IAAII,YAAY,GAAG,SAASA,YAAT,CAAsBC,KAAtB,EAA6BC,GAA7B,EAAkC;EACnD;EACA,OAAO,CAACD,KAAD,EAAQC,GAAR,CAAP;AACD,CAHD;;AAKA,IAAIC,cAAc,GAAG,SAASA,cAAT,CAAwBF,KAAxB,EAA+BC,GAA/B,EAAoCE,SAApC,EAA+CC,OAA/C,EAAwDC,GAAxD,EAA6D;EAChF,OAAOlB,gBAAgB,CAACD,iBAAiB,CAACc,KAAD,EAAQC,GAAR,EAAaE,SAAb,EAAwBC,OAAxB,EAAiCC,GAAG,CAACC,MAArC,CAAlB,CAAvB;AACD,CAFD,C,CAEG;;;AAGH,IAAIC,UAAU,GAAG;EACfD,MAAM,EAAE,EADO;EAEfE,yBAAyB,EAAEhB,IAAI,CAACiB,EAAL,GAAU,CAFtB;EAGfC,YAAY,EAAE,IAHC;EAIfC,QAAQ,EAAE,EAJK;EAKfC,UAAU,EAAE,CAAC;IACXC,KAAK,EAAE,CADI;IAEXC,KAAK,EAAE;EAFI,CAAD,EAGT;IACDD,KAAK,EAAE,CAAC,CADP;IAEDC,KAAK,EAAE;EAFN,CAHS,EAMT;IACDD,KAAK,EAAE,CADN;IAEDC,KAAK,EAAE;EAFN,CANS,EAST;IACDD,KAAK,EAAE,CADN;IAEDC,KAAK,EAAE,CAAC;EAFP,CATS,CAYV;EAZU,CALG;;EAoBf,IAAIC,SAAJ,GAAgB;IACd,OAAO;MACL,GAAG,CADE;MAEL,IAAI,KAAKJ,QAAL,GAAgB,CAFf;MAGL,IAAI,KAAKA,QAAL,GAAgB;IAHf,CAAP;EAKD,CA1Bc;;EA4BfK,QAAQ,EAAE3B,aA5BK;EA6Bf4B,aAAa,EAAEf;AA7BA,CAAjB;AA+BA,OAAO,IAAIgB,aAAa,GAAG;EACzBV,yBAAyB,EAAEhB,IAAI,CAACiB,EAAL,GAAU,CADZ;EAEzB;EACAG,UAAU,EAAE,CAAC;IACXC,KAAK,EAAE,CADI;IAEXC,KAAK,EAAE;EAFI,CAAD,EAGT;IACDD,KAAK,EAAE,CADN;IAEDC,KAAK,EAAE;EAFN,CAHS,EAMT;IACDD,KAAK,EAAE,CADN;IAEDC,KAAK,EAAE;EAFN,CANS,EAST;IACDD,KAAK,EAAE,CAAC,CADP;IAEDC,KAAK,EAAE;EAFN,CATS,EAYT;IACDD,KAAK,EAAE,CAAC,CADP;IAEDC,KAAK,EAAE;EAFN,CAZS,EAeT;IACDD,KAAK,EAAE,CAAC,CADP;IAEDC,KAAK,EAAE,CAAC;EAFP,CAfS,EAkBT;IACDD,KAAK,EAAE,CADN;IAEDC,KAAK,EAAE,CAAC;EAFP,CAlBS,EAqBT;IACDD,KAAK,EAAE,CADN;IAEDC,KAAK,EAAE,CAAC;EAFP,CArBS,CAHa;EA4BzBE,QAAQ,EAAEpB,SA5Be;EA6BzBqB,aAAa,EAAElB;AA7BU,CAApB;;AAgCP,IAAIoB,UAAU,GAAG,SAASA,UAAT,CAAoBC,GAApB,EAAyBT,QAAzB,EAAmC;EAClD,IAAIU,MAAM,GAAG7B,IAAI,CAAC8B,KAAL,CAAW9B,IAAI,CAACC,GAAL,CAAS2B,GAAG,GAAGT,QAAf,CAAX,CAAb;EACA,IAAIY,IAAI,GAAGH,GAAG,GAAG,CAAN,GAAU,CAAC,CAAX,GAAe,CAA1B;EACA,OAAOC,MAAM,GAAG,CAAT,GAAa,CAAb,GAAiBE,IAAI,GAAGF,MAA/B;AACD,CAJD;;AAMA,IAAIG,cAAc,GAAG,SAASA,cAAT,CAAwBC,KAAxB,EAA+Bd,QAA/B,EAAyCL,MAAzC,EAAiD;EACpE,IAAIoB,GAAG,GAAG,EAAV;EACAD,KAAK,CAACE,OAAN,CAAc,UAAUC,IAAV,EAAgB;IAC5B;IACA,IAAI,CAACA,IAAL,EAAW;IACX,IAAIC,IAAI,GAAG7C,eAAe,CAAC4C,IAAI,CAACE,OAAL,EAAD,EAAiBxB,MAAjB,CAA1B;;IAEA,KAAK,IAAIZ,CAAC,GAAGyB,UAAU,CAACU,IAAI,CAACE,IAAN,EAAYpB,QAAZ,CAAvB,EAA8CjB,CAAC,IAAIyB,UAAU,CAACU,IAAI,CAACG,IAAN,EAAYrB,QAAZ,CAA7D,EAAoFjB,CAAC,IAAI,CAAzF,EAA4F;MAC1F,KAAK,IAAIC,CAAC,GAAGwB,UAAU,CAACU,IAAI,CAACI,IAAN,EAAYtB,QAAZ,CAAvB,EAA8ChB,CAAC,IAAIwB,UAAU,CAACU,IAAI,CAACK,IAAN,EAAYvB,QAAZ,CAA7D,EAAoFhB,CAAC,IAAI,CAAzF,EAA4F;QAC1F+B,GAAG,CAAC,GAAGS,MAAH,CAAUzC,CAAV,EAAa,KAAb,EAAoByC,MAApB,CAA2BxC,CAA3B,CAAD,CAAH,GAAqC,IAArC;MACD;IACF;EACF,CAVD;EAWA,OAAO+B,GAAP;AACD,CAdD;AAeA;AACA;AACA;AACA;AACA;;;AAGA,IAAIU,iBAAiB,GAAG,SAASA,iBAAT,CAA2B9C,EAA3B,EAA+BC,EAA/B,EAAmC;EACzD,IAAI8C,MAAM,GAAG9C,EAAE,CAACG,CAAH,GAAOJ,EAAE,CAACI,CAAvB;EACA,IAAI4C,MAAM,GAAG/C,EAAE,CAACI,CAAH,GAAOL,EAAE,CAACK,CAAvB;;EAEA,IAAI0C,MAAM,IAAIC,MAAd,EAAsB;IACpB,OAAO9C,IAAI,CAAC+C,KAAL,CAAWD,MAAX,EAAmBD,MAAnB,CAAP;EACD;;EAED,OAAO,CAAP;AACD,CATD;AAUA;AACA;AACA;AACA;AACA;;;AAGA,IAAIG,YAAY,GAAG,SAASA,YAAT,CAAsBC,MAAtB,EAA8BC,MAA9B,EAAsC;EACvD,IAAIC,eAAe,GAAGnD,IAAI,CAACC,GAAL,CAASgD,MAAM,GAAGC,MAAlB,CAAtB;EACA,OAAOC,eAAe,GAAGnD,IAAI,CAACiB,EAAvB,GAA4B,IAAIjB,IAAI,CAACiB,EAAT,GAAckC,eAA1C,GAA4DA,eAAnE,CAFuD,CAE6B;AACrF,CAHD,C,CAGG;;;AAGH,IAAIC,YAAY,GAAG,SAASA,YAAT,CAAsBC,IAAtB,EAA4BC,SAA5B,EAAuC9B,QAAvC,EAAiD;EAClE,IAAI+B,GAAG,GAAGC,QAAV;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,SAAS,CAACK,MAAhC,EAAwCF,CAAC,GAAGC,GAA5C,EAAiDD,CAAC,EAAlD,EAAsD;IACpD,IAAIG,IAAI,GAAGpC,QAAQ,CAAC6B,IAAD,EAAOC,SAAS,CAACG,CAAD,CAAhB,CAAnB;;IAEA,IAAIG,IAAI,GAAGL,GAAX,EAAgB;MACdA,GAAG,GAAGK,IAAN;IACD;EACF;;EAED,OAAOL,GAAP;AACD,CAZD,C,CAYG;;;AAGH,IAAIM,YAAY,GAAG,SAASA,YAAT,CAAsBC,KAAtB,EAA6B;AAChDC,QADmB,EACT;AACVC,IAFmB,EAEb;AACNC,YAHmB,EAGL;AACdpD,GAJmB,EAId;EACH,IAAIqD,MAAM,GAAG,EAAb,CADG,CACc;;EAEjB,IAAI,CAACF,IAAL,EAAW;IACT,OAAO,CAACF,KAAD,CAAP;EACD;;EAED,IAAI1C,UAAU,GAAGP,GAAG,CAACO,UAArB;EAAA,IACIN,MAAM,GAAGD,GAAG,CAACC,MADjB;EAEA,IAAIuB,IAAI,GAAG2B,IAAI,CAAC1B,OAAL,EAAX;EACA,IAAI6B,QAAQ,GAAGJ,QAAQ,CAAC7D,CAAT,GAAamC,IAAI,CAACE,IAAlB,IAA0BwB,QAAQ,CAAC7D,CAAT,GAAamC,IAAI,CAACG,IAA5C,IAAoDuB,QAAQ,CAAC5D,CAAT,GAAakC,IAAI,CAACI,IAAtE,IAA8EsB,QAAQ,CAAC5D,CAAT,GAAakC,IAAI,CAACK,IAA/G;EACA,IAAI0B,UAAU,GAAG5E,eAAe,CAAC6C,IAAD,EAAOvB,MAAP,CAAhC;;EAEA,KAAK,IAAI2C,CAAT,IAAcW,UAAd,EAA0B;IACxBA,UAAU,CAACX,CAAD,CAAV,GAAgB9B,UAAU,CAACyC,UAAU,CAACX,CAAD,CAAX,EAAgB5C,GAAG,CAACM,QAApB,CAA1B;EACD;;EAED,IAAIgD,QAAJ,EAAc;IACZ;IACA,KAAK,IAAIE,EAAE,GAAG,CAAT,EAAYC,YAAY,GAAGlD,UAAhC,EAA4CiD,EAAE,GAAGC,YAAY,CAACX,MAA9D,EAAsEU,EAAE,EAAxE,EAA4E;MAC1E,IAAIE,GAAG,GAAGD,YAAY,CAACD,EAAD,CAAtB;MACA,IAAIG,MAAM,GAAG,CAAC,CAAC;QACbtE,CAAC,EAAEkE,UAAU,CAAC7B,IADD;QAEbpC,CAAC,EAAEiE,UAAU,CAAC3B;MAFD,CAAD,EAGX;QACDvC,CAAC,EAAEkE,UAAU,CAAC5B,IADb;QAEDrC,CAAC,EAAEiE,UAAU,CAAC3B;MAFb,CAHW,CAAD,EAMT,CAAC;QACHvC,CAAC,EAAEkE,UAAU,CAAC7B,IADX;QAEHpC,CAAC,EAAEiE,UAAU,CAAC3B;MAFX,CAAD,EAGD;QACDvC,CAAC,EAAEkE,UAAU,CAAC7B,IADb;QAEDpC,CAAC,EAAEiE,UAAU,CAAC1B;MAFb,CAHC,CANS,EAYT,CAAC;QACHxC,CAAC,EAAEkE,UAAU,CAAC5B,IADX;QAEHrC,CAAC,EAAEiE,UAAU,CAAC3B;MAFX,CAAD,EAGD;QACDvC,CAAC,EAAEkE,UAAU,CAAC5B,IADb;QAEDrC,CAAC,EAAEiE,UAAU,CAAC1B;MAFb,CAHC,CAZS,EAkBT,CAAC;QACHxC,CAAC,EAAEkE,UAAU,CAAC7B,IADX;QAEHpC,CAAC,EAAEiE,UAAU,CAAC1B;MAFX,CAAD,EAGD;QACDxC,CAAC,EAAEkE,UAAU,CAAC5B,IADb;QAEDrC,CAAC,EAAEiE,UAAU,CAAC1B;MAFb,CAHC,CAlBS,CAAb;;MA0BA,KAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;QAC1B,IAAIgB,SAAS,GAAGD,MAAM,CAACf,CAAD,CAAtB;QACA,IAAIiB,WAAW,GAAGpF,IAAI,CAACqF,gBAAL,CAAsBb,KAAtB,EAA6B;UAC7C5D,CAAC,EAAE4D,KAAK,CAAC5D,CAAN,GAAUqE,GAAG,CAAClD,KAAJ,GAAY+C,UAAU,CAACQ,KADS;UAE7CzE,CAAC,EAAE2D,KAAK,CAAC3D,CAAN,GAAUoE,GAAG,CAACjD,KAAJ,GAAY8C,UAAU,CAACS;QAFS,CAA7B,EAGfJ,SAAS,CAAC,CAAD,CAHM,EAGDA,SAAS,CAAC,CAAD,CAHR,CAAlB;;QAKA,IAAIC,WAAW,IAAI,CAAC9E,qBAAqB,CAACkE,KAAD,EAAQY,WAAR,EAAqBrC,IAArB,CAAzC,EAAqE;UACnEqC,WAAW,CAACI,EAAZ,GAAiB,GAAGnC,MAAH,CAAU+B,WAAW,CAACxE,CAAtB,EAAyB,KAAzB,EAAgCyC,MAAhC,CAAuC+B,WAAW,CAACvE,CAAnD,CAAjB;UACA+D,MAAM,CAACa,IAAP,CAAYL,WAAZ;QACD;MACF;IACF;;IAED,OAAOR,MAAP;EACD,CA9DE,CA8DD;;;EAGF,IAAIc,SAAS,GAAGvF,oBAAoB,CAAC2E,UAAD,EAAaN,KAAb,EAAoBG,YAApB,CAApC;EACAe,SAAS,CAACF,EAAV,GAAe,GAAGnC,MAAH,CAAUqC,SAAS,CAAC9E,CAApB,EAAuB,KAAvB,EAA8ByC,MAA9B,CAAqCqC,SAAS,CAAC7E,CAA/C,CAAf;EACA,OAAO,CAAC6E,SAAD,CAAP;AACD,CAxED;;AA0EA,IAAIC,kBAAkB,GAAG,SAASA,kBAAT,CAA4BC,OAA5B,EAAqCC,QAArC,EAA+CC,QAA/C,EAAyDC,eAAzD,EAA0E;EACjG,IAAIC,cAAc,GAAG1C,iBAAiB,CAACsC,OAAD,EAAUC,QAAV,CAAtC;;EAEA,IAAI,CAACC,QAAQ,CAACF,OAAO,CAACJ,EAAT,CAAb,EAA2B;IACzB,IAAIS,UAAU,GAAG3C,iBAAiB,CAACyC,eAAD,EAAkBH,OAAlB,CAAlC;IACA,OAAOlC,YAAY,CAACuC,UAAD,EAAaD,cAAb,CAAnB;EACD;;EAED,IAAIE,kBAAkB,GAAG5C,iBAAiB,CAAC;IACzC1C,CAAC,EAAEkF,QAAQ,CAACF,OAAO,CAACJ,EAAT,CAAR,CAAqB5E,CADiB;IAEzCC,CAAC,EAAEiF,QAAQ,CAACF,OAAO,CAACJ,EAAT,CAAR,CAAqB3E;EAFiB,CAAD,EAGvC+E,OAHuC,CAA1C;EAIA,OAAOlC,YAAY,CAACwC,kBAAD,EAAqBF,cAArB,CAAnB;AACD,CAbD;;AAeA,IAAIG,gBAAgB,GAAG,SAASA,gBAAT,CAA0BP,OAA1B,EAAmCE,QAAnC,EAA6CC,eAA7C,EAA8DK,QAA9D,EAAwEC,UAAxE,EAAoFC,aAApF,EAAmGzE,QAAnG,EAA6G;EAClI,IAAI0E,aAAa,GAAG,CAACH,QAAD,CAApB;EACA,IAAII,SAAS,GAAGZ,OAAO,CAACJ,EAAxB;EACA,IAAIiB,QAAQ,GAAGb,OAAO,CAAChF,CAAvB;EACA,IAAI8F,QAAQ,GAAGd,OAAO,CAAC/E,CAAvB;EACA,IAAI8F,SAAS,GAAG;IACd/F,CAAC,EAAE6F,QADW;IAEd5F,CAAC,EAAE6F,QAFW;IAGdlB,EAAE,EAAEgB;EAHU,CAAhB;;EAMA,IAAIb,kBAAkB,CAACgB,SAAD,EAAYL,aAAZ,EAA2BR,QAA3B,EAAqCC,eAArC,CAAtB,EAA6E;IAC3E;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAQ,aAAa,CAACK,OAAd,CAAsB;MACpBhG,CAAC,EAAE0F,aAAa,CAAC1F,CAAd,KAAoBwF,QAAQ,CAACxF,CAA7B,GAAiCwF,QAAQ,CAACxF,CAA1C,GAA8C+F,SAAS,CAAC/F,CAAV,GAAciB,QAD3C;MAEpBhB,CAAC,EAAEyF,aAAa,CAACzF,CAAd,KAAoBuF,QAAQ,CAACvF,CAA7B,GAAiCuF,QAAQ,CAACvF,CAA1C,GAA8C8F,SAAS,CAAC9F,CAAV,GAAcgB;IAF3C,CAAtB;EAID;;EAED,OAAOiE,QAAQ,CAACU,SAAD,CAAR,IAAuBV,QAAQ,CAACU,SAAD,CAAR,CAAoBhB,EAApB,KAA2BgB,SAAzD,EAAoE;IAClE,IAAIhC,KAAK,GAAG;MACV5D,CAAC,EAAE6F,QADO;MAEV5F,CAAC,EAAE6F,QAFO;MAGVlB,EAAE,EAAEgB;IAHM,CAAZ;IAKA,IAAIK,KAAK,GAAGf,QAAQ,CAACU,SAAD,CAAR,CAAoBhB,EAAhC;IACA,IAAIsB,IAAI,GAAGhB,QAAQ,CAACU,SAAD,CAAR,CAAoB5F,CAA/B;IACA,IAAImG,IAAI,GAAGjB,QAAQ,CAACU,SAAD,CAAR,CAAoB3F,CAA/B;IACA,IAAImG,QAAQ,GAAG;MACbpG,CAAC,EAAEkG,IADU;MAEbjG,CAAC,EAAEkG,IAFU;MAGbvB,EAAE,EAAEqB;IAHS,CAAf;IAKA,IAAIhD,eAAe,GAAG8B,kBAAkB,CAACqB,QAAD,EAAWxC,KAAX,EAAkBsB,QAAlB,EAA4BC,eAA5B,CAAxC;;IAEA,IAAIlC,eAAJ,EAAqB;MACnB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA0C,aAAa,CAACK,OAAd,CAAsB;QACpBhG,CAAC,EAAEoG,QAAQ,CAACpG,CAAT,KAAe4D,KAAK,CAAC5D,CAArB,GAAyB2F,aAAa,CAAC,CAAD,CAAb,CAAiB3F,CAA1C,GAA8CoG,QAAQ,CAACpG,CAAT,GAAaiB,QAD1C;QAEpBhB,CAAC,EAAEmG,QAAQ,CAACnG,CAAT,KAAe2D,KAAK,CAAC3D,CAArB,GAAyB0F,aAAa,CAAC,CAAD,CAAb,CAAiB1F,CAA1C,GAA8CmG,QAAQ,CAACnG,CAAT,GAAagB;MAF1C,CAAtB;IAID;;IAED2E,SAAS,GAAGK,KAAZ;IACAJ,QAAQ,GAAGK,IAAX;IACAJ,QAAQ,GAAGK,IAAX;EACD,CAhEiI,CAgEhI;;;EAGF,IAAIE,UAAU,GAAG;IACfrG,CAAC,EAAE6F,QADY;IAEf5F,CAAC,EAAE6F,QAFY;IAGflB,EAAE,EAAEgB;EAHW,CAAjB,CAnEkI,CAuE/H;EACH;EACA;EACA;;EAEAD,aAAa,CAAC,CAAD,CAAb,CAAiB3F,CAAjB,GAAqBqG,UAAU,CAACrG,CAAX,KAAiBmF,eAAe,CAACnF,CAAjC,GAAqCyF,UAAU,CAACzF,CAAhD,GAAoD2F,aAAa,CAAC,CAAD,CAAb,CAAiB3F,CAA1F;EACA2F,aAAa,CAAC,CAAD,CAAb,CAAiB1F,CAAjB,GAAqBoG,UAAU,CAACpG,CAAX,KAAiBkF,eAAe,CAAClF,CAAjC,GAAqCwF,UAAU,CAACxF,CAAhD,GAAoD0F,aAAa,CAAC,CAAD,CAAb,CAAiB1F,CAA1F;EACA0F,aAAa,CAACK,OAAd,CAAsBP,UAAtB;EACA,OAAOE,aAAP;AACD,CAhFD;;AAkFA,OAAO,IAAIW,UAAU,GAAG,SAASA,UAAT,CAAoBb,UAApB,EAAgCD,QAAhC,EAA0C/E,SAA1C,EAAqDC,OAArD,EAA8D6F,SAA9D,EAAyE;EAC/F,IAAIC,KAAK,CAACf,UAAU,CAACzF,CAAZ,CAAL,IAAuBwG,KAAK,CAAChB,QAAQ,CAACxF,CAAV,CAAhC,EAA8C,OAAO,EAAP;EAC9C,IAAIW,GAAG,GAAGtB,OAAO,CAACwB,UAAD,EAAa0F,SAAb,CAAjB;EACA5F,GAAG,CAAC8F,SAAJ,GAAgB9F,GAAG,CAAC8F,SAAJ,IAAiB,EAAjC;EACA,IAAIxF,QAAQ,GAAGN,GAAG,CAACM,QAAnB;EACA,IAAIe,GAAG,GAAGF,cAAc,CAACnB,GAAG,CAAC8F,SAAJ,CAAchE,MAAd,CAAqB,CAAChC,SAAD,EAAYC,OAAZ,CAArB,CAAD,EAA6CO,QAA7C,EAAuDN,GAAG,CAACC,MAA3D,CAAxB;EACA,IAAIuE,eAAe,GAAG;IACpBnF,CAAC,EAAEyB,UAAU,CAACgE,UAAU,CAACzF,CAAZ,EAAeiB,QAAf,CADO;IAEpBhB,CAAC,EAAEwB,UAAU,CAACgE,UAAU,CAACxF,CAAZ,EAAegB,QAAf;EAFO,CAAtB;EAIA,IAAIyE,aAAa,GAAG;IAClB1F,CAAC,EAAEyB,UAAU,CAAC+D,QAAQ,CAACxF,CAAV,EAAaiB,QAAb,CADK;IAElBhB,CAAC,EAAEwB,UAAU,CAAC+D,QAAQ,CAACvF,CAAV,EAAagB,QAAb;EAFK,CAApB;EAIAwE,UAAU,CAACb,EAAX,GAAgB,GAAGnC,MAAH,CAAU0C,eAAe,CAACnF,CAA1B,EAA6B,KAA7B,EAAoCyC,MAApC,CAA2C0C,eAAe,CAAClF,CAA3D,CAAhB;EACAuF,QAAQ,CAACZ,EAAT,GAAc,GAAGnC,MAAH,CAAUiD,aAAa,CAAC1F,CAAxB,EAA2B,KAA3B,EAAkCyC,MAAlC,CAAyCiD,aAAa,CAACzF,CAAvD,CAAd;EACA,IAAIyG,WAAW,GAAG/C,YAAY,CAACwB,eAAD,EAAkBM,UAAlB,EAA8BhF,SAA9B,EAAyCiF,aAAzC,EAAwD/E,GAAxD,CAA9B;EACA,IAAIyC,SAAS,GAAGO,YAAY,CAAC+B,aAAD,EAAgBF,QAAhB,EAA0B9E,OAA1B,EAAmCyE,eAAnC,EAAoDxE,GAApD,CAA5B;EACA+F,WAAW,CAACzE,OAAZ,CAAoB,UAAU2B,KAAV,EAAiB;IACnC,OAAO5B,GAAG,CAAC4B,KAAK,CAACgB,EAAP,CAAV;EACD,CAFD;EAGAxB,SAAS,CAACnB,OAAV,CAAkB,UAAU2B,KAAV,EAAiB;IACjC,OAAO5B,GAAG,CAAC4B,KAAK,CAACgB,EAAP,CAAV;EACD,CAFD;EAGA,IAAI+B,OAAO,GAAG,EAAd;EACA,IAAIC,SAAS,GAAG,EAAhB;EACA,IAAI1B,QAAQ,GAAG,EAAf,CA1B+F,CA0B5E;;EAEnB,IAAI2B,MAAM,GAAG,EAAb,CA5B+F,CA4B9E;;EAEjB,IAAIC,MAAM,GAAG,EAAb,CA9B+F,CA8B9E;;EAEjB,KAAK,IAAIvD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmD,WAAW,CAACjD,MAAhC,EAAwCF,CAAC,EAAzC,EAA6C;IAC3C,IAAIwD,SAAS,GAAGL,WAAW,CAACnD,CAAD,CAA3B;IACAoD,OAAO,CAACI,SAAS,CAACnC,EAAX,CAAP,GAAwBmC,SAAxB,CAF2C,CAER;;IAEnCF,MAAM,CAACE,SAAS,CAACnC,EAAX,CAAN,GAAuB,CAAvB;IACAkC,MAAM,CAACC,SAAS,CAACnC,EAAX,CAAN,GAAuB1B,YAAY,CAAC6D,SAAD,EAAY3D,SAAZ,EAAuBzC,GAAG,CAACW,QAA3B,CAAnC;EACD;;EAED,IAAI0F,WAAW,GAAGrG,GAAG,CAACK,YAAtB;EACA,IAAIK,SAAS,GAAGV,GAAG,CAACU,SAApB;EACA,IAAI2D,OAAJ,EAAaiC,OAAb,EAAsBC,SAAtB,EAAiCjC,QAAjC,EAA2CkC,YAA3C,EAAyDC,aAAzD,EAAwEnE,eAAxE;;EAEA,OAAOoE,MAAM,CAACC,IAAP,CAAYX,OAAZ,EAAqBlD,MAArB,GAA8B,CAA9B,IAAmCuD,WAAW,GAAG,CAAxD,EAA2D;IACzDhC,OAAO,GAAGuC,SAAV;IACAN,OAAO,GAAG3D,QAAV,CAFyD,CAErC;;IAEpB+D,MAAM,CAACC,IAAP,CAAYX,OAAZ,EAAqB1E,OAArB,CAA6B,UAAUuF,GAAV,EAAe;MAC1C,IAAI5C,EAAE,GAAG+B,OAAO,CAACa,GAAD,CAAP,CAAa5C,EAAtB;;MAEA,IAAIkC,MAAM,CAAClC,EAAD,CAAN,IAAcqC,OAAlB,EAA2B;QACzBA,OAAO,GAAGH,MAAM,CAAClC,EAAD,CAAhB;QACAI,OAAO,GAAG2B,OAAO,CAAC/B,EAAD,CAAjB;MACD;IACF,CAPD;IAQA,IAAI,CAACI,OAAL,EAAc,MAZ2C,CAYpC;;IAErB,IAAI5B,SAAS,CAACqE,SAAV,CAAoB,UAAU7D,KAAV,EAAiB;MACvC,OAAOA,KAAK,CAAC5D,CAAN,KAAYgF,OAAO,CAAChF,CAApB,IAAyB4D,KAAK,CAAC3D,CAAN,KAAY+E,OAAO,CAAC/E,CAApD;IACD,CAFG,IAEC,CAAC,CAFN,EAES;MACP,OAAOsF,gBAAgB,CAACP,OAAD,EAAUE,QAAV,EAAoBC,eAApB,EAAqCK,QAArC,EAA+CC,UAA/C,EAA2DC,aAA3D,EAA0EzE,QAA1E,CAAvB;IACD;;IAED,OAAO0F,OAAO,CAAC3B,OAAO,CAACJ,EAAT,CAAd;IACAgC,SAAS,CAAC5B,OAAO,CAACJ,EAAT,CAAT,GAAwB,IAAxB,CArByD,CAqB3B;IAC9B;;IAEA,KAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5C,GAAG,CAACO,UAAJ,CAAeuC,MAAnC,EAA2CF,CAAC,EAA5C,EAAgD;MAC9C2D,SAAS,GAAGvG,GAAG,CAACO,UAAJ,CAAeqC,CAAf,CAAZ;MACA0B,QAAQ,GAAG;QACTjF,CAAC,EAAEgF,OAAO,CAAChF,CAAR,GAAYkH,SAAS,CAAC/F,KADhB;QAETlB,CAAC,EAAE+E,OAAO,CAAC/E,CAAR,GAAYiH,SAAS,CAAC9F,KAFhB;QAGTwD,EAAE,EAAE,GAAGnC,MAAH,CAAU3C,IAAI,CAAC8B,KAAL,CAAWoD,OAAO,CAAChF,CAAnB,IAAwBkH,SAAS,CAAC/F,KAA5C,EAAmD,KAAnD,EAA0DsB,MAA1D,CAAiE3C,IAAI,CAAC8B,KAAL,CAAWoD,OAAO,CAAC/E,CAAnB,IAAwBiH,SAAS,CAAC9F,KAAnG;MAHK,CAAX;MAKA,IAAIwF,SAAS,CAAC3B,QAAQ,CAACL,EAAV,CAAb,EAA4B;MAC5B3B,eAAe,GAAG8B,kBAAkB,CAACC,OAAD,EAAUC,QAAV,EAAoBC,QAApB,EAA8BC,eAA9B,CAApC;MACA,IAAIlC,eAAe,GAAGtC,GAAG,CAACG,yBAA1B,EAAqD;MACrD,IAAIkB,GAAG,CAACiD,QAAQ,CAACL,EAAV,CAAP,EAAsB,SAVwB,CAUd;MAChC;;MAEA,IAAI,CAAC+B,OAAO,CAAC1B,QAAQ,CAACL,EAAV,CAAZ,EAA2B;QACzB+B,OAAO,CAAC1B,QAAQ,CAACL,EAAV,CAAP,GAAuBK,QAAvB;MACD;;MAEDkC,YAAY,GAAGxG,GAAG,CAACW,QAAJ,CAAa0D,OAAb,EAAsBC,QAAtB,KAAmCuB,KAAK,CAACnF,SAAS,CAAC4B,eAAD,CAAV,CAAL,GAAoChC,QAApC,GAA+CI,SAAS,CAAC4B,eAAD,CAA3F,CAAf;MACAmE,aAAa,GAAGP,MAAM,CAAC7B,OAAO,CAACJ,EAAT,CAAN,GAAqBuC,YAArC;;MAEA,IAAIN,MAAM,CAAC5B,QAAQ,CAACL,EAAV,CAAN,IAAuBwC,aAAa,IAAIP,MAAM,CAAC5B,QAAQ,CAACL,EAAV,CAAlD,EAAiE;QAC/D;MACD;;MAEDM,QAAQ,CAACD,QAAQ,CAACL,EAAV,CAAR,GAAwBI,OAAxB;MACA6B,MAAM,CAAC5B,QAAQ,CAACL,EAAV,CAAN,GAAsBwC,aAAtB;MACAN,MAAM,CAAC7B,QAAQ,CAACL,EAAV,CAAN,GAAsBwC,aAAa,GAAGlE,YAAY,CAAC+B,QAAD,EAAW7B,SAAX,EAAsBzC,GAAG,CAACW,QAA1B,CAAlD;IACD;;IAED0F,WAAW,IAAI,CAAf;EACD;;EAED,OAAOrG,GAAG,CAACY,aAAJ,CAAkBkE,UAAlB,EAA8BD,QAA9B,EAAwC/E,SAAxC,EAAmDC,OAAnD,EAA4DC,GAA5D,CAAP;AACD,CArGM"},"metadata":{},"sourceType":"module"}