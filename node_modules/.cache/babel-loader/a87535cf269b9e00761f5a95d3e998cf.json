{"ast":null,"code":"/**\n * @description Tarjan's algorithm for finding the strongly connected components of a graph.\n * @description https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @description.zh-CN Tarjan 算法用于找到图的强连通子图。\n * @param graph\n * @returns\n */\nvar tarjan = function tarjan(graph) {\n  var index = 0;\n  var stack = [];\n  var visited = new Map(); // node id -> { onStack, lowlink, index }\n\n  var results = [];\n\n  function dfs(v) {\n    var _graph$successors;\n\n    var entry = {\n      onStack: true,\n      lowlink: index,\n      index: index\n    };\n    visited.set(v, entry);\n    index += 1;\n    stack.push(v);\n    (_graph$successors = graph.successors(v)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function (w) {\n      var _visited$get; // 如果 w 没有被访问过，则继续访问 w\n\n\n      if (!visited.has(w)) {\n        dfs(w);\n        var wEntry = visited.get(w);\n        entry.lowlink = Math.min(entry.lowlink, wEntry.lowlink); // 如果 w 在栈顶，则说明 w 和 v 不是强连通的\n      } else if ((_visited$get = visited.get(w)) === null || _visited$get === void 0 ? void 0 : _visited$get.onStack) {\n        var _wEntry = visited.get(w); // 如果 w 在栈中，则说明 w 在当前访问的路径上\n\n\n        entry.lowlink = Math.min(entry.lowlink, _wEntry.index);\n      }\n    }); // 如果 v 的 lowlink 不等于 v 的 index，则说明 v 和 v 的 lowlink 不是强连通的\n\n    if (entry.lowlink === entry.index) {\n      var cmpt = [];\n      var w;\n\n      do {\n        // 将 w 出栈，并将 w 的所有邻接点加入强连通子图\n        w = stack.pop();\n        var wEntry = visited.get(w);\n        wEntry.onStack = false;\n        cmpt.push(w);\n      } while (v !== w);\n\n      results.push(cmpt);\n    }\n  }\n\n  graph.nodes().forEach(function (v) {\n    if (!visited.has(v)) {\n      dfs(v);\n    }\n  });\n  return results;\n};\n\nexport default tarjan;","map":{"version":3,"names":["tarjan","graph","index","stack","visited","Map","results","dfs","v","_graph$successors","entry","onStack","lowlink","set","push","successors","forEach","w","_visited$get","has","wEntry","get","Math","min","_wEntry","cmpt","pop","nodes"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/graphlib/es/algorithm/tarjan.js"],"sourcesContent":["/**\n * @description Tarjan's algorithm for finding the strongly connected components of a graph.\n * @description https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @description.zh-CN Tarjan 算法用于找到图的强连通子图。\n * @param graph\n * @returns\n */\nvar tarjan = function tarjan(graph) {\n  var index = 0;\n  var stack = [];\n  var visited = new Map(); // node id -> { onStack, lowlink, index }\n\n  var results = [];\n\n  function dfs(v) {\n    var _graph$successors;\n\n    var entry = {\n      onStack: true,\n      lowlink: index,\n      index: index\n    };\n    visited.set(v, entry);\n    index += 1;\n    stack.push(v);\n    (_graph$successors = graph.successors(v)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function (w) {\n      var _visited$get;\n\n      // 如果 w 没有被访问过，则继续访问 w\n      if (!visited.has(w)) {\n        dfs(w);\n        var wEntry = visited.get(w);\n        entry.lowlink = Math.min(entry.lowlink, wEntry.lowlink); // 如果 w 在栈顶，则说明 w 和 v 不是强连通的\n      } else if ((_visited$get = visited.get(w)) === null || _visited$get === void 0 ? void 0 : _visited$get.onStack) {\n        var _wEntry = visited.get(w); // 如果 w 在栈中，则说明 w 在当前访问的路径上\n\n\n        entry.lowlink = Math.min(entry.lowlink, _wEntry.index);\n      }\n    }); // 如果 v 的 lowlink 不等于 v 的 index，则说明 v 和 v 的 lowlink 不是强连通的\n\n    if (entry.lowlink === entry.index) {\n      var cmpt = [];\n      var w;\n\n      do {\n        // 将 w 出栈，并将 w 的所有邻接点加入强连通子图\n        w = stack.pop();\n        var wEntry = visited.get(w);\n        wEntry.onStack = false;\n        cmpt.push(w);\n      } while (v !== w);\n\n      results.push(cmpt);\n    }\n  }\n\n  graph.nodes().forEach(function (v) {\n    if (!visited.has(v)) {\n      dfs(v);\n    }\n  });\n  return results;\n};\n\nexport default tarjan;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,MAAM,GAAG,SAASA,MAAT,CAAgBC,KAAhB,EAAuB;EAClC,IAAIC,KAAK,GAAG,CAAZ;EACA,IAAIC,KAAK,GAAG,EAAZ;EACA,IAAIC,OAAO,GAAG,IAAIC,GAAJ,EAAd,CAHkC,CAGT;;EAEzB,IAAIC,OAAO,GAAG,EAAd;;EAEA,SAASC,GAAT,CAAaC,CAAb,EAAgB;IACd,IAAIC,iBAAJ;;IAEA,IAAIC,KAAK,GAAG;MACVC,OAAO,EAAE,IADC;MAEVC,OAAO,EAAEV,KAFC;MAGVA,KAAK,EAAEA;IAHG,CAAZ;IAKAE,OAAO,CAACS,GAAR,CAAYL,CAAZ,EAAeE,KAAf;IACAR,KAAK,IAAI,CAAT;IACAC,KAAK,CAACW,IAAN,CAAWN,CAAX;IACA,CAACC,iBAAiB,GAAGR,KAAK,CAACc,UAAN,CAAiBP,CAAjB,CAArB,MAA8C,IAA9C,IAAsDC,iBAAiB,KAAK,KAAK,CAAjF,GAAqF,KAAK,CAA1F,GAA8FA,iBAAiB,CAACO,OAAlB,CAA0B,UAAUC,CAAV,EAAa;MACnI,IAAIC,YAAJ,CADmI,CAGnI;;;MACA,IAAI,CAACd,OAAO,CAACe,GAAR,CAAYF,CAAZ,CAAL,EAAqB;QACnBV,GAAG,CAACU,CAAD,CAAH;QACA,IAAIG,MAAM,GAAGhB,OAAO,CAACiB,GAAR,CAAYJ,CAAZ,CAAb;QACAP,KAAK,CAACE,OAAN,GAAgBU,IAAI,CAACC,GAAL,CAASb,KAAK,CAACE,OAAf,EAAwBQ,MAAM,CAACR,OAA/B,CAAhB,CAHmB,CAGsC;MAC1D,CAJD,MAIO,IAAI,CAACM,YAAY,GAAGd,OAAO,CAACiB,GAAR,CAAYJ,CAAZ,CAAhB,MAAoC,IAApC,IAA4CC,YAAY,KAAK,KAAK,CAAlE,GAAsE,KAAK,CAA3E,GAA+EA,YAAY,CAACP,OAAhG,EAAyG;QAC9G,IAAIa,OAAO,GAAGpB,OAAO,CAACiB,GAAR,CAAYJ,CAAZ,CAAd,CAD8G,CAChF;;;QAG9BP,KAAK,CAACE,OAAN,GAAgBU,IAAI,CAACC,GAAL,CAASb,KAAK,CAACE,OAAf,EAAwBY,OAAO,CAACtB,KAAhC,CAAhB;MACD;IACF,CAd6F,CAA9F,CAXc,CAyBV;;IAEJ,IAAIQ,KAAK,CAACE,OAAN,KAAkBF,KAAK,CAACR,KAA5B,EAAmC;MACjC,IAAIuB,IAAI,GAAG,EAAX;MACA,IAAIR,CAAJ;;MAEA,GAAG;QACD;QACAA,CAAC,GAAGd,KAAK,CAACuB,GAAN,EAAJ;QACA,IAAIN,MAAM,GAAGhB,OAAO,CAACiB,GAAR,CAAYJ,CAAZ,CAAb;QACAG,MAAM,CAACT,OAAP,GAAiB,KAAjB;QACAc,IAAI,CAACX,IAAL,CAAUG,CAAV;MACD,CAND,QAMST,CAAC,KAAKS,CANf;;MAQAX,OAAO,CAACQ,IAAR,CAAaW,IAAb;IACD;EACF;;EAEDxB,KAAK,CAAC0B,KAAN,GAAcX,OAAd,CAAsB,UAAUR,CAAV,EAAa;IACjC,IAAI,CAACJ,OAAO,CAACe,GAAR,CAAYX,CAAZ,CAAL,EAAqB;MACnBD,GAAG,CAACC,CAAD,CAAH;IACD;EACF,CAJD;EAKA,OAAOF,OAAP;AACD,CAxDD;;AA0DA,eAAeN,MAAf"},"metadata":{},"sourceType":"module"}