{"ast":null,"code":"// @ts-ignore\nimport { copy, create, dot } from 'gl-vec2'; // @ts-ignore\n\nimport { computeMiter, direction, normal } from 'polyline-miter-util';\n\nfunction extrusions(positions, out, point, normal, scale) {\n  addNext(out, normal, -scale);\n  addNext(out, normal, scale);\n  positions.push(point);\n  positions.push(point);\n}\n\nfunction addNext(out, normal, length) {\n  out.push([[normal[0], normal[1]], length]);\n}\n\nexport default function (points, closed, indexOffset) {\n  var lineA = [0, 0];\n  var lineB = [0, 0];\n  var tangent = [0, 0];\n  var miter = [0, 0];\n\n  var _lastFlip = -1;\n\n  var _started = false;\n  var _normal = null;\n  var tmp = create();\n  var count = indexOffset || 0;\n  var miterLimit = 3;\n  var out = [];\n  var attrPos = [];\n  var attrIndex = [];\n  var attrCounters = [0, 0];\n\n  if (closed) {\n    points = points.slice();\n    points.push(points[0]);\n  }\n\n  var total = points.length;\n\n  for (var i = 1; i < total; i++) {\n    var index = count;\n    var last = points[i - 1];\n    var cur = points[i];\n    var next = i < points.length - 1 ? points[i + 1] : null;\n    attrCounters.push(i / total, i / total);\n    direction(lineA, cur, last);\n\n    if (!_normal) {\n      _normal = [0, 0];\n      normal(_normal, lineA);\n    }\n\n    if (!_started) {\n      _started = true;\n      extrusions(attrPos, out, last, _normal, 1);\n    }\n\n    attrIndex.push([index + 0, index + 1, index + 2]);\n\n    if (!next) {\n      // no miter, simple segment\n      normal(_normal, lineA); // reset normal\n\n      extrusions(attrPos, out, cur, _normal, 1);\n      attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n      count += 2;\n    } else {\n      // miter with last\n      // get unit dir of next line\n      direction(lineB, next, cur); // stores tangent & miter\n\n      var miterLen = computeMiter(tangent, miter, lineA, lineB, 1); // get orientation\n\n      var flip = dot(tangent, _normal) < 0 ? -1 : 1;\n      var bevel = miterLen > miterLimit; // 处理相邻线段重叠的情况\n\n      if (!isFinite(miterLen)) {\n        normal(_normal, lineA); // reset normal\n\n        extrusions(attrPos, out, cur, _normal, 1);\n        attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n        count += 2;\n        _lastFlip = flip;\n        continue;\n      }\n\n      if (bevel) {\n        miterLen = miterLimit;\n        attrCounters.push(i / total); // next two points in our first segment\n\n        addNext(out, _normal, -flip);\n        attrPos.push(cur);\n        addNext(out, miter, miterLen * flip);\n        attrPos.push(cur);\n        attrIndex.push(_lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]); // now add the bevel triangle\n\n        attrIndex.push([index + 2, index + 3, index + 4]);\n        normal(tmp, lineB);\n        copy(_normal, tmp); // store normal for next round\n\n        addNext(out, _normal, -flip);\n        attrPos.push(cur); // the miter is now the normal for our next join\n\n        count += 3;\n      } else {\n        // miter\n        // next two points for our miter join\n        extrusions(attrPos, out, cur, miter, miterLen);\n        attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);\n        flip = -1; // the miter is now the normal for our next join\n\n        copy(_normal, miter);\n        count += 2;\n      }\n\n      _lastFlip = flip;\n    }\n  }\n\n  return {\n    normals: out,\n    attrIndex: attrIndex,\n    attrPos: attrPos,\n    attrCounters: attrCounters\n  };\n}","map":{"version":3,"mappings":"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","names":["copy","create","dot","computeMiter","direction","normal","extrusions","positions","out","point","scale","addNext","push","length","points","closed","indexOffset","lineA","lineB","tangent","miter","_lastFlip","_started","_normal","tmp","count","miterLimit","attrPos","attrIndex","attrCounters","slice","total","i","index","last","cur","next","miterLen","flip","bevel","isFinite","normals"],"sources":["../../src/utils/polyline-normals.ts"],"sourcesContent":["// @ts-ignore\nimport { copy, create, dot } from 'gl-vec2';\n// @ts-ignore\nimport { computeMiter, direction, normal } from 'polyline-miter-util';\n\nfunction extrusions(\n  positions: number[][],\n  out: any,\n  point: number[],\n  normal: number[],\n  scale: number,\n) {\n  addNext(out, normal, -scale);\n  addNext(out, normal, scale);\n  positions.push(point);\n  positions.push(point);\n}\n\nfunction addNext(out: any[][], normal: number[], length: number) {\n  out.push([[normal[0], normal[1]], length]);\n}\n\nexport default function(\n  points: number[][],\n  closed: boolean,\n  indexOffset?: number,\n) {\n  const lineA = [0, 0];\n  const lineB = [0, 0];\n  const tangent = [0, 0];\n  const miter = [0, 0];\n  let _lastFlip = -1;\n  let _started = false;\n  let _normal: any = null;\n  const tmp = create();\n  let count = indexOffset || 0;\n  const miterLimit = 3;\n\n  const out: any = [];\n  const attrPos: number[][] = [];\n  const attrIndex = [];\n  const attrCounters: number[] = [0, 0];\n  if (closed) {\n    points = points.slice();\n    points.push(points[0]);\n  }\n\n  const total = points.length;\n  for (let i = 1; i < total; i++) {\n    const index = count;\n    const last = points[i - 1];\n    const cur = points[i];\n    const next = i < points.length - 1 ? points[i + 1] : null;\n\n    attrCounters.push(i / total, i / total);\n\n    direction(lineA, cur, last);\n\n    if (!_normal) {\n      _normal = [0, 0];\n      normal(_normal, lineA);\n    }\n\n    if (!_started) {\n      _started = true;\n      extrusions(attrPos, out, last, _normal, 1);\n    }\n\n    attrIndex.push([index + 0, index + 1, index + 2]);\n\n    if (!next) {\n      // no miter, simple segment\n      normal(_normal, lineA); // reset normal\n      extrusions(attrPos, out, cur, _normal, 1);\n      attrIndex.push(\n        _lastFlip === 1\n          ? [index, index + 2, index + 3]\n          : [index + 2, index + 1, index + 3],\n      );\n\n      count += 2;\n    } else {\n      // miter with last\n      // get unit dir of next line\n      direction(lineB, next, cur);\n\n      // stores tangent & miter\n      let miterLen = computeMiter(tangent, miter, lineA, lineB, 1);\n\n      // get orientation\n      let flip = dot(tangent, _normal) < 0 ? -1 : 1;\n\n      const bevel = miterLen > miterLimit;\n\n      // 处理相邻线段重叠的情况\n      if (!isFinite(miterLen)) {\n        normal(_normal, lineA); // reset normal\n        extrusions(attrPos, out, cur, _normal, 1);\n        attrIndex.push(\n          _lastFlip === 1\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3],\n        );\n\n        count += 2;\n        _lastFlip = flip;\n        continue;\n      }\n\n      if (bevel) {\n        miterLen = miterLimit;\n        attrCounters.push(i / total);\n\n        // next two points in our first segment\n        addNext(out, _normal, -flip);\n        attrPos.push(cur);\n        addNext(out, miter, miterLen * flip);\n        attrPos.push(cur);\n\n        attrIndex.push(\n          _lastFlip !== -flip\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3],\n        );\n\n        // now add the bevel triangle\n        attrIndex.push([index + 2, index + 3, index + 4]);\n\n        normal(tmp, lineB);\n        copy(_normal, tmp); // store normal for next round\n\n        addNext(out, _normal, -flip);\n        attrPos.push(cur);\n\n        // the miter is now the normal for our next join\n        count += 3;\n      } else {\n        // miter\n        // next two points for our miter join\n        extrusions(attrPos, out, cur, miter, miterLen);\n        attrIndex.push(\n          _lastFlip === 1\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3],\n        );\n\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        copy(_normal, miter);\n        count += 2;\n      }\n      _lastFlip = flip;\n    }\n  }\n\n  return {\n    normals: out,\n    attrIndex,\n    attrPos,\n    attrCounters,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}