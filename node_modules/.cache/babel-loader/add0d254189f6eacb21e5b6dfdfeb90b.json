{"ast":null,"code":"import { FunctionExt } from '../../../util';\nimport { Point, Rectangle } from '../../../geometry';\nimport { SortedSet } from './sorted-set';\nimport { ObstacleMap } from './obstacle-map';\nimport * as util from './util';\nimport { resolveOptions } from './options';\n/**\n * Finds the route between two points (`from`, `to`).\n */\n\nfunction findRoute(edgeView, from, to, map, options) {\n  const precision = options.precision;\n  let sourceEndpoint;\n  let targetEndpoint;\n\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(util.getSourceEndpoint(edgeView, options).clone(), precision);\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision);\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(util.getTargetEndpoint(edgeView, options).clone(), precision);\n  } else {\n    targetEndpoint = util.round(to.clone(), precision);\n  } // Get grid for this route.\n\n\n  const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint); // Get pathfinding points.\n  // -----------------------\n\n  const startPoint = sourceEndpoint;\n  const endPoint = targetEndpoint;\n  let startPoints;\n  let endPoints;\n\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(startPoint, from, options.startDirections, grid, options);\n  } else {\n    startPoints = [startPoint];\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);\n  } else {\n    endPoints = [endPoint];\n  } // take into account only accessible rect points (those not under obstacles)\n\n\n  startPoints = startPoints.filter(p => map.isAccessible(p));\n  endPoints = endPoints.filter(p => map.isAccessible(p)); // There is an accessible route point on both sides.\n\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    const openSet = new SortedSet(); // Keeps the actual points for given nodes of the open set.\n\n    const points = {}; // Keeps the point that is immediate predecessor of given element.\n\n    const parents = {}; // Cost from start to a point along best known path.\n\n    const costs = {};\n\n    for (let i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      const startPoint = startPoints[i];\n      const key = util.getKey(startPoint);\n      openSet.add(key, util.getCost(startPoint, endPoints));\n      points[key] = startPoint;\n      costs[key] = 0;\n    }\n\n    const previousRouteDirectionAngle = options.previousDirectionAngle; // undefined for first route\n\n    const isPathBeginning = previousRouteDirectionAngle === undefined; // directions\n\n    let direction;\n    let directionChange;\n    const directions = util.getGridOffsets(grid, options);\n    const numDirections = directions.length;\n    const endPointsKeys = endPoints.reduce((res, endPoint) => {\n      const key = util.getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []); // main route finding loop\n\n    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);\n    let loopsRemaining = options.maxLoopCount;\n\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      const currentKey = openSet.pop();\n      const currentPoint = points[currentKey];\n      const currentParent = parents[currentKey];\n      const currentCost = costs[currentKey];\n      const isStartPoint = currentPoint.equals(startPoint);\n      const isRouteBeginning = currentParent == null;\n      let previousDirectionAngle;\n\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle;\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);\n      } else {\n        previousDirectionAngle = null;\n      } // Check if we reached any endpoint\n\n\n      const skipEndCheck = isRouteBeginning && sameStartEndPoints;\n\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle;\n        return util.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);\n      } // Go over all possible directions and find neighbors\n\n\n      for (let i = 0; i < numDirections; i += 1) {\n        direction = directions[i];\n        const directionAngle = direction.angle;\n        directionChange = util.getDirectionChange(previousDirectionAngle, directionAngle); // Don't use the point changed rapidly.\n\n        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {\n          continue;\n        }\n\n        const neighborPoint = util.align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);\n        const neighborKey = util.getKey(neighborPoint); // Closed points were already evaluated.\n\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue;\n        } // Neighbor is an end point.\n\n\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          const isEndPoint = neighborPoint.equals(endPoint);\n\n          if (!isEndPoint) {\n            const endDirectionAngle = util.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);\n            const endDirectionChange = util.getDirectionChange(directionAngle, endDirectionAngle);\n\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue;\n            }\n          }\n        } // The current direction is ok.\n        // ----------------------------\n\n\n        const neighborCost = direction.cost;\n        const neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];\n        const costFromStart = currentCost + neighborCost + neighborPenalty; // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + util.getCost(neighborPoint, endPoints));\n        }\n      }\n\n      loopsRemaining -= 1;\n    }\n  }\n\n  if (options.fallbackRoute) {\n    return FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);\n  }\n\n  return null;\n}\n\nexport const router = function (vertices, optionsRaw, edgeView) {\n  const options = resolveOptions(optionsRaw);\n  const sourceBBox = util.getSourceBBox(edgeView, options);\n  const targetBBox = util.getTargetBBox(edgeView, options);\n  const sourceEndpoint = util.getSourceEndpoint(edgeView, options); // pathfinding\n\n  const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);\n  const oldVertices = vertices.map(p => Point.create(p));\n  const newVertices = []; // The origin of first route's grid, does not need snapping\n\n  let tailPoint = sourceEndpoint;\n  let from;\n  let to;\n\n  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n    let partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i]; // This is the last iteration\n\n    if (to == null) {\n      to = targetBBox; // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n\n      const edge = edgeView.cell;\n      const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;\n\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        const dragFrom = from === sourceBBox ? sourceEndpoint : from;\n        const dragTo = to.getOrigin();\n        partialRoute = FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);\n      }\n    } // Find the partial route\n\n\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options);\n    } // Cannot found the partial route.\n\n\n    if (partialRoute === null) {\n      return FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);\n    } // Remove the first point if the previous partial route has\n    // the same point as last.\n\n\n    const leadPoint = partialRoute[0];\n\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift();\n    } // Save tailPoint for next iteration\n\n\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    newVertices.push(...partialRoute);\n  }\n\n  return newVertices;\n};","map":{"version":3,"mappings":"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","names":["FunctionExt","Point","Rectangle","SortedSet","ObstacleMap","util","resolveOptions","findRoute","edgeView","from","to","map","options","precision","sourceEndpoint","targetEndpoint","isRectangle","round","getSourceEndpoint","clone","getTargetEndpoint","grid","getGrid","step","startPoint","endPoint","startPoints","endPoints","getRectPoints","startDirections","endDirections","filter","p","isAccessible","length","openSet","points","parents","costs","i","n","key","getKey","add","getCost","previousRouteDirectionAngle","previousDirectionAngle","isPathBeginning","undefined","direction","directionChange","directions","getGridOffsets","numDirections","endPointsKeys","reduce","res","push","sameStartEndPoints","equalPoints","loopsRemaining","maxLoopCount","isEmpty","currentKey","pop","currentPoint","currentParent","currentCost","isStartPoint","equals","isRouteBeginning","getDirectionAngle","skipEndCheck","indexOf","reconstructRoute","directionAngle","angle","getDirectionChange","maxDirectionChange","neighborPoint","align","translate","gridOffsetX","gridOffsetY","neighborKey","isClose","isEndPoint","endDirectionAngle","endDirectionChange","neighborCost","cost","neighborPenalty","penalties","costFromStart","isOpen","fallbackRoute","call","router","vertices","optionsRaw","sourceBBox","getSourceBBox","targetBBox","getTargetBBox","build","graph","model","cell","oldVertices","create","newVertices","tailPoint","len","partialRoute","edge","isEndingAtPoint","getSourceCellId","getTargetCellId","draggingRouter","dragFrom","dragTo","getOrigin","fallbackRouter","leadPoint","shift"],"sourceRoot":"","sources":["../../../../src/registry/router/manhattan/router.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}