{"ast":null,"code":"export var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  var pointsLength = points.length;\n\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = \"\".concat(p.x, \"|||\").concat(p.y);\n    pointsMap[p.id] = p;\n    result.push(p);\n  }\n\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  } // when it is a point\n\n\n  return bbox;\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, // 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint, // 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  // const { minX, minY, maxX, maxY } = bbox;\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n        pa = _a[0],\n        pb = _a[1],\n        pc = _a[2],\n        pd = _a[3];\n\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current, lowestFScore;\n\n  while (openSet.length) {\n    current = undefined;\n    lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] <= lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\".concat(startPoint.x, \" \").concat(startPoint.y));\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\".concat(ps.x, \" \").concat(ps.y));\n        pathSegments.push(\"Q\".concat(p1.x, \" \").concat(p1.y, \" \").concat(pt.x, \" \").concat(pt.y));\n        pathSegments.push(\"L\".concat(pt.x, \" \").concat(pt.y));\n      } else {\n        pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tKeyShapeBBox = tNode.getKeyShape().getBBox();\n\n    if (tKeyShapeBBox) {\n      var _a = tNode.getModel(),\n          tx = _a.x,\n          ty = _a.y;\n\n      tBBox = {\n        x: tx,\n        y: ty,\n        width: tKeyShapeBBox.width,\n        height: tKeyShapeBBox.height,\n        minX: tKeyShapeBBox.minX + tx,\n        maxX: tKeyShapeBBox.maxX + tx,\n        minY: tKeyShapeBBox.minY + ty,\n        maxY: tKeyShapeBBox.maxY + ty\n      };\n      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n    } else {\n      tBBox = getBBoxFromPoint(end);\n    }\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  } // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset); // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n      connectPoints.push(p);\n    }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};","map":{"version":3,"names":["getBBoxFromPoint","point","x","y","centerX","centerY","minX","minY","maxX","maxY","height","width","getBBoxFromPoints","points","xs","ys","forEach","p","push","Math","min","apply","max","isBBoxesOverlapping","b1","b2","abs","filterConnectPoints","result","pointsMap","pointsLength","length","i","id","concat","simplifyPolyline","getSimplePolyline","sPoint","tPoint","getExpandedBBox","bbox","offset","isHorizontalPort","port","dx","dy","getExpandedBBoxPoint","anotherPoint","isHorizontal","mergeBBox","getPointsFromBBox","isPointOutsideBBox","getBBoxXCrossPoints","getBBoxYCrossPoints","getBBoxCrossPointsByPoint","distance","p1","p2","_costByPoints","heuristicCostEstimate","ps","pt","source","target","reconstructPath","pathPoints","pointById","cameFrom","currentId","iterator","unshift","removeFrom","arr","item","index","indexOf","splice","isSegmentsIntersected","p0","p3","v1x","v1y","v2x","v2y","v3x","v3y","v4x","v4y","pd1","pd2","pd3","pd4","isSegmentCrossingBBox","_a","pa","pb","pc","pd","getNeighborPoints","bbox1","bbox2","neighbors","pathFinder","start","goal","sBBox","tBBox","os","ot","closedSet","openSet","gScore","fScore","current","lowestFScore","undefined","Infinity","neighbor","tentativeGScore","isBending","getBorderRadiusPoints","r","d0","d1","getPathWithBorderRadiusByPolyline","borderRadius","pathSegments","startPoint","join","getPolylinePoints","end","sNode","tNode","getType","sNodeKeyShape","getKeyShape","getCanvasBBox","getBBox","tKeyShapeBBox","getModel","tx","ty","sxBBox","txBBox","lineBBox","sMixBBox","tMixBBox","connectPoints","centerPoint","filter"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/g6-element/es/edges/polyline-util.js"],"sourcesContent":["export var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  var pointsLength = points.length;\n\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = \"\".concat(p.x, \"|||\").concat(p.y);\n    pointsMap[p.id] = p;\n    result.push(p);\n  }\n\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  } // when it is a point\n\n\n  return bbox;\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, // 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint, // 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  // const { minX, minY, maxX, maxY } = bbox;\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n        pa = _a[0],\n        pb = _a[1],\n        pc = _a[2],\n        pd = _a[3];\n\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current, lowestFScore;\n\n  while (openSet.length) {\n    current = undefined;\n    lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] <= lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\".concat(startPoint.x, \" \").concat(startPoint.y));\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\".concat(ps.x, \" \").concat(ps.y));\n        pathSegments.push(\"Q\".concat(p1.x, \" \").concat(p1.y, \" \").concat(pt.x, \" \").concat(pt.y));\n        pathSegments.push(\"L\".concat(pt.x, \" \").concat(pt.y));\n      } else {\n        pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\".concat(p1.x, \" \").concat(p1.y));\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tKeyShapeBBox = tNode.getKeyShape().getBBox();\n\n    if (tKeyShapeBBox) {\n      var _a = tNode.getModel(),\n          tx = _a.x,\n          ty = _a.y;\n\n      tBBox = {\n        x: tx,\n        y: ty,\n        width: tKeyShapeBBox.width,\n        height: tKeyShapeBBox.height,\n        minX: tKeyShapeBBox.minX + tx,\n        maxX: tKeyShapeBBox.maxX + tx,\n        minY: tKeyShapeBBox.minY + ty,\n        maxY: tKeyShapeBBox.maxY + ty\n      };\n      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n    } else {\n      tBBox = getBBoxFromPoint(end);\n    }\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  } // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset); // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n      connectPoints.push(p);\n    }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}