{"ast":null,"code":"import { ArrayExt } from '../../util';\nimport { Point, Line, Angle } from '../../geometry';\nimport * as Util from './util';\n/**\n * Returns a route with orthogonal line segments.\n */\n\nexport const orth = function (vertices, options, edgeView) {\n  let sourceBBox = Util.getSourceBBox(edgeView, options);\n  let targetBBox = Util.getTargetBBox(edgeView, options);\n  const sourceAnchor = Util.getSourceAnchor(edgeView, options);\n  const targetAnchor = Util.getTargetAnchor(edgeView, options); // If anchor lies outside of bbox, the bbox expands to include it\n\n  sourceBBox = sourceBBox.union(Util.getPointBBox(sourceAnchor));\n  targetBBox = targetBBox.union(Util.getPointBBox(targetAnchor));\n  const points = vertices.map(p => Point.create(p));\n  points.unshift(sourceAnchor);\n  points.push(targetAnchor); // bearing of previous route segment\n\n  let bearing = null;\n  const result = [];\n\n  for (let i = 0, len = points.length - 1; i < len; i += 1) {\n    let route = null;\n    const from = points[i];\n    const to = points[i + 1];\n    const isOrthogonal = Private.getBearing(from, to) != null;\n\n    if (i === 0) {\n      // source\n      if (i + 1 === len) {\n        // source -> target\n        // Expand one of the nodes by 1px to detect situations when the two\n        // nodes are positioned next to each other with no gap in between.\n        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {\n          route = Private.insideNode(from, to, sourceBBox, targetBBox);\n        } else if (!isOrthogonal) {\n          route = Private.nodeToNode(from, to, sourceBBox, targetBBox);\n        }\n      } else {\n        // source -> vertex\n        if (sourceBBox.containsPoint(to)) {\n          route = Private.insideNode(from, to, sourceBBox, Util.getPointBBox(to).moveAndExpand(Util.getPaddingBox(options)));\n        } else if (!isOrthogonal) {\n          route = Private.nodeToVertex(from, to, sourceBBox);\n        }\n      }\n    } else if (i + 1 === len) {\n      // vertex -> target\n      // prevent overlaps with previous line segment\n      const isOrthogonalLoop = isOrthogonal && Private.getBearing(to, from) === bearing;\n\n      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n        route = Private.insideNode(from, to, Util.getPointBBox(from).moveAndExpand(Util.getPaddingBox(options)), targetBBox, bearing);\n      } else if (!isOrthogonal) {\n        route = Private.vertexToNode(from, to, targetBBox, bearing);\n      }\n    } else if (!isOrthogonal) {\n      // vertex -> vertex\n      route = Private.vertexToVertex(from, to, bearing);\n    } // set bearing for next iteration\n\n\n    if (route) {\n      result.push(...route.points);\n      bearing = route.direction;\n    } else {\n      // orthogonal route and not looped\n      bearing = Private.getBearing(from, to);\n    } // push `to` point to identified orthogonal vertices array\n\n\n    if (i + 1 < len) {\n      result.push(to);\n    }\n  }\n\n  return result;\n};\nvar Private;\n\n(function (Private) {\n  /**\n   * Bearing to opposite bearing map\n   */\n  const opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n  };\n  /**\n   * Bearing to radians map\n   */\n\n  const radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n  };\n  /**\n   * Returns a point `p` where lines p,p1 and p,p2 are perpendicular\n   * and p is not contained in the given box\n   */\n\n  function freeJoin(p1, p2, bbox) {\n    let p = new Point(p1.x, p2.y);\n\n    if (bbox.containsPoint(p)) {\n      p = new Point(p2.x, p1.y);\n    } // kept for reference\n    // if (bbox.containsPoint(p)) {\n    //   return null\n    // }\n\n\n    return p;\n  }\n  /**\n   * Returns either width or height of a bbox based on the given bearing.\n   */\n\n\n  function getBBoxSize(bbox, bearing) {\n    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n  }\n\n  Private.getBBoxSize = getBBoxSize;\n\n  function getBearing(from, to) {\n    if (from.x === to.x) {\n      return from.y > to.y ? 'N' : 'S';\n    }\n\n    if (from.y === to.y) {\n      return from.x > to.x ? 'W' : 'E';\n    }\n\n    return null;\n  }\n\n  Private.getBearing = getBearing;\n\n  function vertexToVertex(from, to, bearing) {\n    const p1 = new Point(from.x, to.y);\n    const p2 = new Point(to.x, from.y);\n    const d1 = getBearing(from, p1);\n    const d2 = getBearing(from, p2);\n    const opposite = bearing ? opposites[bearing] : null;\n    const p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n    return {\n      points: [p],\n      direction: getBearing(p, to)\n    };\n  }\n\n  Private.vertexToVertex = vertexToVertex;\n\n  function nodeToVertex(from, to, fromBBox) {\n    const p = freeJoin(from, to, fromBBox);\n    return {\n      points: [p],\n      direction: getBearing(p, to)\n    };\n  }\n\n  Private.nodeToVertex = nodeToVertex;\n\n  function vertexToNode(from, to, toBBox, bearing) {\n    const points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n    const freePoints = points.filter(p => !toBBox.containsPoint(p));\n    const freeBearingPoints = freePoints.filter(p => getBearing(p, from) !== bearing);\n    let p;\n\n    if (freeBearingPoints.length > 0) {\n      // Try to pick a point which bears the same direction as the previous segment.\n      p = freeBearingPoints.filter(p => getBearing(from, p) === bearing).pop();\n      p = p || freeBearingPoints[0];\n      return {\n        points: [p],\n        direction: getBearing(p, to)\n      };\n    }\n\n    {\n      // Here we found only points which are either contained in the element or they would create\n      // a link segment going in opposite direction from the previous one.\n      // We take the point inside element and move it outside the element in the direction the\n      // route is going. Now we can join this point with the current end (using freeJoin).\n      p = ArrayExt.difference(points, freePoints)[0];\n      const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n      const p1 = freeJoin(p2, from, toBBox);\n      return {\n        points: [p1, p2],\n        direction: getBearing(p2, to)\n      };\n    }\n  }\n\n  Private.vertexToNode = vertexToNode;\n\n  function nodeToNode(from, to, fromBBox, toBBox) {\n    let route = nodeToVertex(to, from, toBBox);\n    const p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n      route = nodeToVertex(from, to, fromBBox);\n      const p2 = route.points[0];\n\n      if (toBBox.containsPoint(p2)) {\n        const fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n        const toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n        const mid = new Line(fromBorder, toBorder).getCenter();\n        const startRoute = nodeToVertex(from, mid, fromBBox);\n        const endRoute = vertexToVertex(mid, to, startRoute.direction);\n        route.points = [startRoute.points[0], endRoute.points[0]];\n        route.direction = endRoute.direction;\n      }\n    }\n\n    return route;\n  }\n\n  Private.nodeToNode = nodeToNode; // Finds route for situations where one node is inside the other.\n  // Typically the route is directed outside the outer node first and\n  // then back towards the inner node.\n\n  function insideNode(from, to, fromBBox, toBBox, bearing) {\n    const boundary = fromBBox.union(toBBox).inflate(1); // start from the point which is closer to the boundary\n\n    const center = boundary.getCenter();\n    const reversed = center.distance(to) > center.distance(from);\n    const start = reversed ? to : from;\n    const end = reversed ? from : to;\n    let p1;\n    let p2;\n    let p3;\n\n    if (bearing) {\n      // Points on circle with radius equals 'W + H` are always outside the rectangle\n      // with width W and height H if the center of that circle is the center of that rectangle.\n      p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n      p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);\n    } else {\n      p1 = boundary.getNearestPointToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n    let points;\n\n    if (p1.round().equals(p2.round())) {\n      p2 = Point.fromPolar(boundary.width + boundary.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);\n      p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();\n      p3 = freeJoin(p1, p2, boundary);\n      points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n    } else {\n      points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n    return {\n      points,\n      direction\n    };\n  }\n\n  Private.insideNode = insideNode;\n})(Private || (Private = {}));","map":{"version":3,"mappings":"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","names":["ArrayExt","Point","Line","Angle","Util","orth","vertices","options","edgeView","sourceBBox","getSourceBBox","targetBBox","getTargetBBox","sourceAnchor","getSourceAnchor","targetAnchor","getTargetAnchor","union","getPointBBox","points","map","p","create","unshift","push","bearing","result","i","len","length","route","from","to","isOrthogonal","Private","getBearing","intersectsWithRect","clone","inflate","insideNode","nodeToNode","containsPoint","moveAndExpand","getPaddingBox","nodeToVertex","isOrthogonalLoop","vertexToNode","vertexToVertex","direction","opposites","N","S","E","W","radians","Math","PI","freeJoin","p1","p2","bbox","x","y","getBBoxSize","d1","d2","opposite","fromBBox","toBBox","freePoints","filter","freeBearingPoints","pop","difference","move","fromBorder","toBorder","mid","getCenter","startRoute","endRoute","boundary","center","reversed","distance","start","end","p3","fromPolar","width","height","getNearestPointToPoint","round","equals","toRad","theta"],"sourceRoot":"","sources":["../../../src/registry/router/orth.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}