{"ast":null,"code":"\"use strict\";\n/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConcentricLayout = void 0;\n\nvar util_1 = require(\"../util\");\n\nvar base_1 = require(\"./base\");\n/**\n * 同心圆布局\n */\n\n\nvar ConcentricLayout =\n/** @class */\nfunction (_super) {\n  __extends(ConcentricLayout, _super);\n\n  function ConcentricLayout(options) {\n    var _this = _super.call(this) || this;\n\n    _this.nodeSize = 30;\n    /** min spacing between outside of nodes (used for radius adjustment) */\n\n    _this.minNodeSpacing = 10;\n    /** same as minNodeSpacing. min spacing between outside of nodes (used for radius adjustment) */\n\n    _this.nodeSpacing = 10;\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = false;\n    /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n\n    _this.equidistant = false;\n    /** where nodes start in radians */\n\n    _this.startAngle = 3 / 2 * Math.PI;\n    /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n\n    _this.clockwise = true;\n    /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n\n    _this.sortBy = \"degree\";\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  ConcentricLayout.prototype.getDefaultCfg = function () {\n    return {\n      nodeSize: 30,\n      minNodeSpacing: 10,\n      nodeSpacing: 10,\n      preventOverlap: false,\n      sweep: undefined,\n      equidistant: false,\n      startAngle: 3 / 2 * Math.PI,\n      clockwise: true,\n      maxLevelDiff: undefined,\n      sortBy: \"degree\"\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  ConcentricLayout.prototype.execute = function () {\n    var _a, _b;\n\n    var self = this;\n    var nodes = self.nodes,\n        edges = self.edges;\n    var n = nodes.length;\n\n    if (n === 0) {\n      (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n\n    var center = self.center;\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n      return;\n    }\n\n    var nodeSize = self.nodeSize,\n        nodeSpacing = self.nodeSpacing;\n    var layoutNodes = [];\n    var maxNodeSize;\n    var maxNodeSpacing = 0;\n\n    if ((0, util_1.isArray)(nodeSize)) {\n      maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);\n    } else {\n      maxNodeSize = nodeSize;\n    }\n\n    if ((0, util_1.isArray)(nodeSpacing)) {\n      maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);\n    } else if ((0, util_1.isNumber)(nodeSpacing)) {\n      maxNodeSpacing = nodeSpacing;\n    }\n\n    nodes.forEach(function (node) {\n      layoutNodes.push(node);\n      var nodeSize = maxNodeSize;\n\n      if ((0, util_1.isArray)(node.size)) {\n        nodeSize = Math.max(node.size[0], node.size[1]);\n      } else if ((0, util_1.isNumber)(node.size)) {\n        nodeSize = node.size;\n      } else if ((0, util_1.isObject)(node.size)) {\n        nodeSize = Math.max(node.size.width, node.size.height);\n      }\n\n      maxNodeSize = Math.max(maxNodeSize, nodeSize);\n\n      if ((0, util_1.isFunction)(nodeSpacing)) {\n        maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);\n      }\n    });\n    self.clockwise = self.counterclockwise !== undefined ? !self.counterclockwise : self.clockwise; // layout\n\n    var nodeMap = {};\n    var indexMap = {};\n    layoutNodes.forEach(function (node, i) {\n      nodeMap[node.id] = node;\n      indexMap[node.id] = i;\n    }); // get the node degrees\n\n    if (self.sortBy === \"degree\" || !(0, util_1.isString)(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = \"degree\";\n\n      if (!(0, util_1.isNumber)(nodes[0].degree)) {\n        var values_1 = (0, util_1.getDegree)(nodes.length, indexMap, edges);\n        layoutNodes.forEach(function (node, i) {\n          node.degree = values_1[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort(function (n1, n2) {\n      return n2[self.sortBy] - n1[self.sortBy];\n    });\n    self.maxValueNode = layoutNodes[0];\n    self.maxLevelDiff = self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4; // put the values into levels\n\n    var levels = [[]];\n    var currentLevel = levels[0];\n    layoutNodes.forEach(function (node) {\n      if (currentLevel.length > 0) {\n        var diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n\n        if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n\n      currentLevel.push(node);\n    }); // create positions for levels\n\n    var minDist = maxNodeSize + (maxNodeSpacing || self.minNodeSpacing); // min dist between nodes\n\n    if (!self.preventOverlap) {\n      // then strictly constrain to bb\n      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      var maxR = Math.min(self.width, self.height) / 2 - minDist;\n      var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n      minDist = Math.min(minDist, rStep);\n    } // find the metrics for each level\n\n\n    var r = 0;\n    levels.forEach(function (level) {\n      var sweep = self.sweep;\n\n      if (sweep === undefined) {\n        sweep = 2 * Math.PI - 2 * Math.PI / level.length;\n      }\n\n      var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n      if (level.length > 1 && self.preventOverlap) {\n        // but only if more than one node (can't overlap)\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n        r = Math.max(rMin, r);\n      }\n\n      level.r = r;\n      r += minDist;\n    });\n\n    if (self.equidistant) {\n      var rDeltaMax_1 = 0;\n      var rr_1 = 0;\n\n      for (var i = 0; i < levels.length; i++) {\n        var level = levels[i];\n        var rDelta = level.r - rr_1;\n        rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);\n      }\n\n      rr_1 = 0;\n      levels.forEach(function (level, i) {\n        if (i === 0) {\n          rr_1 = level.r;\n        }\n\n        level.r = rr_1;\n        rr_1 += rDeltaMax_1;\n      });\n    } // calculate the node positions\n\n\n    levels.forEach(function (level) {\n      var dTheta = level.dTheta;\n      var rr = level.r;\n      level.forEach(function (node, j) {\n        var theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n        node.x = center[0] + rr * Math.cos(theta);\n        node.y = center[1] + rr * Math.sin(theta);\n      });\n    });\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  };\n\n  ConcentricLayout.prototype.getType = function () {\n    return \"concentric\";\n  };\n\n  return ConcentricLayout;\n}(base_1.Base);\n\nexports.ConcentricLayout = ConcentricLayout;","map":{"version":3,"mappings":"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","names":["__extends","options","_super","_this","Math","PI","updateCfg","ConcentricLayout","nodeSize","minNodeSpacing","nodeSpacing","preventOverlap","sweep","undefined","equidistant","startAngle","clockwise","maxLevelDiff","sortBy","self","edges","n","nodes","length","onLayoutEnd","_a","width","window","innerWidth","height","innerHeight","center","x","y","_b","layoutNodes","maxNodeSize","maxNodeSpacing","max","forEach","node","push","size","counterclockwise","nodeMap","indexMap","i","id","degree","values_1","sort","n1","n2","maxValueNode","levels","currentLevel","diff","abs","minDist","firstLvlHasMulti","maxR","min","rStep","r","level","dTheta","dcos","cos","dsin","sin","rMin","sqrt","rDeltaMax_1","rr_1","rDelta","rr","j","theta","base_1","exports"],"sourceRoot":"","sources":["../../src/layout/concentric.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}