{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;\n\nimport { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { IDENTIFIER } from '../../identifier';\nexport var SceneGraphSystem = (_dec = injectable(), _dec2 = inject(IDENTIFIER.HierarchyComponentManager), _dec3 = inject(IDENTIFIER.TransformComponentManager), _dec4 = inject(IDENTIFIER.MeshComponentManager), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {\n  function SceneGraphSystem() {\n    _classCallCheck(this, SceneGraphSystem);\n\n    _initializerDefineProperty(this, \"hierarchy\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"transform\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"mesh\", _descriptor3, this);\n  }\n\n  _createClass(SceneGraphSystem, [{\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.runTransformUpdateSystem();\n                this.runHierarchyUpdateSystem();\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function execute() {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.hierarchy.clear();\n      this.transform.clear();\n    }\n  }, {\n    key: \"getHierarchyComponentManager\",\n    value: function getHierarchyComponentManager() {\n      return this.hierarchy;\n    }\n  }, {\n    key: \"getTransformComponentManager\",\n    value: function getTransformComponentManager() {\n      return this.transform;\n    }\n  }, {\n    key: \"runTransformUpdateSystem\",\n    value: function runTransformUpdateSystem() {\n      var _this = this; // 原版基于 JobSystem 实现\n\n\n      this.transform.forEach(function (entity, transform) {\n        if (transform.isDirty() || transform.isLocalDirty()) {\n          _this.setMeshAABBDirty(_this.mesh.getComponentByEntity(entity));\n\n          transform.updateTransform();\n        }\n      });\n    }\n  }, {\n    key: \"runHierarchyUpdateSystem\",\n    value: function runHierarchyUpdateSystem() {\n      var _this2 = this;\n\n      this.hierarchy.forEach(function (entity, parentComponent) {\n        var transformChild = _this2.transform.getComponentByEntity(entity);\n\n        var transformParent = _this2.transform.getComponentByEntity(parentComponent.parentID);\n\n        if (transformChild !== null && transformParent !== null) {\n          transformChild.updateTransformWithParent(transformParent);\n        }\n      });\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(entity, parent, isChildAlreadyInLocalSpace) {\n      if (this.hierarchy.contains(entity)) {\n        this.detach(entity);\n      }\n\n      this.hierarchy.create(entity, {\n        parentID: parent\n      });\n      var mesh = this.mesh.getComponentByEntity(parent); // inform parent mesh to update its aabb\n\n      this.setMeshAABBDirty(mesh);\n\n      if (mesh && mesh.children.indexOf(entity) === -1) {\n        mesh.children.push(entity);\n      }\n\n      if (this.hierarchy.getCount() > 1) {\n        for (var i = this.hierarchy.getCount() - 1; i > 0; --i) {\n          var parentCandidateEntity = this.hierarchy.getEntity(i); // const parentCandidateComponent = this.hierarchy.getComponent(i);\n\n          for (var j = 0; j < i; ++j) {\n            var childCandidateEntity = this.hierarchy.getComponent(j);\n\n            if (childCandidateEntity.parentID === parentCandidateEntity) {\n              this.hierarchy.moveItem(i, j);\n              ++i; // next outer iteration will check the same index again as parent candidate, however things were moved upwards, so it will be a different entity!\n\n              break;\n            }\n          }\n        }\n      } // Re-query parent after potential MoveItem(), because it invalidates references:\n\n\n      var parentcomponent = this.hierarchy.getComponentByEntity(entity);\n      var transformParent = this.transform.getComponentByEntity(parent);\n\n      if (transformParent === null) {\n        transformParent = this.transform.create(parent);\n      }\n\n      var transformChild = this.transform.getComponentByEntity(entity);\n\n      if (transformChild === null) {\n        transformChild = this.transform.create(entity); // after transforms.Create(), transform_parent pointer could have become invalidated!\n\n        transformParent = this.transform.getComponentByEntity(parent);\n      }\n\n      transformChild.parent = transformParent;\n\n      if (!isChildAlreadyInLocalSpace && transformParent) {\n        transformChild.matrixTransform(mat4.invert(mat4.create(), transformParent.worldTransform));\n        transformChild.updateTransform();\n      }\n\n      if (transformParent) {\n        transformChild.updateTransformWithParent(transformParent);\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach(entity) {\n      var self = this.hierarchy.getComponentByEntity(entity);\n\n      if (self !== null) {\n        var transform = this.transform.getComponentByEntity(entity);\n\n        if (transform !== null) {\n          transform.parent = null;\n          transform.applyTransform();\n        }\n\n        this.hierarchy.removeKeepSorted(entity); // inform parent mesh to update its aabb\n\n        var mesh = this.mesh.getComponentByEntity(self.parentID);\n\n        if (mesh) {\n          var index = mesh.children.indexOf(entity);\n          mesh.children.splice(index, 1);\n        }\n\n        this.setMeshAABBDirty(mesh);\n      }\n    }\n  }, {\n    key: \"detachChildren\",\n    value: function detachChildren(parent) {\n      var mesh = this.mesh.getComponentByEntity(parent);\n\n      if (mesh) {\n        mesh.children = [];\n      }\n\n      for (var i = 0; i < this.hierarchy.getCount();) {\n        var _this$hierarchy$getCo;\n\n        if (((_this$hierarchy$getCo = this.hierarchy.getComponent(i)) === null || _this$hierarchy$getCo === void 0 ? void 0 : _this$hierarchy$getCo.parentID) === parent) {\n          var entity = this.hierarchy.getEntity(i);\n          this.detach(entity);\n        } else {\n          ++i;\n        }\n      }\n    }\n  }, {\n    key: \"setMeshAABBDirty\",\n    value: function setMeshAABBDirty(mesh) {\n      if (mesh) {\n        mesh.aabbDirty = true;\n      }\n    }\n  }]);\n\n  return SceneGraphSystem;\n}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"hierarchy\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"transform\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"mesh\", [_dec4], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":{"version":3,"mappings":"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","names":["mat4","inject","injectable","IDENTIFIER","SceneGraphSystem","HierarchyComponentManager","TransformComponentManager","MeshComponentManager","_classCallCheck","_initializerDefineProperty","_createClass","key","value","runTransformUpdateSystem","runHierarchyUpdateSystem","hierarchy","clear","transform","forEach","entity","isDirty","isLocalDirty","_this","setMeshAABBDirty","mesh","getComponentByEntity","updateTransform","parentComponent","transformChild","_this2","transformParent","parentID","updateTransformWithParent","parent","isChildAlreadyInLocalSpace","contains","detach","create","children","indexOf","push","getCount","i","parentCandidateEntity","getEntity","j","childCandidateEntity","getComponent","moveItem","parentcomponent","matrixTransform","invert","worldTransform","self","applyTransform","removeKeepSorted","index","splice","aabbDirty","configurable","enumerable","writable","initializer"],"sources":["../../../src/components/scenegraph/System.ts"],"sourcesContent":["import { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { Entity, ISystem } from '../..';\nimport { Component } from '../../ComponentManager';\nimport { ComponentManager } from '../../ComponentManager';\nimport { IDENTIFIER } from '../../identifier';\nimport { MeshComponent } from '../mesh/MeshComponent';\nimport { HierarchyComponent } from './HierarchyComponent';\nimport { TransformComponent } from './TransformComponent';\n\n@injectable()\nexport class SceneGraphSystem implements ISystem {\n  @inject(IDENTIFIER.HierarchyComponentManager)\n  private readonly hierarchy: ComponentManager<HierarchyComponent>;\n\n  @inject(IDENTIFIER.TransformComponentManager)\n  private readonly transform: ComponentManager<TransformComponent>;\n\n  @inject(IDENTIFIER.MeshComponentManager)\n  private readonly mesh: ComponentManager<MeshComponent>;\n\n  public async execute() {\n    this.runTransformUpdateSystem();\n    this.runHierarchyUpdateSystem();\n  }\n\n  public tearDown() {\n    this.hierarchy.clear();\n    this.transform.clear();\n  }\n\n  public getHierarchyComponentManager() {\n    return this.hierarchy;\n  }\n\n  public getTransformComponentManager() {\n    return this.transform;\n  }\n\n  public runTransformUpdateSystem() {\n    // 原版基于 JobSystem 实现\n    this.transform.forEach((entity, transform) => {\n      if (transform.isDirty() || transform.isLocalDirty()) {\n        this.setMeshAABBDirty(this.mesh.getComponentByEntity(entity));\n        transform.updateTransform();\n      }\n    });\n  }\n\n  public runHierarchyUpdateSystem() {\n    this.hierarchy.forEach((entity, parentComponent) => {\n      const transformChild = this.transform.getComponentByEntity(entity);\n      const transformParent = this.transform.getComponentByEntity(\n        parentComponent.parentID,\n      );\n      if (transformChild !== null && transformParent !== null) {\n        transformChild.updateTransformWithParent(transformParent);\n      }\n    });\n  }\n\n  public attach(\n    entity: Entity,\n    parent: Entity,\n    isChildAlreadyInLocalSpace?: boolean,\n  ) {\n    if (this.hierarchy.contains(entity)) {\n      this.detach(entity);\n    }\n\n    this.hierarchy.create(entity, {\n      parentID: parent,\n    });\n    const mesh = this.mesh.getComponentByEntity(parent);\n    // inform parent mesh to update its aabb\n    this.setMeshAABBDirty(mesh);\n    if (mesh && mesh.children.indexOf(entity) === -1) {\n      mesh.children.push(entity);\n    }\n\n    if (this.hierarchy.getCount() > 1) {\n      for (let i = this.hierarchy.getCount() - 1; i > 0; --i) {\n        const parentCandidateEntity = this.hierarchy.getEntity(i);\n        // const parentCandidateComponent = this.hierarchy.getComponent(i);\n        for (let j = 0; j < i; ++j) {\n          const childCandidateEntity = this.hierarchy.getComponent(j);\n\n          if (childCandidateEntity.parentID === parentCandidateEntity) {\n            this.hierarchy.moveItem(i, j);\n            ++i; // next outer iteration will check the same index again as parent candidate, however things were moved upwards, so it will be a different entity!\n            break;\n          }\n        }\n      }\n    }\n\n    // Re-query parent after potential MoveItem(), because it invalidates references:\n    const parentcomponent = this.hierarchy.getComponentByEntity(entity);\n\n    let transformParent = this.transform.getComponentByEntity(parent);\n    if (transformParent === null) {\n      transformParent = this.transform.create(parent);\n    }\n\n    let transformChild = this.transform.getComponentByEntity(entity);\n    if (transformChild === null) {\n      transformChild = this.transform.create(entity);\n      // after transforms.Create(), transform_parent pointer could have become invalidated!\n      transformParent = this.transform.getComponentByEntity(parent);\n    }\n\n    transformChild.parent = transformParent;\n\n    if (!isChildAlreadyInLocalSpace && transformParent) {\n      transformChild.matrixTransform(\n        mat4.invert(mat4.create(), transformParent.worldTransform),\n      );\n      transformChild.updateTransform();\n    }\n    if (transformParent) {\n      transformChild.updateTransformWithParent(transformParent);\n    }\n  }\n\n  public detach(entity: Entity) {\n    const self = this.hierarchy.getComponentByEntity(entity);\n    if (self !== null) {\n      const transform = this.transform.getComponentByEntity(entity);\n      if (transform !== null) {\n        transform.parent = null;\n        transform.applyTransform();\n      }\n\n      this.hierarchy.removeKeepSorted(entity);\n\n      // inform parent mesh to update its aabb\n      const mesh = this.mesh.getComponentByEntity(self.parentID);\n      if (mesh) {\n        const index = mesh.children.indexOf(entity);\n        mesh.children.splice(index, 1);\n      }\n      this.setMeshAABBDirty(mesh);\n    }\n  }\n\n  public detachChildren(parent: Entity) {\n    const mesh = this.mesh.getComponentByEntity(parent);\n    if (mesh) {\n      mesh.children = [];\n    }\n    for (let i = 0; i < this.hierarchy.getCount(); ) {\n      if (this.hierarchy.getComponent(i)?.parentID === parent) {\n        const entity = this.hierarchy.getEntity(i);\n        this.detach(entity);\n      } else {\n        ++i;\n      }\n    }\n  }\n\n  private setMeshAABBDirty(\n    mesh: (Component<MeshComponent> & MeshComponent) | null,\n  ) {\n    if (mesh) {\n      mesh.aabbDirty = true;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}