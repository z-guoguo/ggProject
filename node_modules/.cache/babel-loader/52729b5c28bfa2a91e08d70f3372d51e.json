{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nvar _dec, _class;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AABB } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nimport { isNumber } from '../utils/is-number';\nimport { isTypedArray } from '../utils/is-typedarray';\nimport { merge } from '../utils/typedarray';\nexport var\n/**\n * merge many geometries into one, use a batch of draw calls\n */\nMerged = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_Geometry) {\n  _inherits(Merged, _Geometry);\n\n  var _super = _createSuper(Merged);\n\n  function Merged() {\n    _classCallCheck(this, Merged);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Merged, [{\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      var _this$config$geometri = this.config.geometries,\n          geometries = _this$config$geometri === void 0 ? [] : _this$config$geometri;\n      var mergedComponent = this.getComponent();\n      mergedComponent.aabb = new AABB();\n      var mergedAttributes = [];\n      var mergedIndices = [];\n      var indexOffset = 0;\n      geometries.forEach(function (geometry) {\n        var aabb = geometry.aabb,\n            indices = geometry.indices,\n            vertexCount = geometry.vertexCount,\n            attributes = geometry.attributes; // merge aabb\n\n        mergedComponent.aabb.add(aabb);\n        mergedComponent.vertexCount += vertexCount; // merge indices\n\n        if (indices) {\n          mergedIndices.push.apply(mergedIndices, _toConsumableArray(indices.map(function (index) {\n            return index + indexOffset;\n          })));\n        }\n\n        indexOffset += vertexCount; // merge attributes\n\n        attributes.forEach(function (attribute, i) {\n          if (!mergedAttributes[i]) {\n            mergedAttributes[i] = attribute;\n            mergedAttributes[i].dirty = true;\n          } else {\n            if (attribute.data) {\n              if (isNumber(attribute.data)) {\n                // @ts-ignore\n                mergedAttributes[i].push(attribute.data);\n              } else if (isTypedArray(attribute.data)) {\n                // @ts-ignore\n                mergedAttributes[i].data = merge( // @ts-ignore\n                mergedAttributes[i].data, attribute.data);\n              } else {\n                // @ts-ignore\n                mergedAttributes[i].data = mergedAttributes[i].data.concat(attribute.data);\n              }\n            }\n          }\n        });\n      });\n      mergedComponent.attributes = mergedAttributes;\n      mergedComponent.indices = Uint32Array.from(mergedIndices);\n      mergedComponent.dirty = true;\n    }\n  }]);\n\n  return Merged;\n}(Geometry)) || _class);","map":{"version":3,"mappings":"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","names":["AABB","injectable","Geometry","isNumber","isTypedArray","merge","Merged","_inherits","_classCallCheck","_createClass","key","value","config","geometries","mergedComponent","getComponent","aabb","mergedAttributes","mergedIndices","indexOffset","forEach","geometry","indices","vertexCount","attributes","add","push","_toConsumableArray","map","index","attribute","i","dirty","data","concat","Uint32Array","from"],"sources":["../../src/geometry/Merged.ts"],"sourcesContent":["import { AABB, GeometryComponent } from '@antv/g-webgpu-core';\nimport { injectable } from 'inversify';\nimport { Geometry } from '.';\nimport { isNumber } from '../utils/is-number';\nimport { isTypedArray } from '../utils/is-typedarray';\nimport { merge } from '../utils/typedarray';\n\nexport interface IMergedGeometryParams {\n  geometries: GeometryComponent[];\n}\n\n@injectable()\n/**\n * merge many geometries into one, use a batch of draw calls\n */\nexport class Merged extends Geometry<Partial<IMergedGeometryParams>> {\n  protected onEntityCreated() {\n    const { geometries = [] } = this.config;\n\n    const mergedComponent = this.getComponent();\n    mergedComponent.aabb = new AABB();\n\n    const mergedAttributes: GeometryComponent['attributes'] = [];\n    const mergedIndices: number[] = [];\n    let indexOffset = 0;\n    geometries.forEach((geometry) => {\n      const { aabb, indices, vertexCount, attributes } = geometry;\n\n      // merge aabb\n      mergedComponent.aabb.add(aabb);\n      mergedComponent.vertexCount += vertexCount;\n\n      // merge indices\n      if (indices) {\n        mergedIndices.push(...indices.map((index) => index + indexOffset));\n      }\n      indexOffset += vertexCount;\n\n      // merge attributes\n      attributes.forEach((attribute, i) => {\n        if (!mergedAttributes[i]) {\n          mergedAttributes[i] = attribute;\n          mergedAttributes[i].dirty = true;\n        } else {\n          if (attribute.data) {\n            if (isNumber(attribute.data)) {\n              // @ts-ignore\n              mergedAttributes[i].push(attribute.data);\n            } else if (isTypedArray(attribute.data)) {\n              // @ts-ignore\n              mergedAttributes[i].data = merge(\n                // @ts-ignore\n                mergedAttributes[i].data,\n                attribute.data,\n              );\n            } else {\n              // @ts-ignore\n              mergedAttributes[i].data = mergedAttributes[i].data.concat(\n                attribute.data,\n              );\n            }\n          }\n        }\n      });\n    });\n\n    mergedComponent.attributes = mergedAttributes;\n    mergedComponent.indices = Uint32Array.from(mergedIndices);\n    mergedComponent.dirty = true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}