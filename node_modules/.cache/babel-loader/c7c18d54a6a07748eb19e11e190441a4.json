{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _class3, _temp;\n\nimport { inject, injectable } from 'inversify';\nimport { IDENTIFIER } from '../../../identifier';\n/* babel-plugin-inline-import '../../../services/shader-module/shaders/webgl.copy.frag.glsl' */\n\nvar copyFrag = \"varying vec2 v_UV;\\n\\nuniform sampler2D u_Texture;\\n\\nvoid main() {\\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\\n}\";\n/* babel-plugin-inline-import '../../../services/shader-module/shaders/webgl.copy.vert.glsl' */\n\nvar copyVert = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\n/* babel-plugin-inline-import '../../../services/shader-module/shaders/webgpu.copy.frag.glsl' */\n\nvar copyFragWebGPU = \"layout(set = 0, binding = 0) uniform sampler u_TextureSampler;\\nlayout(set = 0, binding = 1) uniform texture2D u_Texture;\\n\\nlayout(location = 0) in vec2 v_UV;\\nlayout(location = 0) out vec4 outColor;\\n\\nvoid main() {\\n  outColor = texture(sampler2D(u_Texture, u_TextureSampler), v_UV);\\n}\";\n/* babel-plugin-inline-import '../../../services/shader-module/shaders/webgpu.copy.vert.glsl' */\n\nvar copyVertWebGPU = \"layout(location = 0) in vec2 a_Position;\\nlayout(location = 0) out vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport { gl } from '../gl';\nimport { RenderPass } from './RenderPass';\nexport var CopyPass = (_dec = injectable(), _dec2 = inject(IDENTIFIER.RenderEngine), _dec3 = inject(IDENTIFIER.ResourcePool), _dec(_class = (_class2 = (_temp = _class3 = function CopyPass() {\n  var _this = this;\n\n  _classCallCheck(this, CopyPass);\n\n  _initializerDefineProperty(this, \"engine\", _descriptor, this);\n\n  _initializerDefineProperty(this, \"resourcePool\", _descriptor2, this);\n\n  this.model = void 0;\n\n  this.setup = function (fg, passNode, pass) {\n    var renderPass = fg.getPass(RenderPass.IDENTIFIER);\n\n    if (renderPass) {\n      var output = fg.createRenderTarget(passNode, 'render to screen', {\n        width: 1,\n        height: 1\n      });\n      pass.data = {\n        input: passNode.read(renderPass.data.output),\n        output: passNode.write(fg, output)\n      };\n    }\n  };\n\n  this.execute = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fg, pass) {\n      var _this$engine, createModel, createAttribute, createBuffer, model, resourceNode, framebuffer;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this$engine = _this.engine, createModel = _this$engine.createModel, createAttribute = _this$engine.createAttribute, createBuffer = _this$engine.createBuffer;\n\n              if (_this.model) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 4;\n              return createModel({\n                vs: _this.engine.supportWebGPU ? copyVertWebGPU : copyVert,\n                fs: _this.engine.supportWebGPU ? copyFragWebGPU : copyFrag,\n                attributes: {\n                  // rendering a fullscreen triangle instead of quad\n                  // @see https://www.saschawillems.de/blog/2016/08/13/vulkan-tutorial-on-rendering-a-fullscreen-quad-without-buffers/\n                  a_Position: createAttribute({\n                    buffer: createBuffer({\n                      data: [-4, -4, 4, -4, 0, 4],\n                      type: gl.FLOAT\n                    }),\n                    size: 2,\n                    arrayStride: 2 * 4,\n                    stepMode: 'vertex',\n                    attributes: [{\n                      shaderLocation: 0,\n                      offset: 0,\n                      format: 'float2'\n                    }]\n                  })\n                },\n                uniforms: {\n                  // @ts-ignore\n                  u_Texture: null\n                },\n                depth: {\n                  enable: false\n                },\n                count: 3,\n                blend: {\n                  // copy pass 需要混合\n                  // enable: this.getName() === 'copy',\n                  enable: true\n                }\n              });\n\n            case 4:\n              model = _context.sent;\n              _this.model = model;\n\n            case 6:\n              // 实例化资源\n              resourceNode = fg.getResourceNode(pass.data.input);\n              framebuffer = _this.resourcePool.getOrCreateResource(resourceNode.resource);\n\n              _this.engine.useFramebuffer(null, function () {\n                _this.engine.clear({\n                  framebuffer: null,\n                  color: [0, 0, 0, 0],\n                  depth: 1,\n                  stencil: 0\n                });\n\n                _this.model.draw({\n                  uniforms: {\n                    u_Texture: framebuffer // u_ViewportSize: [width, height],\n\n                  }\n                });\n              });\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  this.tearDown = function () {\n    _this.model = undefined;\n  };\n}, _class3.IDENTIFIER = 'Copy Pass', _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"engine\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"resourcePool\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":{"version":3,"mappings":"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","names":["inject","injectable","IDENTIFIER","gl","RenderPass","CopyPass","RenderEngine","ResourcePool","_classCallCheck","_initializerDefineProperty","model","setup","fg","passNode","pass","renderPass","getPass","output","createRenderTarget","width","height","data","input","read","write","execute","_this$engine","_this","engine","createModel","createAttribute","createBuffer","_context","vs","supportWebGPU","copyVertWebGPU","copyVert","fs","copyFragWebGPU","copyFrag","attributes","a_Position","buffer","type","FLOAT","size","arrayStride","stepMode","shaderLocation","offset","format","uniforms","u_Texture","depth","enable","count","blend","resourceNode","getResourceNode","framebuffer","resourcePool","getOrCreateResource","resource","useFramebuffer","clear","color","stencil","draw","tearDown","undefined","configurable","enumerable","writable","initializer"],"sources":["../../../../src/components/renderer/passes/CopyPass.ts"],"sourcesContent":["import { inject, injectable } from 'inversify';\nimport { IDENTIFIER } from '../../../identifier';\nimport copyFrag from '../../../services/shader-module/shaders/webgl.copy.frag.glsl';\nimport copyVert from '../../../services/shader-module/shaders/webgl.copy.vert.glsl';\nimport copyFragWebGPU from '../../../services/shader-module/shaders/webgpu.copy.frag.glsl';\nimport copyVertWebGPU from '../../../services/shader-module/shaders/webgpu.copy.vert.glsl';\nimport { FrameGraphHandle } from '../../framegraph/FrameGraphHandle';\nimport { FrameGraphPass } from '../../framegraph/FrameGraphPass';\nimport { PassNode } from '../../framegraph/PassNode';\nimport { ResourcePool } from '../../framegraph/ResourcePool';\nimport { FrameGraphSystem } from '../../framegraph/System';\nimport { gl } from '../gl';\nimport { IModel } from '../IModel';\nimport { IRendererService } from '../IRendererService';\nimport { IRenderPass } from './IRenderPass';\nimport { RenderPass, RenderPassData } from './RenderPass';\n\nexport interface CopyPassData {\n  input: FrameGraphHandle;\n  output: FrameGraphHandle;\n}\n\n@injectable()\nexport class CopyPass implements IRenderPass<CopyPassData> {\n  public static IDENTIFIER = 'Copy Pass';\n\n  @inject(IDENTIFIER.RenderEngine)\n  private readonly engine: IRendererService;\n\n  @inject(IDENTIFIER.ResourcePool)\n  private readonly resourcePool: ResourcePool;\n\n  private model: IModel | undefined;\n\n  public setup = (\n    fg: FrameGraphSystem,\n    passNode: PassNode,\n    pass: FrameGraphPass<CopyPassData>,\n  ): void => {\n    const renderPass = fg.getPass<RenderPassData>(RenderPass.IDENTIFIER);\n    if (renderPass) {\n      const output = fg.createRenderTarget(passNode, 'render to screen', {\n        width: 1,\n        height: 1,\n      });\n\n      pass.data = {\n        input: passNode.read(renderPass.data.output),\n        output: passNode.write(fg, output),\n      };\n    }\n  };\n\n  public execute = async (\n    fg: FrameGraphSystem,\n    pass: FrameGraphPass<CopyPassData>,\n  ): Promise<void> => {\n    const { createModel, createAttribute, createBuffer } = this.engine;\n\n    if (!this.model) {\n      const model = await createModel({\n        vs: this.engine.supportWebGPU ? copyVertWebGPU : copyVert,\n        fs: this.engine.supportWebGPU ? copyFragWebGPU : copyFrag,\n        attributes: {\n          // rendering a fullscreen triangle instead of quad\n          // @see https://www.saschawillems.de/blog/2016/08/13/vulkan-tutorial-on-rendering-a-fullscreen-quad-without-buffers/\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-4, -4, 4, -4, 0, 4],\n              type: gl.FLOAT,\n            }),\n            size: 2,\n            arrayStride: 2 * 4,\n            stepMode: 'vertex',\n            attributes: [\n              {\n                shaderLocation: 0,\n                offset: 0,\n                format: 'float2',\n              },\n            ],\n          }),\n        },\n        uniforms: {\n          // @ts-ignore\n          u_Texture: null,\n        },\n        depth: {\n          enable: false,\n        },\n        count: 3,\n        blend: {\n          // copy pass 需要混合\n          // enable: this.getName() === 'copy',\n          enable: true,\n        },\n      });\n      this.model = model;\n    }\n\n    // 实例化资源\n    const resourceNode = fg.getResourceNode(pass.data.input);\n    const framebuffer = this.resourcePool.getOrCreateResource(\n      resourceNode.resource,\n    );\n\n    this.engine.useFramebuffer(null, () => {\n      this.engine.clear({\n        framebuffer: null,\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n      });\n      this.model!.draw({\n        uniforms: {\n          u_Texture: framebuffer,\n          // u_ViewportSize: [width, height],\n        },\n      });\n    });\n  };\n\n  public tearDown = () => {\n    this.model = undefined;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}