{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { mat3, vec3, vec4 } from 'gl-matrix';\nimport { Component } from '../../ComponentManager';\nimport { isTypedArray } from '../../utils/is-typedarray';\nexport var GeometryComponent = /*#__PURE__*/function (_Component) {\n  _inherits(GeometryComponent, _Component);\n\n  var _super = _createSuper(GeometryComponent); // instanced count\n\n\n  function GeometryComponent(data) {\n    var _this;\n\n    _classCallCheck(this, GeometryComponent);\n\n    _this = _super.call(this, data);\n    _this.dirty = true;\n    _this.attributes = [];\n    _this.indices = void 0;\n    _this.indicesBuffer = void 0;\n    _this.vertexCount = 0;\n    _this.maxInstancedCount = void 0;\n    _this.aabb = void 0;\n    _this.entity = void 0;\n    Object.assign(_assertThisInitialized(_this), data);\n    return _this;\n  }\n  /**\n   * @see https://threejs.org/docs/#api/en/core/BufferAttribute\n   */\n\n\n  _createClass(GeometryComponent, [{\n    key: \"setAttribute\",\n    value: function setAttribute(name, data, descriptor, bufferGetter) {\n      var existed = this.attributes.find(function (a) {\n        return a.name === name;\n      });\n\n      if (!existed) {\n        this.attributes.push(_objectSpread(_objectSpread({\n          dirty: true,\n          name: name,\n          data: data\n        }, descriptor), {}, {\n          bufferGetter: bufferGetter\n        }));\n      } else {\n        existed.data = data;\n        existed.dirty = true;\n      }\n\n      this.dirty = true;\n      return this;\n    }\n  }, {\n    key: \"setIndex\",\n    value: function setIndex(data) {\n      this.indices = new Uint32Array( // @ts-ignore\n      data.buffer ? data.buffer : data);\n      this.dirty = true;\n      return this;\n    }\n    /**\n     * when merge all the geometries into one, we need to transform every vertex's position\n     * and every face's normal\n     */\n\n  }, {\n    key: \"applyMatrix\",\n    value: function applyMatrix(matrix) {\n      var positionAttribute = this.attributes.find(function (_ref) {\n        var name = _ref.name;\n        return name === 'position';\n      });\n      var normalAttribute = this.attributes.find(function (_ref2) {\n        var name = _ref2.name;\n        return name === 'normal';\n      });\n\n      if (positionAttribute) {\n        positionAttribute.dirty = true; // @ts-ignore\n\n        if (positionAttribute.data && positionAttribute.data.length) {\n          // @ts-ignore\n          for (var i = 0; i < positionAttribute.data.length; i += 3) {\n            var position = vec4.fromValues( // @ts-ignore\n            positionAttribute.data[i], // @ts-ignore\n            positionAttribute.data[i + 1], // @ts-ignore\n            positionAttribute.data[i + 2], 1);\n            vec4.transformMat4(position, position, matrix);\n\n            if (isTypedArray(positionAttribute.data)) {\n              // @ts-ignore\n              positionAttribute.data.set([position[0], position[1], position[2]], i);\n            } else {\n              // @ts-ignore\n              positionAttribute.data[i] = position[0]; // @ts-ignore\n\n              positionAttribute.data[i + 1] = position[1]; // @ts-ignore\n\n              positionAttribute.data[i + 2] = position[2];\n            }\n          }\n        }\n      }\n\n      if (normalAttribute) {\n        var normalMatrix = mat3.normalFromMat4(mat3.create(), matrix); // @ts-ignore\n\n        if (normalAttribute.data && normalAttribute.data.length) {\n          // @ts-ignore\n          for (var _i = 0; _i < normalAttribute.data.length; _i += 3) {\n            var normal = vec3.fromValues( // @ts-ignore\n            normalAttribute.data[_i], // @ts-ignore\n            normalAttribute.data[_i + 1], // @ts-ignore\n            normalAttribute.data[_i + 2]);\n            vec3.transformMat3(normal, normal, normalMatrix);\n            vec3.normalize(normal, normal);\n\n            if (isTypedArray(normalAttribute.data)) {\n              // @ts-ignore\n              normalAttribute.data.set([normal[0], normal[1], normal[2]], _i);\n            } else {\n              // @ts-ignore\n              normalAttribute.data[_i] = normal[0]; // @ts-ignore\n\n              normalAttribute.data[_i + 1] = normal[1]; // @ts-ignore\n\n              normalAttribute.data[_i + 2] = normal[2];\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return GeometryComponent;\n}(Component);","map":{"version":3,"mappings":"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","names":["mat3","vec3","vec4","Component","isTypedArray","GeometryComponent","_inherits","data","_classCallCheck","_this","dirty","attributes","indices","indicesBuffer","vertexCount","maxInstancedCount","aabb","entity","Object","assign","_createClass","key","value","name","descriptor","bufferGetter","existed","find","a","push","Uint32Array","buffer","matrix","positionAttribute","normalAttribute","length","i","position","fromValues","transformMat4","set","normalMatrix","normalFromMat4","create","normal","transformMat3","normalize"],"sources":["../../../src/components/geometry/GeometryComponent.ts"],"sourcesContent":["import { mat3, mat4, vec3, vec4 } from 'gl-matrix';\nimport { Entity } from '../..';\nimport { Component } from '../../ComponentManager';\nimport { NonFunctionProperties } from '../../ComponentManager';\nimport { AABB } from '../../shape/AABB';\nimport { isTypedArray } from '../../utils/is-typedarray';\nimport { IBuffer } from '../renderer/IBuffer';\nimport { IElements } from '../renderer/IElements';\nimport { BufferData } from '../renderer/IRendererService';\n\nexport class GeometryComponent extends Component<GeometryComponent> {\n  public dirty: boolean = true;\n\n  public attributes: Array<\n    {\n      dirty: boolean;\n      name: string;\n      data?: BufferData;\n      buffer?: IBuffer;\n      // 结合 Compute Pipeline 时，需要在运行时获取 PingPong buffer\n      bufferGetter?: () => IBuffer;\n    } & GPUVertexBufferLayoutDescriptor\n  > = [];\n\n  public indices: Uint32Array | null;\n  public indicesBuffer: IElements | null;\n\n  public vertexCount: number = 0;\n\n  // instanced count\n  public maxInstancedCount: number;\n\n  public aabb: AABB;\n\n  public entity: Entity;\n\n  constructor(data: Partial<NonFunctionProperties<GeometryComponent>>) {\n    super(data);\n\n    Object.assign(this, data);\n  }\n\n  /**\n   * @see https://threejs.org/docs/#api/en/core/BufferAttribute\n   */\n  public setAttribute(\n    name: string,\n    data: BufferData,\n    descriptor: GPUVertexBufferLayoutDescriptor,\n    bufferGetter?: () => IBuffer,\n  ) {\n    const existed = this.attributes.find((a) => a.name === name);\n    if (!existed) {\n      this.attributes.push({\n        dirty: true,\n        name,\n        data,\n        ...descriptor,\n        bufferGetter,\n      });\n    } else {\n      existed.data = data;\n      existed.dirty = true;\n    }\n    this.dirty = true;\n    return this;\n  }\n\n  public setIndex(data: number[] | Uint8Array | Uint16Array | Uint32Array) {\n    this.indices = new Uint32Array(\n      // @ts-ignore\n      data.buffer ? data.buffer : (data as number[]),\n    );\n    this.dirty = true;\n    return this;\n  }\n\n  /**\n   * when merge all the geometries into one, we need to transform every vertex's position\n   * and every face's normal\n   */\n  public applyMatrix(matrix: mat4) {\n    const positionAttribute = this.attributes.find(\n      ({ name }) => name === 'position',\n    );\n    const normalAttribute = this.attributes.find(\n      ({ name }) => name === 'normal',\n    );\n\n    if (positionAttribute) {\n      positionAttribute.dirty = true;\n\n      // @ts-ignore\n      if (positionAttribute.data && positionAttribute.data.length) {\n        // @ts-ignore\n        for (let i = 0; i < positionAttribute.data.length; i += 3) {\n          const position = vec4.fromValues(\n            // @ts-ignore\n            positionAttribute.data[i] as number,\n            // @ts-ignore\n            positionAttribute.data[i + 1] as number,\n            // @ts-ignore\n            positionAttribute.data[i + 2] as number,\n            1,\n          );\n          vec4.transformMat4(position, position, matrix);\n          if (isTypedArray(positionAttribute.data)) {\n            // @ts-ignore\n            positionAttribute.data.set(\n              [position[0], position[1], position[2]],\n              i,\n            );\n          } else {\n            // @ts-ignore\n            positionAttribute.data[i] = position[0];\n            // @ts-ignore\n            positionAttribute.data[i + 1] = position[1];\n            // @ts-ignore\n            positionAttribute.data[i + 2] = position[2];\n          }\n        }\n      }\n    }\n\n    if (normalAttribute) {\n      const normalMatrix = mat3.normalFromMat4(mat3.create(), matrix);\n      // @ts-ignore\n      if (normalAttribute.data && normalAttribute.data.length) {\n        // @ts-ignore\n        for (let i = 0; i < normalAttribute.data.length; i += 3) {\n          const normal = vec3.fromValues(\n            // @ts-ignore\n            normalAttribute.data[i] as number,\n            // @ts-ignore\n            normalAttribute.data[i + 1] as number,\n            // @ts-ignore\n            normalAttribute.data[i + 2] as number,\n          );\n          vec3.transformMat3(normal, normal, normalMatrix);\n          vec3.normalize(normal, normal);\n          if (isTypedArray(normalAttribute.data)) {\n            // @ts-ignore\n            normalAttribute.data.set([normal[0], normal[1], normal[2]], i);\n          } else {\n            // @ts-ignore\n            normalAttribute.data[i] = normal[0];\n            // @ts-ignore\n            normalAttribute.data[i + 1] = normal[1];\n            // @ts-ignore\n            normalAttribute.data[i + 2] = normal[2];\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}