{"ast":null,"code":"import { isString, isNumber, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return \"\".concat(type, \"-\").concat(Math.random()).concat(Date.now());\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\n\nexport var formatPadding = function formatPadding(padding) {\n  if (isArray(padding)) {\n    switch (padding.length) {\n      case 4:\n        return padding;\n\n      case 3:\n        padding.push(padding[1]);\n        return padding;\n\n      case 2:\n        return padding.concat(padding);\n\n      case 1:\n        return [padding[0], padding[0], padding[0], padding[0]];\n\n      default:\n        return [0, 0, 0, 0];\n    }\n  }\n\n  if (isNumber(padding)) {\n    return [padding, padding, padding, padding];\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    return [intPadding, intPadding, intPadding, intPadding];\n  }\n\n  return [0, 0, 0, 0];\n};\n/**\n * clone event\n * @param e\n */\n\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\n\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\n\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxX = bbox.maxX,\n        maxY = bbox.maxY;\n\n    if (minX < minx) {\n      minx = minX;\n    }\n\n    if (minY < miny) {\n      miny = minY;\n    }\n\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.vision/en/docs/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\n\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n        target = edge.target;\n    var sourceTarget = \"\".concat(source, \"-\").concat(target);\n    if (tags[i]) continue;\n\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target; // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[\"\".concat(src, \"|\").concat(dst, \"|\").concat(edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[\"\".concat(current.source, \"|\").concat(current.target, \"|\").concat(k)] ? -1 : 1);\n\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n\n  return edges;\n};","map":{"version":3,"names":["isString","isNumber","isArray","G6GraphEvent","uniqueId","type","concat","Math","random","Date","now","formatPadding","padding","length","push","intPadding","parseInt","cloneEvent","e","event","clientX","clientY","x","y","target","currentTarget","bubbles","item","isViewportChanged","matrix","MATRIX_LEN","ORIGIN_MATRIX","i","isNaN","input","Number","calculationItemsBBox","items","minx","Infinity","maxx","miny","maxy","element","bbox","getBBox","minX","minY","maxX","maxY","floor","width","ceil","height","processParallelEdges","edges","offsetDiff","multiEdgeType","singleEdgeType","loopEdgeType","undefined","len","cod","loopPosition","edgeMap","tags","reverses","edge","source","sourceTarget","j","sedge","src","dst","key","arcEdges","length_1","k","current","loopCfg","position","dist","sign","curveOffset"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/g6-core/es/util/base.js"],"sourcesContent":["import { isString, isNumber, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return \"\".concat(type, \"-\").concat(Math.random()).concat(Date.now());\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\n\nexport var formatPadding = function formatPadding(padding) {\n  if (isArray(padding)) {\n    switch (padding.length) {\n      case 4:\n        return padding;\n\n      case 3:\n        padding.push(padding[1]);\n        return padding;\n\n      case 2:\n        return padding.concat(padding);\n\n      case 1:\n        return [padding[0], padding[0], padding[0], padding[0]];\n\n      default:\n        return [0, 0, 0, 0];\n    }\n  }\n\n  if (isNumber(padding)) {\n    return [padding, padding, padding, padding];\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    return [intPadding, intPadding, intPadding, intPadding];\n  }\n\n  return [0, 0, 0, 0];\n};\n/**\n * clone event\n * @param e\n */\n\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\n\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\n\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxX = bbox.maxX,\n        maxY = bbox.maxY;\n\n    if (minX < minx) {\n      minx = minX;\n    }\n\n    if (minY < miny) {\n      miny = minY;\n    }\n\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.vision/en/docs/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\n\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n        target = edge.target;\n    var sourceTarget = \"\".concat(source, \"-\").concat(target);\n    if (tags[i]) continue;\n\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target; // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[\"\".concat(src, \"|\").concat(dst, \"|\").concat(edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[\"\".concat(current.source, \"|\").concat(current.target, \"|\").concat(k)] ? -1 : 1);\n\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n\n  return edges;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}