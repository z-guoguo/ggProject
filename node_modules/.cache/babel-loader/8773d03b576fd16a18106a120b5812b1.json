{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _util2 = require(\"./util\");\n\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n};\n\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\n\n  var paths = {};\n\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  } // 兼容之前单路径\n\n\n  var path = {};\n\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\n\nvar _default = dijkstra;\nexports.default = _default;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n\n  var paths = [];\n\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath, true), [target], false));else paths.push([prePath, target]);\n    }\n  }\n\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_tslib","require","_util","_util2","minVertex","D","nodes","marks","minDis","Infinity","minNode","i","length","nodeId","id","dijkstra","graphData","source","directed","weightPropertyName","_a","_b","edges","nodeIds","prevs","forEach","node","push","nodeNum","_loop_1","minNodeId","relatedEdges","getOutEdgesNodeId","getEdgesByNodeId","edge","edgeTarget","target","edgeSource","w","weight","paths","findAllPaths","path","allPath","_default","foundPaths","_i","prev","prevPaths","prevPaths_1","prePath","isArray","__spreadArray"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/lib/dijkstra.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _util2 = require(\"./util\");\n\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n};\n\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\n\n  var paths = {};\n\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  } // 兼容之前单路径\n\n\n  var path = {};\n\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\n\nvar _default = dijkstra;\nexports.default = _default;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n\n  var paths = [];\n\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath, true), [target], false));else paths.push([prePath, target]);\n    }\n  }\n\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}