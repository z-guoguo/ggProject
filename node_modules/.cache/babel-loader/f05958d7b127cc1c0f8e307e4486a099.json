{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nimport { Util } from '@antv/g6-core';\nimport { isNumber } from '@antv/util';\nvar traverseTree = Util.traverseTree;\n/**\n * 将 number | Function 类型的参数转换为 return number 的 Function\n * @param  {number | Function}  value 需要被转换的值\n * @param  {number}  defaultV 返回函数的默认返回值\n * @return {Function} 转换后的函数\n */\n\nexport var proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n\n  return func;\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 需要被转换的值\n * @param  {EdgeConfig[]}  edges 返回函数的默认返回值\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureData = function buildTextureData(nodes, edges) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i];\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr(nodes, edges, attrs) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = len / 2; // 第四位存储与该节点相关的所有节点个数\n\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  } // 不是 4 的倍数，填充 0\n\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个以上属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr(nodes, edges, attrs1, attrs2) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs1(e));\n    nodeDict[mapIdPos[e.source]].push(attrs2(e));\n    nodeDict[mapIdPos[e.source]].push(0);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs1(e));\n    nodeDict[mapIdPos[e.target]].push(attrs2(e));\n    nodeDict[mapIdPos[e.target]].push(0);\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n\n    var len = dests.length; // dataArray[i * 4 + 2] = offset;\n    // dataArray[i * 4 + 3] = len / 4; // 第四位存储与该节点相关的所有节点个数\n    // pack offset & length into float32: offset 20bit, length 12bit\n\n    dataArray[i * 4 + 2] = offset + 1048576 * len / 4;\n    dataArray[i * 4 + 3] = 0; // 第四位存储与上一次的距离差值\n\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  } // 不是 4 的倍数，填充 0\n\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * transform the extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @param  {ModelConfig[]}  items the items to be read\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\n\nexport var attributesToTextureData = function attributesToTextureData(attributeNames, items) {\n  var dataArray = [];\n  var attributeNum = attributeNames.length;\n  var attributteStringMap = {};\n  items.forEach(function (item) {\n    attributeNames.forEach(function (name, i) {\n      if (attributteStringMap[item[name]] === undefined) {\n        attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;\n      }\n\n      dataArray.push(attributteStringMap[item[name]]); // insure each node's attributes take inter number of grids\n\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  });\n  return {\n    array: new Float32Array(dataArray),\n    count: Object.keys(attributteStringMap).length\n  };\n};\n/**\n * transform the number array format of extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\n\nexport var arrayToTextureData = function arrayToTextureData(valueArrays) {\n  var dataArray = [];\n  var attributeNum = valueArrays.length;\n  var itemNum = valueArrays[0].length;\n\n  var _loop_1 = function _loop_1(j) {\n    valueArrays.forEach(function (valueArray, i) {\n      dataArray.push(valueArray[j]); // insure each node's attributes take inter number of grids\n\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  };\n\n  for (var j = 0; j < itemNum; j++) {\n    _loop_1(j);\n  }\n\n  return new Float32Array(dataArray);\n};\n/**\n *\n * @param data Tree graph data\n * @param layout\n */\n\nexport var radialLayout = function radialLayout(data, layout) {\n  // 布局方式有 H / V / LR / RL / TB / BT\n  var VERTICAL_LAYOUTS = ['V', 'TB', 'BT'];\n  var min = {\n    x: Infinity,\n    y: Infinity\n  };\n  var max = {\n    x: -Infinity,\n    y: -Infinity\n  }; // 默认布局是垂直布局TB，此时x对应rad，y对应r\n\n  var rScale = 'x';\n  var radScale = 'y';\n\n  if (layout && VERTICAL_LAYOUTS.indexOf(layout) >= 0) {\n    // 若是水平布局，y对应rad，x对应r\n    radScale = 'x';\n    rScale = 'y';\n  }\n\n  var count = 0;\n  traverseTree(data, function (node) {\n    count++;\n\n    if (node.x > max.x) {\n      max.x = node.x;\n    }\n\n    if (node.x < min.x) {\n      min.x = node.x;\n    }\n\n    if (node.y > max.y) {\n      max.y = node.y;\n    }\n\n    if (node.y < min.y) {\n      min.y = node.y;\n    }\n\n    return true;\n  });\n  var avgRad = Math.PI * 2 / count;\n  var radDiff = max[radScale] - min[radScale];\n\n  if (radDiff === 0) {\n    return data;\n  }\n\n  traverseTree(data, function (node) {\n    var radial = (node[radScale] - min[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;\n    var r = Math.abs(rScale === 'x' ? node.x - data.x : node.y - data.y);\n    node.x = r * Math.cos(radial);\n    node.y = r * Math.sin(radial);\n    return true;\n  });\n  return data;\n};","map":{"version":3,"names":["Util","isNumber","traverseTree","proccessToFunc","value","defaultV","func","d","buildTextureData","nodes","edges","dataArray","nodeDict","mapIdPos","i","length","n","id","push","x","y","e","source","target","maxEdgePerVetex","offset","dests","len","Math","max","j","dest","array","Float32Array","buildTextureDataWithOneEdgeAttr","attrs","buildTextureDataWithTwoEdgeAttr","attrs1","attrs2","attributesToTextureData","attributeNames","items","attributeNum","attributteStringMap","forEach","item","name","undefined","Object","keys","count","arrayToTextureData","valueArrays","itemNum","_loop_1","valueArray","radialLayout","data","layout","VERTICAL_LAYOUTS","min","Infinity","rScale","radScale","indexOf","node","avgRad","PI","radDiff","radial","r","abs","cos","sin"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/g6-pc/es/util/layout.js"],"sourcesContent":["import { Util } from '@antv/g6-core';\nimport { isNumber } from '@antv/util';\nvar traverseTree = Util.traverseTree;\n/**\n * 将 number | Function 类型的参数转换为 return number 的 Function\n * @param  {number | Function}  value 需要被转换的值\n * @param  {number}  defaultV 返回函数的默认返回值\n * @return {Function} 转换后的函数\n */\n\nexport var proccessToFunc = function proccessToFunc(value, defaultV) {\n  var func;\n\n  if (!value) {\n    func = function func(d) {\n      return defaultV || 1;\n    };\n  } else if (isNumber(value)) {\n    func = function func(d) {\n      return value;\n    };\n  } else {\n    func = value;\n  }\n\n  return func;\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 需要被转换的值\n * @param  {EdgeConfig[]}  edges 返回函数的默认返回值\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureData = function buildTextureData(nodes, edges) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i];\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = dests.length;\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  }\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr(nodes, edges, attrs) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n\n    var len = dests.length;\n    dataArray[i * 4 + 2] = offset;\n    dataArray[i * 4 + 3] = len / 2; // 第四位存储与该节点相关的所有节点个数\n\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  } // 不是 4 的倍数，填充 0\n\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * 将节点和边数据转换为 GPU 可读的数组，每条边带有一个以上属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 节点数组\n * @param  {EdgeConfig[]}  edges 边数组\n * @param  {Function}  attrs 读取边属性的函数\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\n\nexport var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr(nodes, edges, attrs1, attrs2) {\n  var dataArray = [];\n  var nodeDict = [];\n  var mapIdPos = {};\n  var i = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var n = nodes[i];\n    mapIdPos[n.id] = i;\n    dataArray.push(n.x);\n    dataArray.push(n.y);\n    dataArray.push(0);\n    dataArray.push(0);\n    nodeDict.push([]);\n  }\n\n  for (i = 0; i < edges.length; i++) {\n    var e = edges[i];\n    nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n    nodeDict[mapIdPos[e.source]].push(attrs1(e));\n    nodeDict[mapIdPos[e.source]].push(attrs2(e));\n    nodeDict[mapIdPos[e.source]].push(0);\n    nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    nodeDict[mapIdPos[e.target]].push(attrs1(e));\n    nodeDict[mapIdPos[e.target]].push(attrs2(e));\n    nodeDict[mapIdPos[e.target]].push(0);\n  }\n\n  var maxEdgePerVetex = 0;\n\n  for (i = 0; i < nodes.length; i++) {\n    var offset = dataArray.length;\n    var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n\n    var len = dests.length; // dataArray[i * 4 + 2] = offset;\n    // dataArray[i * 4 + 3] = len / 4; // 第四位存储与该节点相关的所有节点个数\n    // pack offset & length into float32: offset 20bit, length 12bit\n\n    dataArray[i * 4 + 2] = offset + 1048576 * len / 4;\n    dataArray[i * 4 + 3] = 0; // 第四位存储与上一次的距离差值\n\n    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);\n\n    for (var j = 0; j < len; ++j) {\n      var dest = dests[j];\n      dataArray.push(+dest);\n    }\n  } // 不是 4 的倍数，填充 0\n\n\n  while (dataArray.length % 4 !== 0) {\n    dataArray.push(0);\n  }\n\n  return {\n    array: new Float32Array(dataArray),\n    maxEdgePerVetex: maxEdgePerVetex\n  };\n};\n/**\n * transform the extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @param  {ModelConfig[]}  items the items to be read\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\n\nexport var attributesToTextureData = function attributesToTextureData(attributeNames, items) {\n  var dataArray = [];\n  var attributeNum = attributeNames.length;\n  var attributteStringMap = {};\n  items.forEach(function (item) {\n    attributeNames.forEach(function (name, i) {\n      if (attributteStringMap[item[name]] === undefined) {\n        attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;\n      }\n\n      dataArray.push(attributteStringMap[item[name]]); // insure each node's attributes take inter number of grids\n\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  });\n  return {\n    array: new Float32Array(dataArray),\n    count: Object.keys(attributteStringMap).length\n  };\n};\n/**\n * transform the number array format of extended attributes of nodes or edges to a texture array\n * @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n * @return {Float32Array} the attributes' value array to be read by GPU\n */\n\nexport var arrayToTextureData = function arrayToTextureData(valueArrays) {\n  var dataArray = [];\n  var attributeNum = valueArrays.length;\n  var itemNum = valueArrays[0].length;\n\n  var _loop_1 = function _loop_1(j) {\n    valueArrays.forEach(function (valueArray, i) {\n      dataArray.push(valueArray[j]); // insure each node's attributes take inter number of grids\n\n      if (i === attributeNum - 1) {\n        while (dataArray.length % 4 !== 0) {\n          dataArray.push(0);\n        }\n      }\n    });\n  };\n\n  for (var j = 0; j < itemNum; j++) {\n    _loop_1(j);\n  }\n\n  return new Float32Array(dataArray);\n};\n/**\n *\n * @param data Tree graph data\n * @param layout\n */\n\nexport var radialLayout = function radialLayout(data, layout) {\n  // 布局方式有 H / V / LR / RL / TB / BT\n  var VERTICAL_LAYOUTS = ['V', 'TB', 'BT'];\n  var min = {\n    x: Infinity,\n    y: Infinity\n  };\n  var max = {\n    x: -Infinity,\n    y: -Infinity\n  }; // 默认布局是垂直布局TB，此时x对应rad，y对应r\n\n  var rScale = 'x';\n  var radScale = 'y';\n\n  if (layout && VERTICAL_LAYOUTS.indexOf(layout) >= 0) {\n    // 若是水平布局，y对应rad，x对应r\n    radScale = 'x';\n    rScale = 'y';\n  }\n\n  var count = 0;\n  traverseTree(data, function (node) {\n    count++;\n\n    if (node.x > max.x) {\n      max.x = node.x;\n    }\n\n    if (node.x < min.x) {\n      min.x = node.x;\n    }\n\n    if (node.y > max.y) {\n      max.y = node.y;\n    }\n\n    if (node.y < min.y) {\n      min.y = node.y;\n    }\n\n    return true;\n  });\n  var avgRad = Math.PI * 2 / count;\n  var radDiff = max[radScale] - min[radScale];\n\n  if (radDiff === 0) {\n    return data;\n  }\n\n  traverseTree(data, function (node) {\n    var radial = (node[radScale] - min[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;\n    var r = Math.abs(rScale === 'x' ? node.x - data.x : node.y - data.y);\n    node.x = r * Math.cos(radial);\n    node.y = r * Math.sin(radial);\n    return true;\n  });\n  return data;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}