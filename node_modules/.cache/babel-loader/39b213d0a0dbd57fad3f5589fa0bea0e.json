{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _temp;\n\nimport { inject, injectable } from 'inversify';\nimport { createEntity } from '../..';\nimport { IDENTIFIER } from '../../identifier';\nimport { gl } from '../renderer/gl';\nexport var GeometrySystem = (_dec = injectable(), _dec2 = inject(IDENTIFIER.GeometryComponentManager), _dec3 = inject(IDENTIFIER.RenderEngine), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {\n  function GeometrySystem() {\n    _classCallCheck(this, GeometrySystem);\n\n    _initializerDefineProperty(this, \"geometry\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"engine\", _descriptor2, this);\n  }\n\n  _createClass(GeometrySystem, [{\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.geometry.forEach(function (entity, component) {\n                  // build buffers for each geometry\n                  if (component.dirty) {\n                    component.attributes.forEach(function (attribute) {\n                      if (attribute.dirty && attribute.data) {\n                        if (!attribute.buffer) {\n                          attribute.buffer = _this.engine.createBuffer({\n                            data: attribute.data,\n                            type: gl.FLOAT\n                          });\n                        } else {\n                          var _attribute$buffer;\n\n                          (_attribute$buffer = attribute.buffer) === null || _attribute$buffer === void 0 ? void 0 : _attribute$buffer.subData({\n                            data: attribute.data,\n                            // TODO: support offset in subdata\n                            offset: 0\n                          });\n                        }\n\n                        attribute.dirty = false;\n                      }\n                    }); // create index buffer if needed\n\n                    if (component.indices) {\n                      if (!component.indicesBuffer) {\n                        component.indicesBuffer = _this.engine.createElements({\n                          data: component.indices,\n                          count: component.indices.length,\n                          type: gl.UNSIGNED_INT,\n                          usage: gl.STATIC_DRAW\n                        });\n                      } else {\n                        component.indicesBuffer.subData({\n                          data: component.indices,\n                          offset: 0\n                        });\n                      }\n                    }\n\n                    component.dirty = false;\n                  }\n                });\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function execute() {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.geometry.forEach(function (_, geometry) {\n        if (geometry.indicesBuffer) {\n          geometry.indicesBuffer.destroy();\n        }\n\n        geometry.attributes.forEach(function (attribute) {\n          if (attribute.buffer) {\n            attribute.buffer.destroy();\n          }\n        });\n      });\n      this.geometry.clear();\n    }\n    /**\n     * @see https://threejs.org/docs/#api/en/core/BufferGeometry\n     */\n\n  }, {\n    key: \"createBufferGeometry\",\n    value: function createBufferGeometry() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        vertexCount: 3\n      },\n          vertexCount = _ref.vertexCount;\n\n      var entity = createEntity();\n      return this.geometry.create(entity, {\n        vertexCount: vertexCount\n      });\n    }\n    /**\n     * @see https://threejs.org/docs/#api/en/core/InstancedBufferGeometry\n     */\n\n  }, {\n    key: \"createInstancedBufferGeometry\",\n    value: function createInstancedBufferGeometry(_ref2) {\n      var maxInstancedCount = _ref2.maxInstancedCount,\n          vertexCount = _ref2.vertexCount;\n      var entity = createEntity();\n      return this.geometry.create(entity, {\n        maxInstancedCount: maxInstancedCount,\n        vertexCount: vertexCount\n      });\n    }\n  }]);\n\n  return GeometrySystem;\n}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"geometry\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"engine\", [_dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":{"version":3,"mappings":"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","names":["inject","injectable","createEntity","IDENTIFIER","gl","GeometrySystem","GeometryComponentManager","RenderEngine","_classCallCheck","_initializerDefineProperty","_createClass","key","value","geometry","forEach","entity","component","dirty","attributes","attribute","data","buffer","_this","engine","createBuffer","type","FLOAT","subData","offset","indices","indicesBuffer","createElements","count","length","UNSIGNED_INT","usage","STATIC_DRAW","_","destroy","clear","vertexCount","create","maxInstancedCount","configurable","enumerable","writable","initializer"],"sources":["../../../src/components/geometry/System.ts"],"sourcesContent":["import { vec3 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { createEntity, ISystem } from '../..';\nimport { ComponentManager } from '../../ComponentManager';\nimport { IDENTIFIER } from '../../identifier';\nimport { generateAABBFromVertices } from '../../utils/aabb';\nimport { gl } from '../renderer/gl';\nimport { IBuffer } from '../renderer/IBuffer';\nimport { BufferData, IRendererService } from '../renderer/IRendererService';\nimport { GeometryComponent } from './GeometryComponent';\n\n@injectable()\nexport class GeometrySystem implements ISystem {\n  @inject(IDENTIFIER.GeometryComponentManager)\n  private readonly geometry: ComponentManager<GeometryComponent>;\n\n  @inject(IDENTIFIER.RenderEngine)\n  private readonly engine: IRendererService;\n\n  public async execute() {\n    this.geometry.forEach((entity, component) => {\n      // build buffers for each geometry\n      if (component.dirty) {\n        component.attributes.forEach((attribute) => {\n          if (attribute.dirty && attribute.data) {\n            if (!attribute.buffer) {\n              attribute.buffer = this.engine.createBuffer({\n                data: attribute.data,\n                type: gl.FLOAT,\n              });\n            } else {\n              attribute.buffer?.subData({\n                data: attribute.data,\n                // TODO: support offset in subdata\n                offset: 0,\n              });\n            }\n            attribute.dirty = false;\n          }\n        });\n\n        // create index buffer if needed\n        if (component.indices) {\n          if (!component.indicesBuffer) {\n            component.indicesBuffer = this.engine.createElements({\n              data: component.indices,\n              count: component.indices.length,\n              type: gl.UNSIGNED_INT,\n              usage: gl.STATIC_DRAW,\n            });\n          } else {\n            component.indicesBuffer.subData({\n              data: component.indices,\n              offset: 0,\n            });\n          }\n        }\n        component.dirty = false;\n      }\n    });\n  }\n\n  public tearDown() {\n    this.geometry.forEach((_, geometry) => {\n      if (geometry.indicesBuffer) {\n        geometry.indicesBuffer.destroy();\n      }\n\n      geometry.attributes.forEach((attribute) => {\n        if (attribute.buffer) {\n          attribute.buffer.destroy();\n        }\n      });\n    });\n    this.geometry.clear();\n  }\n\n  /**\n   * @see https://threejs.org/docs/#api/en/core/BufferGeometry\n   */\n  public createBufferGeometry(\n    { vertexCount }: { vertexCount: number } = { vertexCount: 3 },\n  ) {\n    const entity = createEntity();\n    return this.geometry.create(entity, {\n      vertexCount,\n    });\n  }\n\n  /**\n   * @see https://threejs.org/docs/#api/en/core/InstancedBufferGeometry\n   */\n  public createInstancedBufferGeometry({\n    maxInstancedCount,\n    vertexCount,\n  }: {\n    maxInstancedCount: number;\n    vertexCount: number;\n  }) {\n    const entity = createEntity();\n    return this.geometry.create(entity, {\n      maxInstancedCount,\n      vertexCount,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}