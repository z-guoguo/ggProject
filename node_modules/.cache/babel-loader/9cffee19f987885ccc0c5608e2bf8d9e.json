{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { gl, isSafari } from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { extractUniforms } from '../utils/uniform';\nimport { getColorStateDescriptors, getCullMode, getDepthStencilStateDescriptor, primitiveMap } from './constants';\nimport WebGPUBuffer from './WebGPUBuffer'; // @ts-ignore\n\nfunction concatenate(resultConstructor) {\n  var totalLength = 0;\n\n  for (var _len = arguments.length, arrays = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrays[_key - 1] = arguments[_key];\n  }\n\n  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {\n    var arr = _arrays[_i];\n    totalLength += arr.length;\n  }\n\n  var result = new resultConstructor(totalLength);\n  var offset = 0;\n\n  for (var _i2 = 0, _arrays2 = arrays; _i2 < _arrays2.length; _i2++) {\n    var _arr = _arrays2[_i2];\n    result.set(_arr, offset);\n    offset += _arr.length;\n  }\n\n  return result;\n}\n\nvar WebGPUModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n\n  /**\n   * vertex\n   */\n\n  /**\n   * indices's buffer\n   */\n  function WebGPUModel(engine, options) {\n    _classCallCheck(this, WebGPUModel);\n\n    this.engine = engine;\n    this.options = options;\n    this.pipelineLayout = void 0;\n    this.renderPipeline = void 0;\n    this.uniformsBindGroupLayout = void 0;\n    this.uniformBindGroup = void 0;\n    this.uniformBuffer = void 0;\n    this.uniforms = {};\n    this.uniformGPUBufferLayout = [];\n    this.attributeCache = {};\n    this.indexBuffer = void 0;\n    this.indexCount = void 0;\n  }\n\n  _createClass(WebGPUModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var _this$options, vs, fs, attributes, uniforms, primitive, count, elements, depth, blend, stencil, cull, instances, _yield$this$compilePi, vertexStage, fragmentStage, vertexState, descriptor;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$options = this.options, vs = _this$options.vs, fs = _this$options.fs, attributes = _this$options.attributes, uniforms = _this$options.uniforms, primitive = _this$options.primitive, count = _this$options.count, elements = _this$options.elements, depth = _this$options.depth, blend = _this$options.blend, stencil = _this$options.stencil, cull = _this$options.cull, instances = _this$options.instances; // build shaders first\n\n                _context.next = 3;\n                return this.compilePipelineStageDescriptor(vs, fs, null);\n\n              case 3:\n                _yield$this$compilePi = _context.sent;\n                vertexStage = _yield$this$compilePi.vertexStage;\n                fragmentStage = _yield$this$compilePi.fragmentStage;\n\n                if (uniforms) {\n                  // create uniform bind groups & layout\n                  this.buildUniformBindGroup(uniforms);\n                }\n\n                if (elements) {\n                  this.indexBuffer = elements.get();\n                  this.indexCount = elements.indexCount;\n                } // TODO: instanced array\n\n\n                vertexState = {\n                  vertexBuffers: Object.keys(attributes).map(function (attributeName, i) {\n                    var attribute = attributes[attributeName];\n\n                    var _attribute$get = attribute.get(),\n                        arrayStride = _attribute$get.arrayStride,\n                        stepMode = _attribute$get.stepMode,\n                        ats = _attribute$get.attributes;\n\n                    _this.attributeCache[attributeName] = attribute;\n                    return {\n                      arrayStride: arrayStride,\n                      stepMode: stepMode,\n                      attributes: ats\n                    };\n                  })\n                };\n                descriptor = {\n                  sampleCount: this.engine.mainPassSampleCount,\n                  primitiveTopology: primitiveMap[primitive || gl.TRIANGLES],\n                  rasterizationState: _objectSpread(_objectSpread({}, this.getDefaultRasterizationStateDescriptor()), {}, {\n                    // TODO: support frontface\n                    cullMode: getCullMode({\n                      cull: cull\n                    })\n                  }),\n                  depthStencilState: getDepthStencilStateDescriptor({\n                    depth: depth,\n                    stencil: stencil\n                  }),\n                  colorStates: getColorStateDescriptors({\n                    blend: blend\n                  }, this.engine.options.swapChainFormat),\n                  layout: this.pipelineLayout,\n                  vertexStage: vertexStage,\n                  fragmentStage: fragmentStage,\n                  vertexState: vertexState\n                }; // create pipeline\n\n                this.renderPipeline = this.engine.device.createRenderPipeline(descriptor);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"addUniforms\",\n    value: function addUniforms(uniforms) {\n      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), extractUniforms(uniforms));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(options) {\n      var _this2 = this;\n\n      var renderPass = this.engine.getCurrentRenderPass();\n\n      var uniforms = _objectSpread(_objectSpread({}, this.uniforms), extractUniforms(options.uniforms || {}));\n\n      var bindGroupBindings = []; // TODO: uniform 发生修改\n\n      Object.keys(uniforms).forEach(function (uniformName) {\n        var type = _typeof(uniforms[uniformName]);\n\n        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) || // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT) {\n          var _this2$uniformGPUBuff;\n\n          var offset = (_this2$uniformGPUBuff = _this2.uniformGPUBufferLayout.find(function (_ref) {\n            var name = _ref.name;\n            return name === uniformName;\n          })) === null || _this2$uniformGPUBuff === void 0 ? void 0 : _this2$uniformGPUBuff.offset;\n\n          if (offset !== null) {\n            _this2.uniformBuffer.subData({\n              // @ts-ignore\n              data: uniforms[uniformName],\n              // @ts-ignore\n              offset: offset\n            });\n          }\n        } else {\n          var _this2$uniformGPUBuff2;\n\n          var _offset = (_this2$uniformGPUBuff2 = _this2.uniformGPUBufferLayout.find(function (_ref2) {\n            var name = _ref2.name;\n            return name === uniformName;\n          })) === null || _this2$uniformGPUBuff2 === void 0 ? void 0 : _this2$uniformGPUBuff2.offset;\n\n          if (_offset !== null) {\n            var textureOrFramebuffer = uniforms[uniformName].get();\n\n            var _ref3 = // @ts-ignore\n            textureOrFramebuffer.color || textureOrFramebuffer,\n                texture = _ref3.texture,\n                sampler = _ref3.sampler;\n\n            if (sampler) {\n              bindGroupBindings.push({\n                // @ts-ignore\n                binding: _offset,\n                resource: sampler\n              }); // @ts-ignore\n\n              _offset++;\n            }\n\n            bindGroupBindings.push({\n              // @ts-ignore\n              binding: _offset,\n              resource: texture.createView()\n            });\n          }\n        }\n      });\n\n      if (this.uniformBuffer) {\n        bindGroupBindings[0] = {\n          binding: 0,\n          resource: {\n            buffer: this.uniformBuffer.get() // 返回 GPUBuffer 原生对象\n\n          }\n        };\n      }\n\n      this.uniformBindGroup = this.engine.device.createBindGroup({\n        layout: this.uniformsBindGroupLayout,\n        entries: bindGroupBindings\n      });\n\n      if (this.renderPipeline) {\n        renderPass.setPipeline(this.renderPipeline);\n      }\n\n      renderPass.setBindGroup(0, this.uniformBindGroup);\n\n      if (this.indexBuffer) {\n        renderPass.setIndexBuffer(this.indexBuffer.get(), WebGPUConstants.IndexFormat.Uint32, 0);\n      }\n\n      Object.keys(this.attributeCache).forEach(function (attributeName, i) {\n        renderPass.setVertexBuffer(0 + i, _this2.attributeCache[attributeName].get().buffer, 0);\n      }); // renderPass.draw(verticesCount, instancesCount, verticesStart, 0);\n\n      if (this.indexBuffer) {\n        renderPass.drawIndexed(this.indexCount, this.options.instances || 1, 0, 0, 0);\n      } else {\n        renderPass.draw(this.options.count || 0, this.options.instances || 0, 0, 0);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"compilePipelineStageDescriptor\",\n    value: function () {\n      var _compilePipelineStageDescriptor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(vertexCode, fragmentCode, defines) {\n        var shaderVersion, vertexShader, fragmentShader;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                shaderVersion = '#version 450\\n';\n                vertexShader = vertexCode;\n                fragmentShader = fragmentCode;\n\n                if (this.engine.options.useWGSL) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                _context2.next = 6;\n                return this.compileShaderToSpirV(vertexCode, 'vertex', shaderVersion);\n\n              case 6:\n                vertexShader = _context2.sent;\n                _context2.next = 9;\n                return this.compileShaderToSpirV(fragmentCode, 'fragment', shaderVersion);\n\n              case 9:\n                fragmentShader = _context2.sent;\n\n              case 10:\n                return _context2.abrupt(\"return\", this.createPipelineStageDescriptor(vertexShader, fragmentShader));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function compilePipelineStageDescriptor(_x, _x2, _x3) {\n        return _compilePipelineStageDescriptor.apply(this, arguments);\n      }\n\n      return compilePipelineStageDescriptor;\n    }()\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"createPipelineStageDescriptor\",\n    value: function createPipelineStageDescriptor(vertexShader, fragmentShader) {\n      return {\n        vertexStage: {\n          module: this.engine.device.createShaderModule({\n            code: vertexShader,\n            // @ts-ignore\n            isWHLSL: isSafari\n          }),\n          entryPoint: 'main'\n        },\n        fragmentStage: {\n          module: this.engine.device.createShaderModule({\n            code: fragmentShader,\n            // @ts-ignore\n            isWHLSL: isSafari\n          }),\n          entryPoint: 'main'\n        }\n      };\n    }\n    /**\n     * @see https://gpuweb.github.io/gpuweb/#rasterization-state\n     */\n\n  }, {\n    key: \"getDefaultRasterizationStateDescriptor\",\n    value: function getDefaultRasterizationStateDescriptor() {\n      return {\n        frontFace: WebGPUConstants.FrontFace.CCW,\n        cullMode: WebGPUConstants.CullMode.None,\n        depthBias: 0,\n        depthBiasSlopeScale: 0,\n        depthBiasClamp: 0\n      };\n    }\n  }, {\n    key: \"buildUniformBindGroup\",\n    value: function buildUniformBindGroup(uniforms) {\n      var _this3 = this;\n\n      var offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n\n      var mergedUniformData = concatenate.apply(void 0, [Float32Array].concat(_toConsumableArray(Object.keys(uniforms).map(function (uniformName) {\n        if (uniforms[uniformName]) {\n          _this3.uniformGPUBufferLayout.push({\n            name: uniformName,\n            offset: offset\n          }); // @ts-ignore\n\n\n          offset += (uniforms[uniformName].length || 1) * 4;\n          return uniforms[uniformName];\n        } else {\n          // texture & framebuffer\n          return [];\n        }\n      }))));\n      var entries = [];\n      var hasUniform = false;\n\n      if (mergedUniformData.length) {\n        hasUniform = true; // TODO: 所有 uniform 绑定到 slot 0，通过解析 Shader 代码判定可见性\n\n        entries.push({\n          // TODO: 暂时都绑定到 slot 0\n          binding: 0,\n          visibility: WebGPUConstants.ShaderStage.Fragment | WebGPUConstants.ShaderStage.Vertex,\n          // TODO: 暂时 VS 和 FS 都可见\n          type: WebGPUConstants.BindingType.UniformBuffer\n        });\n      } // 声明 texture & sampler\n\n\n      Object.keys(uniforms).filter(function (uniformName) {\n        return uniforms[uniformName] === null;\n      }).forEach(function (uniformName, i) {\n        _this3.uniformGPUBufferLayout.push({\n          name: uniformName,\n          offset: i * 2 + (hasUniform ? 1 : 0)\n        });\n\n        entries.push({\n          // Sampler\n          binding: i * 2 + (hasUniform ? 1 : 0),\n          visibility: WebGPUConstants.ShaderStage.Fragment,\n          type: WebGPUConstants.BindingType.Sampler\n        }, {\n          // Texture view\n          binding: i * 2 + (hasUniform ? 1 : 0) + 1,\n          visibility: WebGPUConstants.ShaderStage.Fragment,\n          type: WebGPUConstants.BindingType.SampledTexture\n        });\n      });\n      this.uniformsBindGroupLayout = this.engine.device.createBindGroupLayout({\n        // 最新 API 0.0.22 版本使用 entries。Chrome Canary 84.0.4110.0 已实现。\n        // 使用 bindings 会报 Warning: GPUBindGroupLayoutDescriptor.bindings is deprecated: renamed to entries\n        // @see https://github.com/antvis/GWebGPUEngine/issues/5\n        entries: entries\n      });\n      this.pipelineLayout = this.engine.device.createPipelineLayout({\n        bindGroupLayouts: [this.uniformsBindGroupLayout]\n      });\n\n      if (hasUniform) {\n        this.uniformBuffer = new WebGPUBuffer(this.engine, {\n          // TODO: 处理 Struct 和 boolean\n          // @ts-ignore\n          data: mergedUniformData instanceof Array ? // @ts-ignore\n          new Float32Array(mergedUniformData) : mergedUniformData,\n          usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n        });\n      }\n    }\n  }]);\n\n  return WebGPUModel;\n}();\n\nexport { WebGPUModel as default };","map":{"version":3,"mappings":"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","names":["gl","isSafari","WebGPUConstants","extractUniforms","getColorStateDescriptors","getCullMode","getDepthStencilStateDescriptor","primitiveMap","WebGPUBuffer","concatenate","resultConstructor","totalLength","arrays","arguments","arr","length","result","offset","set","WebGPUModel","engine","options","_classCallCheck","pipelineLayout","renderPipeline","uniformsBindGroupLayout","uniformBindGroup","uniformBuffer","uniforms","uniformGPUBufferLayout","attributeCache","indexBuffer","indexCount","vs","fs","attributes","primitive","count","elements","depth","blend","stencil","cull","instances","compilePipelineStageDescriptor","vertexStage","fragmentStage","buildUniformBindGroup","get","vertexState","vertexBuffers","Object","keys","map","attributeName","i","attribute","arrayStride","stepMode","ats","_this","descriptor","sampleCount","mainPassSampleCount","primitiveTopology","TRIANGLES","rasterizationState","getDefaultRasterizationStateDescriptor","cullMode","depthStencilState","colorStates","swapChainFormat","layout","device","createRenderPipeline","renderPass","getCurrentRenderPass","bindGroupBindings","forEach","uniformName","type","Array","isArray","BYTES_PER_ELEMENT","_this2","find","name","_this2$uniformGPUBuff","subData","data","_this2$uniformGPUBuff2","textureOrFramebuffer","color","texture","sampler","push","binding","resource","createView","buffer","createBindGroup","entries","setPipeline","setBindGroup","setIndexBuffer","IndexFormat","Uint32","setVertexBuffer","drawIndexed","draw","Error","vertexCode","fragmentCode","defines","shaderVersion","vertexShader","fragmentShader","useWGSL","compileShaderToSpirV","createPipelineStageDescriptor","source","compileRawShaderToSpirV","glslang","compileGLSL","module","createShaderModule","code","isWHLSL","entryPoint","frontFace","FrontFace","CCW","CullMode","None","depthBias","depthBiasSlopeScale","depthBiasClamp","mergedUniformData","Float32Array","_this3","hasUniform","visibility","ShaderStage","Fragment","Vertex","BindingType","UniformBuffer","filter","Sampler","SampledTexture","createBindGroupLayout","createPipelineLayout","bindGroupLayouts","usage","BufferUsage","Uniform","CopyDst"],"sources":["../../src/webgpu/WebGPUModel.ts"],"sourcesContent":["import {\n  gl,\n  IModel,\n  IModelDrawOptions,\n  IModelInitializationOptions,\n  isSafari,\n  IUniform,\n} from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { WebGPUEngine } from '.';\nimport { extractUniforms } from '../utils/uniform';\nimport {\n  getColorStateDescriptors,\n  getCullMode,\n  getDepthStencilStateDescriptor,\n  primitiveMap,\n} from './constants';\nimport WebGPUAttribute from './WebGPUAttribute';\nimport WebGPUBuffer from './WebGPUBuffer';\nimport WebGPUElements from './WebGPUElements';\nimport WebGPUFramebuffer from './WebGPUFramebuffer';\nimport WebGPUTexture2D from './WebGPUTexture2D';\n\n// @ts-ignore\nfunction concatenate(resultConstructor, ...arrays) {\n  let totalLength = 0;\n  for (const arr of arrays) {\n    totalLength += arr.length;\n  }\n  const result = new resultConstructor(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\nexport default class WebGPUModel implements IModel {\n  private pipelineLayout: GPUPipelineLayout;\n  private renderPipeline: GPURenderPipeline;\n  private uniformsBindGroupLayout: GPUBindGroupLayout;\n  private uniformBindGroup: GPUBindGroup;\n  private uniformBuffer: WebGPUBuffer;\n\n  private uniforms: {\n    [key: string]: IUniform;\n  } = {};\n\n  /**\n   * 用于后续渲染时动态更新\n   */\n  private uniformGPUBufferLayout: Array<{\n    name: string;\n    offset: number;\n  }> = [];\n\n  /**\n   * vertex\n   */\n  private attributeCache: {\n    [attributeName: string]: WebGPUAttribute;\n  } = {};\n\n  /**\n   * indices's buffer\n   */\n  private indexBuffer: WebGPUBuffer;\n  private indexCount: number;\n\n  constructor(\n    private engine: WebGPUEngine,\n    private options: IModelInitializationOptions,\n  ) {}\n\n  public async init() {\n    const {\n      vs,\n      fs,\n      attributes,\n      uniforms,\n      primitive,\n      count,\n      elements,\n      depth,\n      blend,\n      stencil,\n      cull,\n      instances,\n    } = this.options;\n\n    // build shaders first\n    const {\n      vertexStage,\n      fragmentStage,\n    } = await this.compilePipelineStageDescriptor(vs, fs, null);\n\n    if (uniforms) {\n      // create uniform bind groups & layout\n      this.buildUniformBindGroup(uniforms);\n    }\n\n    if (elements) {\n      this.indexBuffer = (elements as WebGPUElements).get() as WebGPUBuffer;\n      this.indexCount = (elements as WebGPUElements).indexCount;\n    }\n\n    // TODO: instanced array\n\n    const vertexState = {\n      vertexBuffers: Object.keys(attributes).map((attributeName, i) => {\n        const attribute = attributes[attributeName] as WebGPUAttribute;\n        const { arrayStride, stepMode, attributes: ats } = attribute.get();\n        this.attributeCache[attributeName] = attribute;\n        return {\n          arrayStride,\n          stepMode,\n          attributes: ats,\n        };\n      }),\n    };\n\n    const descriptor = {\n      sampleCount: this.engine.mainPassSampleCount,\n      primitiveTopology: primitiveMap[primitive || gl.TRIANGLES],\n      rasterizationState: {\n        ...this.getDefaultRasterizationStateDescriptor(),\n        // TODO: support frontface\n        cullMode: getCullMode({ cull }),\n      },\n      depthStencilState: getDepthStencilStateDescriptor({\n        depth,\n        stencil,\n      }),\n      colorStates: getColorStateDescriptors(\n        { blend },\n        this.engine.options.swapChainFormat!,\n      ),\n      layout: this.pipelineLayout,\n      vertexStage,\n      fragmentStage,\n      vertexState,\n    };\n\n    // create pipeline\n    this.renderPipeline = this.engine.device.createRenderPipeline(descriptor);\n  }\n\n  public addUniforms(uniforms: { [key: string]: IUniform }): void {\n    this.uniforms = {\n      ...this.uniforms,\n      ...extractUniforms(uniforms),\n    };\n  }\n\n  public draw(options: IModelDrawOptions): void {\n    const renderPass = this.engine.getCurrentRenderPass();\n\n    const uniforms: {\n      [key: string]: IUniform;\n    } = {\n      ...this.uniforms,\n      ...extractUniforms(options.uniforms || {}),\n    };\n\n    const bindGroupBindings: GPUBindGroupEntry[] = [];\n\n    // TODO: uniform 发生修改\n    Object.keys(uniforms).forEach((uniformName: string) => {\n      const type = typeof uniforms[uniformName];\n      if (\n        type === 'boolean' ||\n        type === 'number' ||\n        Array.isArray(uniforms[uniformName]) ||\n        // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT\n      ) {\n        const offset = this.uniformGPUBufferLayout.find(\n          ({ name }) => name === uniformName,\n        )?.offset;\n        if (offset !== null) {\n          this.uniformBuffer.subData({\n            // @ts-ignore\n            data: uniforms[uniformName],\n            // @ts-ignore\n            offset,\n          });\n        }\n      } else {\n        let offset = this.uniformGPUBufferLayout.find(\n          ({ name }) => name === uniformName,\n        )?.offset;\n        if (offset !== null) {\n          const textureOrFramebuffer = (uniforms[uniformName] as\n            | WebGPUTexture2D\n            | WebGPUFramebuffer).get();\n          const { texture, sampler } =\n            // @ts-ignore\n            textureOrFramebuffer.color || textureOrFramebuffer;\n          if (sampler) {\n            bindGroupBindings.push({\n              // @ts-ignore\n              binding: offset,\n              resource: sampler,\n            });\n            // @ts-ignore\n            offset++;\n          }\n          bindGroupBindings.push({\n            // @ts-ignore\n            binding: offset,\n            resource: texture.createView(),\n          });\n        }\n      }\n    });\n\n    if (this.uniformBuffer) {\n      bindGroupBindings[0] = {\n        binding: 0,\n        resource: {\n          buffer: this.uniformBuffer.get(), // 返回 GPUBuffer 原生对象\n        },\n      };\n    }\n\n    this.uniformBindGroup = this.engine.device.createBindGroup({\n      layout: this.uniformsBindGroupLayout,\n      entries: bindGroupBindings,\n    });\n\n    if (this.renderPipeline) {\n      renderPass.setPipeline(this.renderPipeline);\n    }\n\n    renderPass.setBindGroup(0, this.uniformBindGroup);\n\n    if (this.indexBuffer) {\n      renderPass.setIndexBuffer(\n        this.indexBuffer.get(),\n        WebGPUConstants.IndexFormat.Uint32,\n        0,\n      );\n    }\n\n    Object.keys(this.attributeCache).forEach((attributeName: string, i) => {\n      renderPass.setVertexBuffer(\n        0 + i,\n        this.attributeCache[attributeName].get().buffer,\n        0,\n      );\n    });\n\n    // renderPass.draw(verticesCount, instancesCount, verticesStart, 0);\n    if (this.indexBuffer) {\n      renderPass.drawIndexed(\n        this.indexCount,\n        this.options.instances || 1,\n        0,\n        0,\n        0,\n      );\n    } else {\n      renderPass.draw(\n        this.options.count || 0,\n        this.options.instances || 0,\n        0,\n        0,\n      );\n    }\n  }\n\n  public destroy(): void {\n    throw new Error('Method not implemented.');\n  }\n\n  private async compilePipelineStageDescriptor(\n    vertexCode: string,\n    fragmentCode: string,\n    defines: string | null,\n  ): Promise<\n    Pick<GPURenderPipelineDescriptor, 'vertexStage' | 'fragmentStage'>\n  > {\n    const shaderVersion = '#version 450\\n';\n\n    let vertexShader: Uint32Array | string = vertexCode;\n    let fragmentShader: Uint32Array | string = fragmentCode;\n    if (!this.engine.options.useWGSL) {\n      vertexShader = await this.compileShaderToSpirV(\n        vertexCode,\n        'vertex',\n        shaderVersion,\n      );\n      fragmentShader = await this.compileShaderToSpirV(\n        fragmentCode,\n        'fragment',\n        shaderVersion,\n      );\n    }\n\n    return this.createPipelineStageDescriptor(vertexShader, fragmentShader);\n  }\n\n  private compileShaderToSpirV(\n    source: string,\n    type: string,\n    shaderVersion: string,\n  ): Promise<Uint32Array> {\n    return this.compileRawShaderToSpirV(shaderVersion + source, type);\n  }\n\n  private compileRawShaderToSpirV(\n    source: string,\n    type: string,\n  ): Promise<Uint32Array> {\n    return this.engine.glslang.compileGLSL(source, type);\n  }\n\n  private createPipelineStageDescriptor(\n    vertexShader: Uint32Array | string,\n    fragmentShader: Uint32Array | string,\n  ): Pick<GPURenderPipelineDescriptor, 'vertexStage' | 'fragmentStage'> {\n    return {\n      vertexStage: {\n        module: this.engine.device.createShaderModule({\n          code: vertexShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: this.engine.device.createShaderModule({\n          code: fragmentShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n    };\n  }\n\n  /**\n   * @see https://gpuweb.github.io/gpuweb/#rasterization-state\n   */\n  private getDefaultRasterizationStateDescriptor(): GPURasterizationStateDescriptor {\n    return {\n      frontFace: WebGPUConstants.FrontFace.CCW,\n      cullMode: WebGPUConstants.CullMode.None,\n      depthBias: 0,\n      depthBiasSlopeScale: 0,\n      depthBiasClamp: 0,\n    };\n  }\n\n  private buildUniformBindGroup(uniforms: { [key: string]: IUniform }) {\n    let offset = 0;\n    // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n    const mergedUniformData = concatenate(\n      Float32Array,\n      ...Object.keys(uniforms).map((uniformName) => {\n        if (uniforms[uniformName]) {\n          this.uniformGPUBufferLayout.push({\n            name: uniformName,\n            offset,\n          });\n          // @ts-ignore\n          offset += (uniforms[uniformName].length || 1) * 4;\n          return uniforms[uniformName];\n        } else {\n          // texture & framebuffer\n          return [];\n        }\n      }),\n    );\n\n    const entries: GPUBindGroupLayoutEntry[] = [];\n    let hasUniform = false;\n    if (mergedUniformData.length) {\n      hasUniform = true;\n      // TODO: 所有 uniform 绑定到 slot 0，通过解析 Shader 代码判定可见性\n      entries.push({\n        // TODO: 暂时都绑定到 slot 0\n        binding: 0,\n        visibility:\n          WebGPUConstants.ShaderStage.Fragment |\n          WebGPUConstants.ShaderStage.Vertex, // TODO: 暂时 VS 和 FS 都可见\n        type: WebGPUConstants.BindingType.UniformBuffer,\n      });\n    }\n\n    // 声明 texture & sampler\n    Object.keys(uniforms)\n      .filter((uniformName) => uniforms[uniformName] === null)\n      .forEach((uniformName, i) => {\n        this.uniformGPUBufferLayout.push({\n          name: uniformName,\n          offset: i * 2 + (hasUniform ? 1 : 0),\n        });\n        entries.push(\n          {\n            // Sampler\n            binding: i * 2 + (hasUniform ? 1 : 0),\n            visibility: WebGPUConstants.ShaderStage.Fragment,\n            type: WebGPUConstants.BindingType.Sampler,\n          },\n          {\n            // Texture view\n            binding: i * 2 + (hasUniform ? 1 : 0) + 1,\n            visibility: WebGPUConstants.ShaderStage.Fragment,\n            type: WebGPUConstants.BindingType.SampledTexture,\n          },\n        );\n      });\n\n    this.uniformsBindGroupLayout = this.engine.device.createBindGroupLayout({\n      // 最新 API 0.0.22 版本使用 entries。Chrome Canary 84.0.4110.0 已实现。\n      // 使用 bindings 会报 Warning: GPUBindGroupLayoutDescriptor.bindings is deprecated: renamed to entries\n      // @see https://github.com/antvis/GWebGPUEngine/issues/5\n      entries,\n    });\n\n    this.pipelineLayout = this.engine.device.createPipelineLayout({\n      bindGroupLayouts: [this.uniformsBindGroupLayout],\n    });\n\n    if (hasUniform) {\n      this.uniformBuffer = new WebGPUBuffer(this.engine, {\n        // TODO: 处理 Struct 和 boolean\n        // @ts-ignore\n        data:\n          mergedUniformData instanceof Array\n            ? // @ts-ignore\n              new Float32Array(mergedUniformData)\n            : mergedUniformData,\n        usage:\n          WebGPUConstants.BufferUsage.Uniform |\n          WebGPUConstants.BufferUsage.CopyDst,\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}