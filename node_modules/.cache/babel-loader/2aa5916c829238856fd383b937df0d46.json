{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\n\n\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = (0, _util.uniqueId)();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      }); // find the cluster with max weight\n\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true; // remove from origin cluster\n\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster\n\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n\n    if (state_1 === \"break\") break;\n  } // delete the empty clusters\n\n\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nvar _default = labelPropagation;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_adjacentMatrix","_interopRequireDefault","require","_util","obj","__esModule","labelPropagation","graphData","directed","weightPropertyName","maxIteration","_a","nodes","_b","edges","clusters","nodeMap","forEach","node","i","cid","uniqueId","clusterId","id","idx","adjMatrix","ks","neighbors","row","k","iid","entry","j","jid","push","iter","_loop_1","changed","neighborClusters","keys","neighborId","neighborWeight","neighborNode","neighborClusterId","maxWeight","Infinity","bestClusterIds","length","selfClusterIdx","indexOf","splice","selfCluster","nodeInSelfClusterIdx","randomIdx","Math","floor","random","bestCluster","state_1","cluster","clusterEdges","clusterEdgeMap","edge","source","target","weight","sourceClusterId","targetClusterId","newEdgeId","concat","count","newEdge","clustersArray","_default"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/lib/label-propagation.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = (0, _util.uniqueId)();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      }); // find the cluster with max weight\n\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true; // remove from origin cluster\n\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster\n\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n\n    if (state_1 === \"break\") break;\n  } // delete the empty clusters\n\n\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nvar _default = labelPropagation;\nexports.default = _default;"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,eAAe,GAAGC,sBAAsB,CAACC,OAAO,CAAC,mBAAD,CAAR,CAA5C;;AAEA,IAAIC,KAAK,GAAGD,OAAO,CAAC,QAAD,CAAnB;;AAEA,SAASD,sBAAT,CAAgCG,GAAhC,EAAqC;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;IAAEL,OAAO,EAAEK;EAAX,CAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIE,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,SAA1B,EAAqCC,QAArC,EAA+CC,kBAA/C,EAAmEC,YAAnE,EAAiF;EACtG,IAAIF,QAAQ,KAAK,KAAK,CAAtB,EAAyB;IACvBA,QAAQ,GAAG,KAAX;EACD;;EAED,IAAIC,kBAAkB,KAAK,KAAK,CAAhC,EAAmC;IACjCA,kBAAkB,GAAG,QAArB;EACD;;EAED,IAAIC,YAAY,KAAK,KAAK,CAA1B,EAA6B;IAC3BA,YAAY,GAAG,IAAf;EACD,CAXqG,CAWpG;;;EAGF,IAAIC,EAAE,GAAGJ,SAAS,CAACK,KAAnB;EAAA,IACIA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EADjC;EAAA,IAEIE,EAAE,GAAGN,SAAS,CAACO,KAFnB;EAAA,IAGIA,KAAK,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAHjC;EAIA,IAAIE,QAAQ,GAAG,EAAf;EACA,IAAIC,OAAO,GAAG,EAAd,CAnBsG,CAmBpF;;EAElBJ,KAAK,CAACK,OAAN,CAAc,UAAUC,IAAV,EAAgBC,CAAhB,EAAmB;IAC/B,IAAIC,GAAG,GAAG,CAAC,GAAGjB,KAAK,CAACkB,QAAV,GAAV;IACAH,IAAI,CAACI,SAAL,GAAiBF,GAAjB;IACAL,QAAQ,CAACK,GAAD,CAAR,GAAgB;MACdG,EAAE,EAAEH,GADU;MAEdR,KAAK,EAAE,CAACM,IAAD;IAFO,CAAhB;IAIAF,OAAO,CAACE,IAAI,CAACK,EAAN,CAAP,GAAmB;MACjBL,IAAI,EAAEA,IADW;MAEjBM,GAAG,EAAEL;IAFY,CAAnB;EAID,CAXD,EArBsG,CAgClG;;EAEJ,IAAIM,SAAS,GAAG,CAAC,GAAGzB,eAAe,CAACD,OAApB,EAA6BQ,SAA7B,EAAwCC,QAAxC,CAAhB,CAlCsG,CAkCnC;;EAEnE,IAAIkB,EAAE,GAAG,EAAT;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE,IAAIC,SAAS,GAAG,EAAhB;EACAF,SAAS,CAACR,OAAV,CAAkB,UAAUW,GAAV,EAAeT,CAAf,EAAkB;IAClC,IAAIU,CAAC,GAAG,CAAR;IACA,IAAIC,GAAG,GAAGlB,KAAK,CAACO,CAAD,CAAL,CAASI,EAAnB;IACAI,SAAS,CAACG,GAAD,CAAT,GAAiB,EAAjB;IACAF,GAAG,CAACX,OAAJ,CAAY,UAAUc,KAAV,EAAiBC,CAAjB,EAAoB;MAC9B,IAAI,CAACD,KAAL,EAAY;MACZF,CAAC,IAAIE,KAAL;MACA,IAAIE,GAAG,GAAGrB,KAAK,CAACoB,CAAD,CAAL,CAAST,EAAnB;MACAI,SAAS,CAACG,GAAD,CAAT,CAAeG,GAAf,IAAsBF,KAAtB;IACD,CALD;IAMAL,EAAE,CAACQ,IAAH,CAAQL,CAAR;EACD,CAXD;EAYA,IAAIM,IAAI,GAAG,CAAX;;EAEA,IAAIC,OAAO,GAAG,SAASA,OAAT,GAAmB;IAC/B,IAAIC,OAAO,GAAG,KAAd;IACAzB,KAAK,CAACK,OAAN,CAAc,UAAUC,IAAV,EAAgB;MAC5B,IAAIoB,gBAAgB,GAAG,EAAvB;MACA3C,MAAM,CAAC4C,IAAP,CAAYZ,SAAS,CAACT,IAAI,CAACK,EAAN,CAArB,EAAgCN,OAAhC,CAAwC,UAAUuB,UAAV,EAAsB;QAC5D,IAAIC,cAAc,GAAGd,SAAS,CAACT,IAAI,CAACK,EAAN,CAAT,CAAmBiB,UAAnB,CAArB;QACA,IAAIE,YAAY,GAAG1B,OAAO,CAACwB,UAAD,CAAP,CAAoBtB,IAAvC;QACA,IAAIyB,iBAAiB,GAAGD,YAAY,CAACpB,SAArC;QACA,IAAI,CAACgB,gBAAgB,CAACK,iBAAD,CAArB,EAA0CL,gBAAgB,CAACK,iBAAD,CAAhB,GAAsC,CAAtC;QAC1CL,gBAAgB,CAACK,iBAAD,CAAhB,IAAuCF,cAAvC;MACD,CAND,EAF4B,CAQxB;;MAEJ,IAAIG,SAAS,GAAG,CAACC,QAAjB;MACA,IAAIC,cAAc,GAAG,EAArB;MACAnD,MAAM,CAAC4C,IAAP,CAAYD,gBAAZ,EAA8BrB,OAA9B,CAAsC,UAAUK,SAAV,EAAqB;QACzD,IAAIsB,SAAS,GAAGN,gBAAgB,CAAChB,SAAD,CAAhC,EAA6C;UAC3CsB,SAAS,GAAGN,gBAAgB,CAAChB,SAAD,CAA5B;UACAwB,cAAc,GAAG,CAACxB,SAAD,CAAjB;QACD,CAHD,MAGO,IAAIsB,SAAS,KAAKN,gBAAgB,CAAChB,SAAD,CAAlC,EAA+C;UACpDwB,cAAc,CAACZ,IAAf,CAAoBZ,SAApB;QACD;MACF,CAPD;MAQA,IAAIwB,cAAc,CAACC,MAAf,KAA0B,CAA1B,IAA+BD,cAAc,CAAC,CAAD,CAAd,KAAsB5B,IAAI,CAACI,SAA9D,EAAyE;MACzE,IAAI0B,cAAc,GAAGF,cAAc,CAACG,OAAf,CAAuB/B,IAAI,CAACI,SAA5B,CAArB;MACA,IAAI0B,cAAc,IAAI,CAAtB,EAAyBF,cAAc,CAACI,MAAf,CAAsBF,cAAtB,EAAsC,CAAtC;;MAEzB,IAAIF,cAAc,IAAIA,cAAc,CAACC,MAArC,EAA6C;QAC3CV,OAAO,GAAG,IAAV,CAD2C,CAC3B;;QAEhB,IAAIc,WAAW,GAAGpC,QAAQ,CAACG,IAAI,CAACI,SAAN,CAA1B;QACA,IAAI8B,oBAAoB,GAAGD,WAAW,CAACvC,KAAZ,CAAkBqC,OAAlB,CAA0B/B,IAA1B,CAA3B;QACAiC,WAAW,CAACvC,KAAZ,CAAkBsC,MAAlB,CAAyBE,oBAAzB,EAA+C,CAA/C,EAL2C,CAKQ;;QAEnD,IAAIC,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBV,cAAc,CAACC,MAA1C,CAAhB;QACA,IAAIU,WAAW,GAAG1C,QAAQ,CAAC+B,cAAc,CAACO,SAAD,CAAf,CAA1B;QACAI,WAAW,CAAC7C,KAAZ,CAAkBsB,IAAlB,CAAuBhB,IAAvB;QACAA,IAAI,CAACI,SAAL,GAAiBmC,WAAW,CAAClC,EAA7B;MACD;IACF,CApCD;IAqCA,IAAI,CAACc,OAAL,EAAc,OAAO,OAAP;IACdF,IAAI;EACL,CAzCD;;EA2CA,OAAOA,IAAI,GAAGzB,YAAd,EAA4B;IAC1B,IAAIgD,OAAO,GAAGtB,OAAO,EAArB;;IAEA,IAAIsB,OAAO,KAAK,OAAhB,EAAyB;EAC1B,CA3GqG,CA2GpG;;;EAGF/D,MAAM,CAAC4C,IAAP,CAAYxB,QAAZ,EAAsBE,OAAtB,CAA8B,UAAUK,SAAV,EAAqB;IACjD,IAAIqC,OAAO,GAAG5C,QAAQ,CAACO,SAAD,CAAtB;;IAEA,IAAI,CAACqC,OAAO,CAAC/C,KAAT,IAAkB,CAAC+C,OAAO,CAAC/C,KAAR,CAAcmC,MAArC,EAA6C;MAC3C,OAAOhC,QAAQ,CAACO,SAAD,CAAf;IACD;EACF,CAND,EA9GsG,CAoHlG;;EAEJ,IAAIsC,YAAY,GAAG,EAAnB;EACA,IAAIC,cAAc,GAAG,EAArB;EACA/C,KAAK,CAACG,OAAN,CAAc,UAAU6C,IAAV,EAAgB;IAC5B,IAAIC,MAAM,GAAGD,IAAI,CAACC,MAAlB;IAAA,IACIC,MAAM,GAAGF,IAAI,CAACE,MADlB;IAEA,IAAIC,MAAM,GAAGH,IAAI,CAACrD,kBAAD,CAAJ,IAA4B,CAAzC;IACA,IAAIyD,eAAe,GAAGlD,OAAO,CAAC+C,MAAD,CAAP,CAAgB7C,IAAhB,CAAqBI,SAA3C;IACA,IAAI6C,eAAe,GAAGnD,OAAO,CAACgD,MAAD,CAAP,CAAgB9C,IAAhB,CAAqBI,SAA3C;IACA,IAAI8C,SAAS,GAAG,GAAGC,MAAH,CAAUH,eAAV,EAA2B,KAA3B,EAAkCG,MAAlC,CAAyCF,eAAzC,CAAhB;;IAEA,IAAIN,cAAc,CAACO,SAAD,CAAlB,EAA+B;MAC7BP,cAAc,CAACO,SAAD,CAAd,CAA0BH,MAA1B,IAAoCA,MAApC;MACAJ,cAAc,CAACO,SAAD,CAAd,CAA0BE,KAA1B;IACD,CAHD,MAGO;MACL,IAAIC,OAAO,GAAG;QACZR,MAAM,EAAEG,eADI;QAEZF,MAAM,EAAEG,eAFI;QAGZF,MAAM,EAAEA,MAHI;QAIZK,KAAK,EAAE;MAJK,CAAd;MAMAT,cAAc,CAACO,SAAD,CAAd,GAA4BG,OAA5B;MACAX,YAAY,CAAC1B,IAAb,CAAkBqC,OAAlB;IACD;EACF,CArBD;EAsBA,IAAIC,aAAa,GAAG,EAApB;EACA7E,MAAM,CAAC4C,IAAP,CAAYxB,QAAZ,EAAsBE,OAAtB,CAA8B,UAAUK,SAAV,EAAqB;IACjDkD,aAAa,CAACtC,IAAd,CAAmBnB,QAAQ,CAACO,SAAD,CAA3B;EACD,CAFD;EAGA,OAAO;IACLP,QAAQ,EAAEyD,aADL;IAELZ,YAAY,EAAEA;EAFT,CAAP;AAID,CAtJD;;AAwJA,IAAIa,QAAQ,GAAGnE,gBAAf;AACAT,OAAO,CAACE,OAAR,GAAkB0E,QAAlB"},"metadata":{},"sourceType":"script"}