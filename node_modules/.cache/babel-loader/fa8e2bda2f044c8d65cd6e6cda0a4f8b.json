{"ast":null,"code":"import { ObjectExt, Dom } from '../../util';\nimport { Path, Rectangle, Ellipse } from '../../geometry';\nimport { offset, getStrokeWidth, findShapeNode } from './util';\n/**\n * Places the connection point at the intersection between the\n * edge path end segment and the actual shape of the target magnet.\n */\n\nexport const boundary = function (line, view, magnet, options) {\n  let node;\n  let intersection;\n  const anchor = line.end;\n  const selector = options.selector;\n\n  if (typeof selector === 'string') {\n    node = view.findOne(selector);\n  } else if (Array.isArray(selector)) {\n    node = ObjectExt.getByPath(magnet, selector);\n  } else {\n    node = findShapeNode(magnet);\n  }\n\n  if (!Dom.isSVGGraphicsElement(node)) {\n    if (node === magnet || !Dom.isSVGGraphicsElement(magnet)) {\n      return anchor;\n    }\n\n    node = magnet;\n  }\n\n  const localShape = view.getShapeOfElement(node);\n  const magnetMatrix = view.getMatrixOfElement(node);\n  const translateMatrix = view.getRootTranslatedMatrix();\n  const rotateMatrix = view.getRootRotatedMatrix();\n  const targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n  const localMatrix = targetMatrix.inverse();\n  const localLine = Dom.transformLine(line, localMatrix);\n  const localRef = localLine.start.clone();\n  const data = view.getDataOfElement(node);\n\n  if (options.insideout === false) {\n    if (data.shapeBBox == null) {\n      data.shapeBBox = localShape.bbox();\n    }\n\n    const localBBox = data.shapeBBox;\n\n    if (localBBox != null && localBBox.containsPoint(localRef)) {\n      return anchor;\n    }\n  }\n\n  if (options.extrapolate === true) {\n    localLine.setLength(1e6);\n  } // Caching segment subdivisions for paths\n\n\n  let pathOptions;\n\n  if (Path.isPath(localShape)) {\n    const precision = options.precision || 2;\n\n    if (data.segmentSubdivisions == null) {\n      data.segmentSubdivisions = localShape.getSegmentSubdivisions({\n        precision\n      });\n    }\n\n    pathOptions = {\n      precision,\n      segmentSubdivisions: data.segmentSubdivisions\n    };\n    intersection = localLine.intersect(localShape, pathOptions);\n  } else {\n    intersection = localLine.intersect(localShape);\n  }\n\n  if (intersection) {\n    if (Array.isArray(intersection)) {\n      intersection = localRef.closest(intersection);\n    }\n  } else if (options.sticky === true) {\n    // No intersection, find the closest point instead\n    if (Rectangle.isRectangle(localShape)) {\n      intersection = localShape.getNearestPointToPoint(localRef);\n    } else if (Ellipse.isEllipse(localShape)) {\n      intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOptions);\n    }\n  }\n\n  const cp = intersection ? Dom.transformPoint(intersection, targetMatrix) : anchor;\n  let cpOffset = options.offset || 0;\n\n  if (options.stroked !== false) {\n    if (typeof cpOffset === 'object') {\n      cpOffset = Object.assign({}, cpOffset);\n\n      if (cpOffset.x == null) {\n        cpOffset.x = 0;\n      }\n\n      cpOffset.x += getStrokeWidth(node) / 2;\n    } else {\n      cpOffset += getStrokeWidth(node) / 2;\n    }\n  }\n\n  return offset(cp, line.start, cpOffset);\n};","map":{"version":3,"mappings":"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","names":["ObjectExt","Dom","Path","Rectangle","Ellipse","offset","getStrokeWidth","findShapeNode","boundary","line","view","magnet","options","node","intersection","anchor","end","selector","findOne","Array","isArray","getByPath","isSVGGraphicsElement","localShape","getShapeOfElement","magnetMatrix","getMatrixOfElement","translateMatrix","getRootTranslatedMatrix","rotateMatrix","getRootRotatedMatrix","targetMatrix","multiply","localMatrix","inverse","localLine","transformLine","localRef","start","clone","data","getDataOfElement","insideout","shapeBBox","bbox","localBBox","containsPoint","extrapolate","setLength","pathOptions","isPath","precision","segmentSubdivisions","getSegmentSubdivisions","intersect","closest","sticky","isRectangle","getNearestPointToPoint","isEllipse","intersectsWithLineFromCenterToPoint","closestPoint","cp","transformPoint","cpOffset","stroked","x"],"sourceRoot":"","sources":["../../../src/registry/connection-point/boundary.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}