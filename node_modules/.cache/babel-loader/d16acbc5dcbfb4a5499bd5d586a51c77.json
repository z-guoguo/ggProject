{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exchangeEdges = exports.enterEdge = exports.leaveEdge = exports.initLowLimValues = exports.calcCutValue = exports.initCutValues = void 0;\n\nvar feasible_tree_1 = require(\"./feasible-tree\");\n\nvar util_1 = require(\"./util\");\n\nvar util_2 = require(\"../util\");\n\nvar graphlib_1 = require(\"@antv/graphlib\");\n\nvar preorder = graphlib_1.algorithm.preorder,\n    postorder = graphlib_1.algorithm.postorder;\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\n\nvar networkSimplex = function (og) {\n  var g = (0, util_2.simplify)(og);\n  (0, util_1.longestPath)(g);\n  var t = (0, feasible_tree_1.feasibleTree)(g);\n  (0, exports.initLowLimValues)(t);\n  (0, exports.initCutValues)(t, g);\n  var e;\n  var f;\n\n  while (e = (0, exports.leaveEdge)(t)) {\n    f = (0, exports.enterEdge)(t, g, e);\n    (0, exports.exchangeEdges)(t, g, e, f);\n  }\n};\n/*\n * Initializes cut values for all edges in the tree.\n */\n\n\nvar initCutValues = function (t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);\n  vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n    assignCutValue(t, g, v);\n  });\n};\n\nexports.initCutValues = initCutValues;\n\nvar assignCutValue = function (t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edgeFromArgs(child, parent).cutvalue = (0, exports.calcCutValue)(t, g, child);\n};\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\n\n\nvar calcCutValue = function (t, g, child) {\n  var _a;\n\n  var childLab = t.node(child);\n  var parent = childLab.parent; // True if the child is on the tail end of the edge in the directed graph\n\n  var childIsTail = true; // The graph's view of the tree edge we're inspecting\n\n  var graphEdge = g.edgeFromArgs(child, parent); // The accumulated cut value for the edge between this node and its parent\n\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edgeFromArgs(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n  (_a = g.nodeEdges(child)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n    var isOutEdge = e.v === child;\n    var other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail;\n      var otherWeight = g.edge(e).weight;\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edgeFromArgs(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n  return cutValue;\n};\n\nexports.calcCutValue = calcCutValue;\n\nvar initLowLimValues = function (tree, root) {\n  if (root === void 0) {\n    root = tree.nodes()[0];\n  }\n\n  dfsAssignLowLim(tree, {}, 1, root);\n};\n\nexports.initLowLimValues = initLowLimValues;\n\nvar dfsAssignLowLim = function (tree, visited, nextLim, v, parent) {\n  var _a;\n\n  var low = nextLim;\n  var useNextLim = nextLim;\n  var label = tree.node(v);\n  visited[v] = true;\n  (_a = tree.neighbors(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (w) {\n    if (!visited[w]) {\n      useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w, v);\n    }\n  });\n  label.low = low;\n  label.lim = useNextLim++;\n\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return useNextLim;\n};\n\nvar leaveEdge = function (tree) {\n  return tree.edges().find(function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n};\n\nexports.leaveEdge = leaveEdge;\n\nvar enterEdge = function (t, g, edge) {\n  var v = edge.v;\n  var w = edge.w; // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false; // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = g.edges().filter(function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n  return (0, util_2.minBy)(candidates, function (edge) {\n    return (0, util_1.slack)(g, edge);\n  });\n};\n\nexports.enterEdge = enterEdge;\n\nvar exchangeEdges = function (t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  (0, exports.initLowLimValues)(t);\n  (0, exports.initCutValues)(t, g);\n  updateRanks(t, g);\n};\n\nexports.exchangeEdges = exchangeEdges;\n\nvar updateRanks = function (t, g) {\n  var root = t.nodes().find(function (v) {\n    var _a;\n\n    return !((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.parent);\n  });\n  var vs = preorder(t, root);\n  vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);\n  vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n    var parent = t.node(v).parent;\n    var edge = g.edgeFromArgs(v, parent);\n    var flipped = false;\n\n    if (!edge) {\n      edge = g.edgeFromArgs(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n};\n/*\n * Returns true if the edge is in the tree.\n */\n\n\nvar isTreeEdge = function (tree, u, v) {\n  return tree.hasEdge(u, v);\n};\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\n\n\nvar isDescendant = function (tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n};\n\nexports.default = networkSimplex;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAIQ,YAAQ,GAAgBA,qBAASC,QAAjC;AAAA,IAAUC,SAAS,GAAKF,qBAASE,SAAjC;AAGR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,IAAMC,cAAc,GAAG,UAACC,EAAD,EAAU;EAC/B,IAAMC,CAAC,GAAG,qBAASD,EAAT,CAAV;EACA,wBAASC,CAAT;EACA,IAAMC,CAAC,GAAG,kCAAaD,CAAb,CAAV;EACA,8BAAiBC,CAAjB;EACA,2BAAcA,CAAd,EAAiBD,CAAjB;EAEA,IAAIE,CAAJ;EACA,IAAIC,CAAJ;;EACA,OAAQD,CAAC,GAAG,uBAAUD,CAAV,CAAZ,EAA2B;IACzBE,CAAC,GAAG,uBAAUF,CAAV,EAAaD,CAAb,EAAgBE,CAAhB,CAAJ;IACA,2BAAcD,CAAd,EAAiBD,CAAjB,EAAoBE,CAApB,EAAuBC,CAAvB;EACD;AACF,CAbD;AAeA;;;;;AAGO,IAAMC,aAAa,GAAG,UAACH,CAAD,EAAWD,CAAX,EAAmB;EAC9C,IAAIK,EAAE,GAAGR,SAAS,CAACI,CAAD,EAAIA,CAAC,CAACK,KAAF,EAAJ,CAAlB;EACAD,EAAE,GAAGA,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEE,KAAJ,CAAU,CAAV,EAAa,GAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEC,MAAJ,IAAa,CAA1B,CAAL;EACAH,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEI,OAAJ,CAAY,UAACC,CAAD,EAAU;IACpBC,cAAc,CAACV,CAAD,EAAID,CAAJ,EAAOU,CAAP,CAAd;EACD,CAFD;AAGD,CANM;;AAAME,wBAAaR,aAAb;;AAQb,IAAMO,cAAc,GAAG,UAACV,CAAD,EAAWD,CAAX,EAAqBa,KAArB,EAAkC;EACvD,IAAMC,QAAQ,GAAGb,CAAC,CAACc,IAAF,CAAOF,KAAP,CAAjB;EACA,IAAMG,MAAM,GAAGF,QAAQ,CAACE,MAAxB;EACAf,CAAC,CAACgB,YAAF,CAAeJ,KAAf,EAAsBG,MAAtB,EAA+BE,QAA/B,GAA0C,0BAAajB,CAAb,EAAgBD,CAAhB,EAAmBa,KAAnB,CAA1C;AACD,CAJD;AAMA;;;;;;AAIO,IAAMM,YAAY,GAAG,UAAClB,CAAD,EAAWD,CAAX,EAAqBa,KAArB,EAAkC;;;EAC5D,IAAMC,QAAQ,GAAGb,CAAC,CAACc,IAAF,CAAOF,KAAP,CAAjB;EACA,IAAMG,MAAM,GAAGF,QAAQ,CAACE,MAAxB,CAF4D,CAG5D;;EACA,IAAII,WAAW,GAAG,IAAlB,CAJ4D,CAK5D;;EACA,IAAIC,SAAS,GAAGrB,CAAC,CAACiB,YAAF,CAAeJ,KAAf,EAAsBG,MAAtB,CAAhB,CAN4D,CAO5D;;EACA,IAAIM,QAAQ,GAAG,CAAf;;EAEA,IAAI,CAACD,SAAL,EAAgB;IACdD,WAAW,GAAG,KAAd;IACAC,SAAS,GAAGrB,CAAC,CAACiB,YAAF,CAAeD,MAAf,EAAuBH,KAAvB,CAAZ;EACD;;EAEDS,QAAQ,GAAGD,SAAS,CAACE,MAArB;EAEA,OAAC,CAACC,SAAF,CAAYX,KAAZ,OAAkB,IAAlB,IAAkBY,aAAlB,GAAkB,MAAlB,GAAkBA,GAAEhB,OAAF,CAAU,UAACP,CAAD,EAAE;IAC5B,IAAMwB,SAAS,GAAGxB,CAAC,CAACQ,CAAF,KAAQG,KAA1B;IACA,IAAMc,KAAK,GAAGD,SAAS,GAAGxB,CAAC,CAAC0B,CAAL,GAAS1B,CAAC,CAACQ,CAAlC;;IAEA,IAAIiB,KAAK,KAAKX,MAAd,EAAsB;MACpB,IAAMa,YAAY,GAAGH,SAAS,KAAKN,WAAnC;MACA,IAAMU,WAAW,GAAG9B,CAAC,CAAC+B,IAAF,CAAO7B,CAAP,EAAWqB,MAA/B;MAEAD,QAAQ,IAAIO,YAAY,GAAGC,WAAH,GAAiB,CAACA,WAA1C;;MACA,IAAIE,UAAU,CAAC/B,CAAD,EAAIY,KAAJ,EAAWc,KAAX,CAAd,EAAiC;QAC/B,IAAMM,aAAa,GAAGhC,CAAC,CAACgB,YAAF,CAAeJ,KAAf,EAAsBc,KAAtB,EAA8BT,QAApD;QACAI,QAAQ,IAAIO,YAAY,GAAG,CAACI,aAAJ,GAAoBA,aAA5C;MACD;IACF;EACF,CAdiB,CAAlB;EAgBA,OAAOX,QAAP;AACD,CAlCM;;AAAMV,uBAAYO,YAAZ;;AAoCN,IAAMe,gBAAgB,GAAG,UAACC,IAAD,EAAcC,IAAd,EAA4C;EAA9B;IAAAA,OAAeD,IAAI,CAAC7B,KAAL,GAAa,CAAb,CAAf;EAA8B;;EAC1E+B,eAAe,CAACF,IAAD,EAAO,EAAP,EAAW,CAAX,EAAcC,IAAd,CAAf;AACD,CAFM;;AAAMxB,2BAAgBsB,gBAAhB;;AAIb,IAAMG,eAAe,GAAG,UAACF,IAAD,EAAcG,OAAd,EAAgDC,OAAhD,EAAiE7B,CAAjE,EAA4EM,MAA5E,EAA2F;;;EACjH,IAAMwB,GAAG,GAAGD,OAAZ;EACA,IAAIE,UAAU,GAAGF,OAAjB;EACA,IAAMG,KAAK,GAAGP,IAAI,CAACpB,IAAL,CAAUL,CAAV,CAAd;EAEA4B,OAAO,CAAC5B,CAAD,CAAP,GAAa,IAAb;EACA,UAAI,CAACiC,SAAL,CAAejC,CAAf,OAAiB,IAAjB,IAAiBe,aAAjB,GAAiB,MAAjB,GAAiBA,GAAEhB,OAAF,CAAU,UAACmB,CAAD,EAAE;IAC3B,IAAI,CAACU,OAAO,CAACV,CAAD,CAAZ,EAAiB;MACfa,UAAU,GAAGJ,eAAe,CAACF,IAAD,EAAOG,OAAP,EAAgBG,UAAhB,EAA4Bb,CAA5B,EAA+BlB,CAA/B,CAA5B;IACD;EACF,CAJgB,CAAjB;EAMAgC,KAAK,CAACF,GAAN,GAAYA,GAAZ;EACAE,KAAK,CAACE,GAAN,GAAYH,UAAU,EAAtB;;EACA,IAAIzB,MAAJ,EAAY;IACV0B,KAAK,CAAC1B,MAAN,GAAeA,MAAf;EACD,CAFD,MAEO;IACL;IACA,OAAO0B,KAAK,CAAC1B,MAAb;EACD;;EAED,OAAOyB,UAAP;AACD,CAtBD;;AAwBO,IAAMI,SAAS,GAAG,UAACV,IAAD,EAAY;EACnC,OAAOA,IAAI,CAACW,KAAL,GAAaC,IAAb,CAAkB,UAAC7C,CAAD,EAAE;IACzB,OAAOiC,IAAI,CAACJ,IAAL,CAAU7B,CAAV,EAAcgB,QAAd,GAAyB,CAAhC;EACD,CAFM,CAAP;AAGD,CAJM;;AAAMN,oBAASiC,SAAT;;AAMN,IAAMG,SAAS,GAAG,UAAC/C,CAAD,EAAWD,CAAX,EAAqB+B,IAArB,EAA8B;EACrD,IAAIrB,CAAC,GAAGqB,IAAI,CAACrB,CAAb;EACA,IAAIkB,CAAC,GAAGG,IAAI,CAACH,CAAb,CAFqD,CAIrD;EACA;EACA;;EACA,IAAI,CAAC5B,CAAC,CAACiD,OAAF,CAAUvC,CAAV,EAAakB,CAAb,CAAL,EAAsB;IACpBlB,CAAC,GAAGqB,IAAI,CAACH,CAAT;IACAA,CAAC,GAAGG,IAAI,CAACrB,CAAT;EACD;;EAED,IAAMwC,MAAM,GAAGjD,CAAC,CAACc,IAAF,CAAOL,CAAP,CAAf;EACA,IAAMyC,MAAM,GAAGlD,CAAC,CAACc,IAAF,CAAOa,CAAP,CAAf;EACA,IAAIwB,SAAS,GAAGF,MAAhB;EACA,IAAIG,IAAI,GAAG,KAAX,CAfqD,CAiBrD;EACA;;EACA,IAAKH,MAAM,CAACN,GAAP,GAAyBO,MAAM,CAACP,GAArC,EAAqD;IACnDQ,SAAS,GAAGD,MAAZ;IACAE,IAAI,GAAG,IAAP;EACD;;EAED,IAAMC,UAAU,GAAGtD,CAAC,CAAC8C,KAAF,GAAUS,MAAV,CAAiB,UAACxB,IAAD,EAAK;IACvC,OAAOsB,IAAI,KAAKG,YAAY,CAACvD,CAAD,EAAIA,CAAC,CAACc,IAAF,CAAOgB,IAAI,CAACrB,CAAZ,CAAJ,EAAoB0C,SAApB,CAArB,IACAC,IAAI,KAAKG,YAAY,CAACvD,CAAD,EAAIA,CAAC,CAACc,IAAF,CAAOgB,IAAI,CAACH,CAAZ,CAAJ,EAAoBwB,SAApB,CAD5B;EAED,CAHkB,CAAnB;EAKA,OAAO,kBAAME,UAAN,EAAkB,UAACvB,IAAD,EAAK;IAAO,OAAO,kBAAM/B,CAAN,EAAS+B,IAAT,CAAP;EAAwB,CAAtD,CAAP;AACD,CA9BM;;AAAMnB,oBAASoC,SAAT;;AAgCN,IAAMS,aAAa,GAAG,UAACxD,CAAD,EAAWD,CAAX,EAAqBE,CAArB,EAA8BC,CAA9B,EAAqC;EAChE,IAAMO,CAAC,GAAGR,CAAC,CAACQ,CAAZ;EACA,IAAMkB,CAAC,GAAG1B,CAAC,CAAC0B,CAAZ;EACA3B,CAAC,CAACyD,UAAF,CAAahD,CAAb,EAAgBkB,CAAhB;EACA3B,CAAC,CAAC0D,OAAF,CAAUxD,CAAC,CAACO,CAAZ,EAAeP,CAAC,CAACyB,CAAjB,EAAoB,EAApB;EACA,8BAAiB3B,CAAjB;EACA,2BAAcA,CAAd,EAAiBD,CAAjB;EACA4D,WAAW,CAAC3D,CAAD,EAAID,CAAJ,CAAX;AACD,CARM;;AAAMY,wBAAa6C,aAAb;;AAUb,IAAMG,WAAW,GAAG,UAAC3D,CAAD,EAAWD,CAAX,EAAmB;EACrC,IAAMoC,IAAI,GAAGnC,CAAC,CAACK,KAAF,GAAUyC,IAAV,CAAe,UAACrC,CAAD,EAAE;IAAA;;IAAM,OAAO,EAAC,OAAC,CAACK,IAAF,CAAOL,CAAP,OAAS,IAAT,IAASe,aAAT,GAAS,MAAT,GAASA,GAAET,MAAZ,CAAP;EAA4B,CAAnD,CAAb;EACA,IAAIX,EAAE,GAAGT,QAAQ,CAACK,CAAD,EAAImC,IAAJ,CAAjB;EACA/B,EAAE,GAAGA,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEE,KAAJ,CAAU,CAAV,CAAL;EACAF,EAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEI,OAAJ,CAAY,UAACC,CAAD,EAAU;IACpB,IAAMM,MAAM,GAAGf,CAAC,CAACc,IAAF,CAAOL,CAAP,EAAWM,MAA1B;IACA,IAAIe,IAAI,GAAG/B,CAAC,CAACiB,YAAF,CAAeP,CAAf,EAAkBM,MAAlB,CAAX;IACA,IAAI6C,OAAO,GAAG,KAAd;;IAEA,IAAI,CAAC9B,IAAL,EAAW;MACTA,IAAI,GAAG/B,CAAC,CAACiB,YAAF,CAAeD,MAAf,EAAuBN,CAAvB,CAAP;MACAmD,OAAO,GAAG,IAAV;IACD;;IAED7D,CAAC,CAACe,IAAF,CAAOL,CAAP,EAAWoD,IAAX,GAAkB9D,CAAC,CAACe,IAAF,CAAOC,MAAP,EAAgB8C,IAAhB,IAAyBD,OAAO,GAAG9B,IAAI,CAACgC,MAAR,GAAkB,CAAChC,IAAI,CAACgC,MAAxD,CAAlB;EACD,CAXD;AAYD,CAhBD;AAkBA;;;;;AAGA,IAAM/B,UAAU,GAAG,UAACG,IAAD,EAAc6B,CAAd,EAAyBtD,CAAzB,EAAkC;EACnD,OAAOyB,IAAI,CAACc,OAAL,CAAae,CAAb,EAAgBtD,CAAhB,CAAP;AACD,CAFD;AAIA;;;;;;AAIA,IAAM8C,YAAY,GAAG,UAACrB,IAAD,EAAce,MAAd,EAA2Be,SAA3B,EAAyC;EAC5D,OAAOA,SAAS,CAACzB,GAAV,IAAiBU,MAAM,CAACN,GAAxB,IAA+BM,MAAM,CAACN,GAAP,IAAcqB,SAAS,CAACrB,GAA9D;AACD,CAFD;;AAIAhC,kBAAed,cAAf","names":["graphlib_1","preorder","postorder","networkSimplex","og","g","t","e","f","initCutValues","vs","nodes","slice","length","forEach","v","assignCutValue","exports","child","childLab","node","parent","edgeFromArgs","cutvalue","calcCutValue","childIsTail","graphEdge","cutValue","weight","nodeEdges","_a","isOutEdge","other","w","pointsToHead","otherWeight","edge","isTreeEdge","otherCutValue","initLowLimValues","tree","root","dfsAssignLowLim","visited","nextLim","low","useNextLim","label","neighbors","lim","leaveEdge","edges","find","enterEdge","hasEdge","vLabel","wLabel","tailLabel","flip","candidates","filter","isDescendant","exchangeEdges","removeEdge","setEdge","updateRanks","flipped","rank","minlen","u","rootLabel"],"sourceRoot":"","sources":["../../../../../src/layout/dagre/src/rank/network-simplex.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}