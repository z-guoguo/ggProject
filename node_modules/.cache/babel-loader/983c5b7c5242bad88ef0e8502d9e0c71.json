{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport { __assign, __extends, __spreadArray } from \"tslib\";\nimport EventEmitter from '@antv/event-emitter';\nimport { ext } from '@antv/matrix-util';\nimport { clone, deepMix, each, isPlainObject, isString, debounce } from '@antv/util';\nimport { getDegree, getAdjMatrix as getAdjacentMatrix, Stack, floydWarshall } from '@antv/algorithm';\nimport { lerp, move } from '../util/math';\nimport { dataValidation, singleDataValidation } from '../util/validation';\nimport Global from '../global';\nimport { ItemController, ModeController, StateController, ViewController } from './controller';\nimport { plainCombosToTrees, traverseTree, reconstructTree, traverseTreeUp, getAnimateCfgWithCallback } from '../util/graphic';\nimport Hull from '../item/hull';\nvar transform = ext.transform;\nvar NODE = 'node';\n\nvar AbstractGraph =\n/** @class */\nfunction (_super) {\n  __extends(AbstractGraph, _super);\n\n  function AbstractGraph(cfg) {\n    var _this = _super.call(this) || this;\n    /**\n     * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\n     * @param {GraphData} data 数据\n     */\n\n\n    _this.sortCombos = debounce(function () {\n      var comboSorted = _this.get('comboSorted');\n\n      if (!_this || _this.destroyed || comboSorted) return;\n\n      _this.set('comboSorted', true);\n\n      var depthMap = [];\n      var dataDepthMap = {};\n\n      var comboTrees = _this.get('comboTrees');\n\n      (comboTrees || []).forEach(function (cTree) {\n        traverseTree(cTree, function (child) {\n          if (depthMap[child.depth]) depthMap[child.depth].push(child.id);else depthMap[child.depth] = [child.id];\n          dataDepthMap[child.id] = child.depth;\n          return true;\n        });\n      });\n\n      var edges = _this.getEdges().concat(_this.get('vedges'));\n\n      (edges || []).forEach(function (edgeItem) {\n        var edge = edgeItem.getModel();\n        var sourceDepth = dataDepthMap[edge.source] || 0;\n        var targetDepth = dataDepthMap[edge.target] || 0;\n        var depth = Math.max(sourceDepth, targetDepth);\n        if (depthMap[depth]) depthMap[depth].push(edge.id);else depthMap[depth] = [edge.id];\n      });\n      depthMap.forEach(function (array) {\n        if (!array || !array.length) return;\n\n        for (var i = array.length - 1; i >= 0; i--) {\n          var item = _this.findById(array[i]);\n\n          if (item) item.toFront();\n        }\n      });\n    }, 500, false);\n    _this.cfg = deepMix(_this.getDefaultCfg(), cfg);\n\n    _this.init();\n\n    _this.animating = false;\n    _this.destroyed = false; // 启用 stack 后，实例化 undoStack 和 redoStack\n\n    if (_this.cfg.enabledStack) {\n      // 实例化 undo 和 redo 栈\n      _this.undoStack = new Stack(_this.cfg.maxStep);\n      _this.redoStack = new Stack(_this.cfg.maxStep);\n    }\n\n    return _this;\n  }\n\n  AbstractGraph.prototype.init = function () {\n    this.initCanvas(); // instance controller\n\n    var viewController = new ViewController(this);\n    var modeController = new ModeController(this);\n    var itemController = new ItemController(this);\n    var stateController = new StateController(this);\n    this.set({\n      viewController: viewController,\n      modeController: modeController,\n      itemController: itemController,\n      stateController: stateController\n    }); // 初始化布局机制\n\n    this.initLayoutController(); // 初始化事件机制\n\n    this.initEventController();\n    this.initGroups();\n    /** 初始化插件 */\n\n    this.initPlugins();\n  }; // 初始化所有 Group\n\n\n  AbstractGraph.prototype.initGroups = function () {\n    var canvas = this.get('canvas');\n    if (!canvas) return;\n    var el = canvas.get('el');\n    var _a = (el || {}).id,\n        id = _a === void 0 ? 'g6' : _a;\n    var group = canvas.addGroup({\n      id: \"\".concat(id, \"-root\"),\n      className: Global.rootContainerClassName\n    });\n\n    if (this.get('groupByTypes')) {\n      var edgeGroup = group.addGroup({\n        id: \"\".concat(id, \"-edge\"),\n        className: Global.edgeContainerClassName\n      });\n      var nodeGroup = group.addGroup({\n        id: \"\".concat(id, \"-node\"),\n        className: Global.nodeContainerClassName\n      });\n      var comboGroup = group.addGroup({\n        id: \"\".concat(id, \"-combo\"),\n        className: Global.comboContainerClassName\n      }); // 用于存储自定义的群组\n\n      comboGroup.toBack();\n      this.set({\n        nodeGroup: nodeGroup,\n        edgeGroup: edgeGroup,\n        comboGroup: comboGroup\n      });\n    }\n\n    var delegateGroup = group.addGroup({\n      id: \"\".concat(id, \"-delegate\"),\n      className: Global.delegateContainerClassName\n    });\n    this.set({\n      delegateGroup: delegateGroup\n    });\n    this.set('group', group);\n  }; // eslint-disable-next-line class-methods-use-this\n\n\n  AbstractGraph.prototype.getDefaultCfg = function () {\n    return {\n      /**\n       * Container could be dom object or dom id\n       */\n      container: undefined,\n\n      /**\n       * Canvas width\n       * unit pixel if undefined force fit width\n       */\n      width: undefined,\n\n      /**\n       * Canvas height\n       * unit pixel if undefined force fit height\n       */\n      height: undefined,\n\n      /**\n       * renderer canvas or svg\n       * @type {string}\n       */\n      renderer: 'canvas',\n\n      /**\n       * control graph behaviors\n       */\n      modes: {},\n\n      /**\n       * 注册插件\n       */\n      plugins: [],\n\n      /**\n       * source data\n       */\n      data: {},\n\n      /**\n       * Fit view padding (client scale)\n       */\n      fitViewPadding: 10,\n\n      /**\n       * Minimum scale size\n       */\n      minZoom: 0.02,\n\n      /**\n       * Maxmum scale size\n       */\n      maxZoom: 10,\n\n      /**\n       *  capture events\n       */\n      event: true,\n\n      /**\n       * group node & edges into different graphic groups\n       */\n      groupByTypes: true,\n\n      /**\n       * determine if it's a directed graph\n       */\n      directed: false,\n\n      /**\n       * when data or shape changed, should canvas draw automatically\n       */\n      autoPaint: true,\n\n      /**\n       * store all the node instances\n       */\n      nodes: [],\n\n      /**\n       * store all the edge instances\n       */\n      edges: [],\n\n      /**\n       * store all the combo instances\n       */\n      combos: [],\n\n      /**\n       * store all the edge instances which are virtual edges related to collapsed combo\n       */\n      vedges: [],\n\n      /**\n       * all the instances indexed by id\n       */\n      itemMap: {},\n\n      /**\n       * 边直接连接到节点的中心，不再考虑锚点\n       */\n      linkCenter: false,\n\n      /**\n       * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：\n       * defaultNode: {\n       *  type: 'rect',\n       *  size: [60, 40],\n       *  style: {\n       *    //... 样式配置项\n       *  }\n       * }\n       * 若数据项为 { id: 'node', x: 100, y: 100 }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }\n       * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }\n       */\n      defaultNode: {},\n\n      /**\n       * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode\n       */\n      defaultEdge: {},\n\n      /**\n       * 节点默认样式，也可以添加状态样式\n       * 例如：\n       * const graph = new G6.Graph({\n       *  nodeStateStyles: {\n       *    selected: { fill: '#ccc', stroke: '#666' },\n       *    active: { lineWidth: 2 }\n       *  },\n       *  ...\n       * });\n       *\n       */\n      nodeStateStyles: {},\n\n      /**\n       * 边默认样式，用法同nodeStateStyle\n       */\n      edgeStateStyles: {},\n\n      /**\n       * graph 状态\n       */\n      states: {},\n\n      /**\n       * 是否启用全局动画\n       */\n      animate: false,\n\n      /**\n       * 动画设置,仅在 animate 为 true 时有效\n       */\n      animateCfg: {\n        /**\n         * 帧回调函数，用于自定义节点运动路径，为空时线性运动\n         */\n        onFrame: undefined,\n\n        /**\n         * 动画时长(ms)\n         */\n        duration: 500,\n\n        /**\n         * 指定动画动效\n         */\n        easing: 'easeLinear'\n      },\n      callback: undefined,\n      // 默认不启用 undo & redo 功能\n      enabledStack: false,\n      // 只有当 enabledStack 为 true 时才起作用\n      maxStep: 10,\n      // 存储图上的 tooltip dom，方便销毁\n      tooltips: []\n    };\n  };\n  /**\n   * 将值设置到 this.cfg 变量上面\n   * @param key 键 或 对象值\n   * @param val 值\n   */\n\n\n  AbstractGraph.prototype.set = function (key, val) {\n    if (isPlainObject(key)) {\n      this.cfg = __assign(__assign({}, this.cfg), key);\n    } else {\n      this.cfg[key] = val;\n    }\n\n    if (key === 'enabledStack' && val && !this.undoStack && !this.redoStack) {\n      this.undoStack = new Stack(this.cfg.maxStep);\n      this.redoStack = new Stack(this.cfg.maxStep);\n    }\n\n    return this;\n  };\n  /**\n   * 获取 this.cfg 中的值\n   * @param key 键\n   */\n\n\n  AbstractGraph.prototype.get = function (key) {\n    var _a;\n\n    return (_a = this.cfg) === null || _a === void 0 ? void 0 : _a[key];\n  };\n  /**\n   * 获取 graph 的根图形分组\n   * @return 根 group\n   */\n\n\n  AbstractGraph.prototype.getGroup = function () {\n    return this.get('group');\n  };\n  /**\n   * 获取 graph 的 DOM 容器\n   * @return DOM 容器\n   */\n\n\n  AbstractGraph.prototype.getContainer = function () {\n    return this.get('container');\n  };\n  /**\n   * 获取 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.getMinZoom = function () {\n    return this.get('minZoom');\n  };\n  /**\n   * 设置 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.setMinZoom = function (ratio) {\n    return this.set('minZoom', ratio);\n  };\n  /**\n   * 获取 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.getMaxZoom = function () {\n    return this.get('maxZoom');\n  };\n  /**\n   * 设置 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.setMaxZoom = function (ratio) {\n    return this.set('maxZoom', ratio);\n  };\n  /**\n   * 获取 graph 的宽度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getWidth = function () {\n    return this.get('width');\n  };\n  /**\n   * 获取 graph 的高度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getHeight = function () {\n    return this.get('height');\n  };\n  /**\n   * 清理元素多个状态\n   * @param {string|Item} item 元素id或元素实例\n   * @param {string[]} states 状态\n   */\n\n\n  AbstractGraph.prototype.clearItemStates = function (item, states) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n\n    if (!states) {\n      states = item.get('states');\n    }\n\n    itemController.clearItemStates(item, states);\n    var stateController = this.get('stateController');\n    stateController.updateStates(item, states, false);\n  };\n  /**\n   * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\n   * 若是自定义节点切在各种状态下\n   * graph.node(node => {\n   *  return {\n   *    type: 'rect',\n   *    label: node.id,\n   *    style: { fill: '#666' },\n   *    stateStyles: {\n   *       selected: { fill: 'blue' },\n   *       custom: { fill: 'green' }\n   *     }\n   *   }\n   * });\n   * @param {function} nodeFn 指定每个节点样式\n   */\n\n\n  AbstractGraph.prototype.node = function (nodeFn) {\n    if (typeof nodeFn === 'function') {\n      this.set('nodeMapper', nodeFn);\n    }\n  };\n  /**\n   * 设置各个边样式\n   * @param {function} edgeFn 指定每个边的样式,用法同 node\n   */\n\n\n  AbstractGraph.prototype.edge = function (edgeFn) {\n    if (typeof edgeFn === 'function') {\n      this.set('edgeMapper', edgeFn);\n    }\n  };\n  /**\n   * 设置各个 combo 的配置\n   * @param comboFn\n   */\n\n\n  AbstractGraph.prototype.combo = function (comboFn) {\n    if (typeof comboFn === 'function') {\n      this.set('comboMapper', comboFn);\n    }\n  };\n  /**\n   * 根据 ID 查询图元素实例\n   * @param id 图元素 ID\n   */\n\n\n  AbstractGraph.prototype.findById = function (id) {\n    return this.get('itemMap')[id];\n  };\n  /**\n   * 根据对应规则查找单个元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge | group)\n   * @param {(item: T, index: number) => T} fn 指定规则\n   * @return {T} 元素实例\n   */\n\n\n  AbstractGraph.prototype.find = function (type, fn) {\n    var result;\n    var items = this.get(\"\".concat(type, \"s\")); // eslint-disable-next-line consistent-return\n\n    each(items, function (item, i) {\n      if (fn(item, i)) {\n        result = item;\n        return result;\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有满足规则的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} fn 指定规则\n   * @return {array} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAll = function (type, fn) {\n    var result = [];\n    each(this.get(\"\".concat(type, \"s\")), function (item, i) {\n      if (fn(item, i)) {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有处于指定状态的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} state 状态\n   * @return {object} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAllByState = function (type, state, additionalFilter) {\n    if (additionalFilter) {\n      return this.findAll(type, function (item) {\n        return item.hasState(state) && additionalFilter(item);\n      });\n    } else {\n      return this.findAll(type, function (item) {\n        return item.hasState(state);\n      });\n    }\n  };\n  /**\n   * 平移画布\n   * @param dx 水平方向位移\n   * @param dy 垂直方向位移\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.translate = function (dx, dy, animate, animateCfg) {\n    var _this = this;\n\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix());\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    if (animate) {\n      var animateConfig = getAnimateCfgWithCallback({\n        animateCfg: animateCfg,\n        callback: function callback() {\n          return _this.emit('viewportchange', {\n            action: 'translate',\n            matrix: group.getMatrix()\n          });\n        }\n      });\n      move(group, {\n        x: group.getCanvasBBox().x + dx,\n        y: group.getCanvasBBox().y + dy\n      }, animate, animateConfig || {\n        duration: 500,\n        easing: 'easeCubic'\n      });\n    } else {\n      matrix = transform(matrix, [['t', dx, dy]]);\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'translate',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n  };\n  /**\n   * 平移画布到某点\n   * @param {number} x 水平坐标\n   * @param {number} y 垂直坐标\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.moveTo = function (x, y, animate, animateCfg) {\n    var group = this.get('group');\n    move(group, {\n      x: x,\n      y: y\n    }, animate, animateCfg || {\n      duration: 500,\n      easing: 'easeCubic'\n    });\n    this.emit('viewportchange', {\n      action: 'move',\n      matrix: group.getMatrix()\n    });\n  };\n  /**\n   * 调整视口适应视图\n   * @param {object} padding 四周围边距\n   * @param {FitViewRules} rules fitView的规则\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.fitView = function (padding, rules, animate, animateCfg) {\n    if (padding) {\n      this.set('fitViewPadding', padding);\n    }\n\n    var viewController = this.get('viewController');\n\n    if (rules) {\n      viewController.fitViewByRules(rules, animate, animateCfg);\n    } else {\n      viewController.fitView(animate, animateCfg);\n    }\n\n    this.autoPaint();\n  };\n  /**\n   * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.fitCenter = function (animate, animateCfg) {\n    var viewController = this.get('viewController');\n    viewController.fitCenter(animate, animateCfg);\n    this.autoPaint();\n  };\n  /**\n   * 新增行为\n   * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\n   * @param {string | string[]} modes 添加到对应的模式\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.addBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, true);\n    return this;\n  };\n  /**\n   * 移除行为\n   * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\n   * @param {string | string[]} modes 从指定的模式中移除\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.removeBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, false);\n    return this;\n  };\n  /**\n   * 更新行为参数\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.updateBehavior = function (behavior, newCfg, mode) {\n    var modeController = this.get('modeController');\n    modeController.updateBehavior(behavior, newCfg, mode);\n    return this;\n  };\n  /**\n   * 伸缩窗口\n   * @param ratio 伸缩比例\n   * @param center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n\n\n  AbstractGraph.prototype.zoom = function (ratio, center, animate, animateCfg) {\n    var _this = this;\n\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix()) || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var minZoom = this.get('minZoom');\n    var maxZoom = this.get('maxZoom');\n    var currentZoom = this.getZoom() || 1;\n    var targetZoom = currentZoom * ratio;\n    var finalRatio = ratio;\n    var failed = false;\n\n    if (minZoom && targetZoom < minZoom) {\n      finalRatio = minZoom / currentZoom;\n      failed = true;\n    } else if (maxZoom && targetZoom > maxZoom) {\n      finalRatio = maxZoom / currentZoom;\n      failed = true;\n    }\n\n    if (center) {\n      matrix = transform(matrix, [['t', -center.x, -center.y], ['s', finalRatio, finalRatio], ['t', center.x, center.y]]);\n    } else {\n      matrix = transform(matrix, [['s', finalRatio, finalRatio]]);\n    }\n\n    if (animate) {\n      // Clone the original matrix to perform the animation\n      var aniMatrix_1 = clone(group.getMatrix());\n\n      if (!aniMatrix_1) {\n        aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      }\n\n      var initialRatio_1 = aniMatrix_1[0];\n      var targetRatio_1 = initialRatio_1 * finalRatio;\n      var animateConfig = getAnimateCfgWithCallback({\n        animateCfg: animateCfg,\n        callback: function callback() {\n          return _this.emit('viewportchange', {\n            action: 'zoom',\n            matrix: group.getMatrix()\n          });\n        }\n      });\n      group.animate(function (ratio) {\n        if (ratio === 1) {\n          // Reuse the first transformation\n          aniMatrix_1 = matrix;\n        } else {\n          var scale = lerp(initialRatio_1, targetRatio_1, ratio) / aniMatrix_1[0];\n\n          if (center) {\n            aniMatrix_1 = transform(aniMatrix_1, [['t', -center.x, -center.y], ['s', scale, scale], ['t', center.x, center.y]]);\n          } else {\n            aniMatrix_1 = transform(aniMatrix_1, [['s', scale, scale]]);\n          }\n        }\n\n        return {\n          matrix: aniMatrix_1\n        };\n      }, animateConfig);\n    } else {\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'zoom',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n\n    return !failed;\n  };\n  /**\n   * 伸缩视口到一固定比例\n   * @param {number} toRatio 伸缩比例\n   * @param {Point} center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n\n\n  AbstractGraph.prototype.zoomTo = function (toRatio, center, animate, animateCfg) {\n    var ratio = toRatio / this.getZoom();\n    return this.zoom(ratio, center, animate, animateCfg);\n  };\n  /**\n   * 将元素移动到视口中心\n   * @param {Item} item 指定元素\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.focusItem = function (item, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    var isAnimate = false;\n    if (animate) isAnimate = true;else if (animate === undefined) isAnimate = this.get('animate');\n    var curAniamteCfg = {};\n    if (animateCfg) curAniamteCfg = animateCfg;else if (animateCfg === undefined) curAniamteCfg = this.get('animateCfg');\n    viewController.focus(item, isAnimate, curAniamteCfg);\n    this.autoPaint();\n  };\n  /**\n   * 自动重绘\n   * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\n   */\n\n\n  AbstractGraph.prototype.autoPaint = function () {\n    if (this.get('autoPaint')) {\n      this.paint();\n    }\n  };\n  /**\n   * 仅画布重新绘制\n   */\n\n\n  AbstractGraph.prototype.paint = function () {\n    this.emit('beforepaint');\n    this.get('canvas').draw();\n    this.emit('afterpaint');\n  };\n  /**\n   * 将屏幕坐标转换为视口坐标\n   * @param {number} clientX 屏幕x坐标\n   * @param {number} clientY 屏幕y坐标\n   * @return {Point} 视口坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByClient = function (clientX, clientY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByClient(clientX, clientY);\n  };\n  /**\n   * 将绘制坐标转换为屏幕坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {Point} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getClientByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getClientByPoint(x, y);\n  };\n  /**\n   * 将画布坐标转换为绘制坐标\n   * @param {number} canvasX 画布 x 坐标\n   * @param {number} canvasY 画布 y 坐标\n   * @return {object} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByCanvas(canvasX, canvasY);\n  };\n  /**\n   * 将绘制坐标转换为画布坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {object} 画布坐标\n   */\n\n\n  AbstractGraph.prototype.getCanvasByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getCanvasByPoint(x, y);\n  };\n  /**\n   * 获取图内容的中心绘制坐标\n   * @return {object} 中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getGraphCenterPoint = function () {\n    var bbox = this.get('group').getCanvasBBox();\n    return {\n      x: (bbox.minX + bbox.maxX) / 2,\n      y: (bbox.minY + bbox.maxY) / 2\n    };\n  };\n  /**\n   * 获取视口中心绘制坐标\n   * @return {object} 视口中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getViewPortCenterPoint = function () {\n    return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);\n  };\n  /**\n   * 显示元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.showItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, true);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.nodes = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.edges = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.combos = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 隐藏元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.hideItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, false);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.nodes = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.edges = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.combos = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 刷新元素\n   * @param {string|object} item 元素id或元素实例\n   */\n\n\n  AbstractGraph.prototype.refreshItem = function (item) {\n    var itemController = this.get('itemController');\n    itemController.refreshItem(item);\n  };\n  /**\n   * 设置是否在更新/刷新后自动重绘\n   * @param {boolean} auto 自动重绘\n   */\n\n\n  AbstractGraph.prototype.setAutoPaint = function (auto) {\n    var self = this;\n    self.set('autoPaint', auto);\n    var canvas = self.get('canvas');\n    canvas.set('autoDraw', auto);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.remove = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.removeItem(item, stack);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.removeItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var nodeItem = item;\n    if (isString(item)) nodeItem = this.findById(item);\n\n    if (!nodeItem && isString(item)) {\n      console.warn(\"The item \".concat(item, \" to be removed does not exist!\"));\n    } else if (nodeItem) {\n      var type = '';\n      if (nodeItem.getType) type = nodeItem.getType(); // 将删除的元素入栈\n\n      if (stack && this.get('enabledStack')) {\n        var deletedModel = __assign(__assign({}, nodeItem.getModel()), {\n          itemType: type\n        });\n\n        var before = {};\n\n        switch (type) {\n          case 'node':\n            {\n              before.nodes = [deletedModel];\n              before.edges = [];\n              var edges = nodeItem.getEdges();\n\n              for (var i = edges.length - 1; i >= 0; i--) {\n                before.edges.push(__assign(__assign({}, edges[i].getModel()), {\n                  itemType: 'edge'\n                }));\n              }\n\n              break;\n            }\n\n          case 'edge':\n            before.edges = [deletedModel];\n            break;\n\n          case 'combo':\n            before.combos = [deletedModel];\n            break;\n\n          default:\n            break;\n        }\n\n        this.pushStack('delete', {\n          before: before,\n          after: {}\n        });\n      }\n\n      if (type === 'node') {\n        var model = nodeItem.getModel(); // 如果删除的是节点，且该节点存在于某个 Combo 中，则需要先将 node 从 combo 中移除，否则删除节点后，操作 combo 会出错\n\n        if (model.comboId) {\n          this.updateComboTree(nodeItem, undefined, false);\n        }\n      }\n\n      var itemController = this.get('itemController');\n      itemController.removeItem(nodeItem);\n\n      if (type === 'combo') {\n        var newComboTrees = reconstructTree(this.get('comboTrees'));\n        this.set('comboTrees', newComboTrees);\n      }\n    }\n  };\n\n  AbstractGraph.prototype.innerAddItem = function (type, model, itemController) {\n    var _this = this; // 添加节点、边或combo之前，先验证数据是否符合规范\n\n\n    if (!singleDataValidation(type, model)) {\n      return false;\n    }\n\n    if (model.id && this.findById(model.id)) {\n      console.warn(\"This item exists already. Be sure the id %c\".concat(model.id, \"%c is unique.\"), 'font-size: 20px; color: red;', '');\n      return;\n    }\n\n    var item;\n    var comboTrees = this.get('comboTrees') || [];\n\n    if (type === 'combo') {\n      var itemMap_1 = this.get('itemMap');\n      var foundParent_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundParent_1) return; // terminate the forEach after the tree containing the item is done\n\n        traverseTreeUp(ctree, function (child) {\n          // find the parent\n          if (model.parentId === child.id) {\n            foundParent_1 = true;\n\n            var newCombo = __assign({\n              id: model.id,\n              depth: child.depth + 2\n            }, model);\n\n            if (child.children) child.children.push(newCombo);else child.children = [newCombo];\n            model.depth = newCombo.depth;\n            item = itemController.addItem(type, model);\n          }\n\n          var childItem = itemMap_1[child.id]; // after the parent is found, update all the ancestors\n\n          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === 'combo') {\n            itemController.updateCombo(childItem, child.children);\n          }\n\n          return true;\n        });\n      }); // if the parent is not found, add it to the root\n\n      if (!foundParent_1) {\n        var newCombo = __assign({\n          id: model.id,\n          depth: 0\n        }, model);\n\n        model.depth = newCombo.depth;\n        comboTrees.push(newCombo);\n        item = itemController.addItem(type, model);\n      }\n\n      this.set('comboTrees', comboTrees);\n\n      if (model.collapsed) {\n        setTimeout(function () {\n          if (item && !item.destroyed) {\n            _this.collapseCombo(item, false);\n\n            _this.updateCombo(item);\n          }\n        }, 0);\n      }\n    } else if (type === 'node' && isString(model.comboId) && comboTrees) {\n      var parentCombo = this.findById(model.comboId);\n\n      if (parentCombo && parentCombo.getType && parentCombo.getType() !== 'combo') {\n        console.warn(\"'\".concat(model.comboId, \"' is not a id of a combo in the graph, the node will be added without combo.\"));\n      }\n\n      item = itemController.addItem(type, model);\n      var itemMap_2 = this.get('itemMap');\n      var foundParent_2 = false,\n          foundNode_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundNode_1 || foundParent_2) return; // terminate the forEach\n\n        traverseTreeUp(ctree, function (child) {\n          if (child.id === model.id) {\n            // if the item exists in the tree already, terminate\n            foundNode_1 = true;\n            return false;\n          }\n\n          if (model.comboId === child.id && !foundNode_1) {\n            // found the parent, add the item to the children of its parent in the tree\n            foundParent_2 = true;\n            var cloneNode = clone(model);\n            cloneNode.itemType = 'node';\n            if (child.children) child.children.push(cloneNode);else child.children = [cloneNode];\n            cloneNode.depth = child.depth + 1;\n          } // update the size of all the ancestors\n\n\n          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === 'combo') {\n            itemController.updateCombo(itemMap_2[child.id], child.children);\n          }\n\n          return true;\n        });\n      });\n    } else {\n      item = itemController.addItem(type, model);\n    }\n\n    if (type === 'node' && model.comboId || type === 'combo' && model.parentId) {\n      // add the combo to the parent's children array\n      var parentCombo = this.findById(model.comboId || model.parentId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() === 'combo') parentCombo.addChild(item);\n    }\n\n    return item;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.addItem = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController');\n    var item = this.innerAddItem(type, model, itemController);\n\n    if (item === false || item === true) {\n      return item;\n    }\n\n    var combos = this.get('combos');\n\n    if (combos && combos.length > 0) {\n      this.sortCombos();\n    }\n\n    this.autoPaint();\n\n    if (stack && this.get('enabledStack')) {\n      var addedModel = __assign(__assign({}, item.getModel()), {\n        itemType: type\n      });\n\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          after.nodes = [addedModel];\n          break;\n\n        case 'edge':\n          after.edges = [addedModel];\n          break;\n\n        case 'combo':\n          after.combos = [addedModel];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('add', {\n        before: {},\n        after: after\n      });\n    }\n\n    return item;\n  };\n\n  AbstractGraph.prototype.addItems = function (items, stack, sortCombo) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController');\n    var returnItems = []; // 1. add anything that is not an edge.\n    // Add undefined as a placeholder for the next cycle. This way we return items matching the input order\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item.type !== 'edge' && item.type !== 'vedge') {\n        returnItems.push(this.innerAddItem(item.type, item.model, itemController));\n      } else {\n        returnItems.push(undefined);\n      }\n    } // 2. add all the edges\n\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item.type === 'edge' || item.type === 'vedge') {\n        returnItems[i] = this.innerAddItem(item.type, item.model, itemController);\n      }\n    }\n\n    if (sortCombo) {\n      var combos = this.get('combos');\n\n      if (combos && combos.length > 0) {\n        this.sortCombos();\n      }\n    }\n\n    this.autoPaint();\n\n    if (stack && this.get('enabledStack')) {\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n\n      for (var i = 0; i < items.length; i++) {\n        var type = items[i].type;\n        var returnItem = returnItems[i];\n\n        if (!!returnItem && returnItem !== true) {\n          var addedModel = __assign(__assign({}, returnItem.getModel()), {\n            itemType: type\n          });\n\n          switch (type) {\n            case 'node':\n              after.nodes.push(addedModel);\n              break;\n\n            case 'edge':\n              after.edges.push(addedModel);\n              break;\n\n            case 'combo':\n              after.combos.push(addedModel);\n              break;\n\n            default:\n              break;\n          }\n        }\n      }\n\n      this.pushStack('addItems', {\n        before: {},\n        after: after\n      });\n    }\n\n    return returnItems;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.add = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    return this.addItem(type, model, stack, sortCombo);\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   */\n\n\n  AbstractGraph.prototype.updateItem = function (item, cfg, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var currentItem;\n\n    if (isString(item)) {\n      currentItem = this.findById(item);\n    } else {\n      currentItem = item;\n    }\n\n    var UnupdateModel = clone(currentItem.getModel());\n    var type = '';\n    if (currentItem.getType) type = currentItem.getType();\n\n    var states = __spreadArray([], currentItem.getStates(), true);\n\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, false);\n      });\n    }\n\n    itemController.updateItem(currentItem, cfg);\n\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, true);\n      });\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var before = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n\n      var afterModel = __assign({\n        id: UnupdateModel.id\n      }, cfg);\n\n      switch (type) {\n        case 'node':\n          before.nodes.push(UnupdateModel);\n          after.nodes.push(afterModel);\n          break;\n\n        case 'edge':\n          before.edges.push(UnupdateModel);\n          after.edges.push(afterModel);\n          break;\n\n        case 'combo':\n          before.combos.push(UnupdateModel);\n          after.combos.push(afterModel);\n          break;\n\n        default:\n          break;\n      }\n\n      if (type === 'node') {\n        before.nodes.push(UnupdateModel);\n      }\n\n      this.pushStack('update', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.update = function (item, cfg, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.updateItem(item, cfg, stack);\n  };\n  /**\n   * 设置元素状态\n   * @param {Item} item 元素id或元素实例\n   * @param {string} state 状态名称\n   * @param {string | boolean} value 是否启用状态 或 状态值\n   */\n\n\n  AbstractGraph.prototype.setItemState = function (item, state, value) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n    itemController.setItemState(item, state, value);\n    var stateController = this.get('stateController');\n\n    if (isString(value)) {\n      stateController.updateState(item, \"\".concat(state, \":\").concat(value), true);\n    } else {\n      stateController.updateState(item, state, value);\n    }\n  };\n  /**\n   * 将指定状态的优先级提升为最高优先级\n   * @param {Item} item 元素id或元素实例\n   * @param state 状态名称\n   */\n\n\n  AbstractGraph.prototype.priorityState = function (item, state) {\n    var itemController = this.get('itemController');\n    itemController.priorityState(item, state);\n  };\n  /**\n   * 设置视图初始化数据\n   * @param {GraphData} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.data = function (data) {\n    dataValidation(data);\n    this.set('data', data);\n  };\n  /**\n   * 根据data接口的数据渲染视图\n   */\n\n\n  AbstractGraph.prototype.render = function () {\n    var self = this;\n    this.set('comboSorted', false);\n    var data = this.get('data');\n\n    if (this.get('enabledStack')) {\n      // render 之前清空 redo 和 undo 栈\n      this.clearStack();\n    }\n\n    if (!data) {\n      throw new Error('data must be defined first');\n    }\n\n    var _a = data.nodes,\n        nodes = _a === void 0 ? [] : _a,\n        _b = data.edges,\n        edges = _b === void 0 ? [] : _b,\n        _c = data.combos,\n        combos = _c === void 0 ? [] : _c;\n    this.clear(true);\n    this.emit('beforerender');\n    self.addItems(nodes.map(function (node) {\n      return {\n        type: 'node',\n        model: node\n      };\n    }), false, false); // process the data to tree structure\n\n    if ((combos === null || combos === void 0 ? void 0 : combos.length) !== 0) {\n      var comboTrees = plainCombosToTrees(combos, nodes);\n      this.set('comboTrees', comboTrees); // add combos\n\n      self.addCombos(combos);\n    }\n\n    self.addItems(edges.map(function (edge) {\n      return {\n        type: 'edge',\n        model: edge\n      };\n    }), false, false);\n    var animate = self.get('animate');\n\n    if (self.get('fitView') || self.get('fitCenter')) {\n      self.set('animate', false);\n    } // layout\n\n\n    var layoutController = self.get('layoutController');\n\n    if (layoutController) {\n      layoutController.layout(success);\n      if (this.destroyed) return;\n    } else {\n      success();\n    } // 将在 onLayoutEnd 中被调用\n\n\n    function success() {\n      // 自底向上将 collapsed 的 combo 合起\n      (self.get('comboTrees') || []).forEach(function (ctree) {\n        traverseTreeUp(ctree, function (child) {\n          var item = self.findById(child.id);\n\n          if (item.getType() === 'combo' && child.collapsed) {\n            self.collapseCombo(child.id, false);\n            self.updateCombo(item);\n          }\n\n          return true;\n        });\n      }); // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\n\n      if (self.get('fitView')) {\n        self.fitView();\n      } else if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n\n      self.autoPaint();\n      self.emit('afterrender');\n\n      if (self.get('fitView') || self.get('fitCenter')) {\n        self.set('animate', animate);\n      }\n\n      setTimeout(function () {\n        var _a;\n\n        (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n          combo.set('animate', true);\n        });\n      }, 0);\n    }\n\n    if (!this.get('groupByTypes')) {\n      if (combos && combos.length !== 0) {\n        this.sortCombos();\n      } else {\n        // 为提升性能，选择数量少的进行操作\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\n          var nodesArr = this.getNodes(); // 遍历节点实例，将所有节点提前。\n\n          nodesArr.forEach(function (node) {\n            node.toFront();\n          });\n        } else {\n          var edgesArr = this.getEdges(); // 遍历节点实例，将所有节点提前。\n\n          edgesArr.forEach(function (edge) {\n            edge.toBack();\n          });\n        }\n      }\n    }\n\n    if (this.get('enabledStack')) {\n      this.pushStack('render');\n    }\n  };\n  /**\n   * 接收数据进行渲染\n   * @Param {Object} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.read = function (data) {\n    this.data(data);\n    this.render();\n  }; // 比较item\n\n\n  AbstractGraph.prototype.diffItems = function (type, items, models) {\n    var self = this;\n    var item;\n    var itemMap = this.get('itemMap');\n    each(models, function (model) {\n      item = itemMap[model.id];\n\n      if (item) {\n        if (self.get('animate') && type === NODE) {\n          var containerMatrix = item.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          item.set('originAttrs', {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          });\n        }\n\n        self.updateItem(item, model, false);\n      } else {\n        item = self.addItem(type, model, false);\n      }\n\n      if (item) items[\"\".concat(type, \"s\")].push(item);\n    });\n  };\n  /**\n   * 更改源数据，根据新数据重新渲染视图\n   * @param {GraphData | TreeGraphData} data 源数据\n   * @param {boolean} 是否入栈，默认为true\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeData = function (propsData, stack) {\n    var _this = this;\n\n    var _a;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n    var data = propsData || self.get('data');\n\n    if (!dataValidation(data)) {\n      return this;\n    }\n\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('changedata', {\n        before: self.save(),\n        after: data\n      });\n    }\n\n    this.set('comboSorted', false); // 删除 hulls\n\n    this.removeHulls(); // 更改数据源后，取消所有状态\n\n    this.getNodes().map(function (node) {\n      return self.clearItemStates(node);\n    });\n    this.getEdges().map(function (edge) {\n      return self.clearItemStates(edge);\n    });\n    var canvas = this.get('canvas');\n    var localRefresh = canvas.get('localRefresh');\n    canvas.set('localRefresh', false);\n\n    if (!self.get('data')) {\n      self.data(data);\n      self.render();\n    }\n\n    var itemMap = this.get('itemMap');\n    var items = {\n      nodes: [],\n      edges: []\n    };\n    var combosData = data.combos;\n\n    if (combosData) {\n      var comboTrees = plainCombosToTrees(combosData, data.nodes);\n      this.set('comboTrees', comboTrees);\n    } else {\n      this.set('comboTrees', []);\n    }\n\n    this.diffItems('node', items, data.nodes);\n    each(itemMap, function (item, id) {\n      itemMap[id].getModel().depth = 0;\n      if (item.getType && item.getType() === 'edge') return;\n\n      if (item.getType && item.getType() === 'combo') {\n        delete itemMap[id];\n        item.destroy();\n      } else if (items.nodes.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    }); // clear the destroyed combos here to avoid removing sub nodes before removing the parent combo\n\n    var comboItems = this.getCombos();\n    var combosLength = comboItems.length;\n\n    for (var i = combosLength - 1; i >= 0; i--) {\n      if (comboItems[i].destroyed) {\n        comboItems.splice(i, 1);\n      }\n    } // process the data to tree structure\n\n\n    if (combosData) {\n      // add combos\n      self.addCombos(combosData);\n\n      if (!this.get('groupByTypes')) {\n        this.sortCombos();\n      }\n    }\n\n    this.diffItems('edge', items, data.edges);\n    each(itemMap, function (item, id) {\n      if (item.getType && (item.getType() === 'node' || item.getType() === 'combo')) return;\n\n      if (items.edges.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    }); // 自底向上将 collapsed 的 combo 合起\n\n    (this.get('comboTrees') || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        var item = _this.findById(child.id);\n\n        if (item.getType() === 'combo' && child.collapsed) {\n          _this.collapseCombo(child.id, false);\n        }\n\n        return true;\n      });\n    });\n    this.set({\n      nodes: items.nodes,\n      edges: items.edges\n    });\n    var layoutController = this.get('layoutController');\n\n    if (layoutController) {\n      layoutController.changeData(function () {\n        setTimeout(function () {\n          var _a;\n\n          (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n            combo.set('animate', true);\n          });\n        }, 0);\n      });\n\n      if (self.get('animate') && !layoutController.getLayoutType()) {\n        // 如果没有指定布局\n        self.positionsAnimate();\n        (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n          return combo.set('animate', true);\n        });\n      } else {\n        self.autoPaint();\n      }\n    }\n\n    setTimeout(function () {\n      canvas.set('localRefresh', localRefresh);\n    }, 16);\n    return this;\n  };\n  /**\n   * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\n   * @param {ComboConfig[]} combos 平铺的 combos 数据\n   */\n\n\n  AbstractGraph.prototype.addCombos = function (combos) {\n    var self = this;\n    var comboTrees = self.get('comboTrees');\n    var itemController = this.get('itemController');\n    itemController.addCombos(comboTrees, combos);\n  };\n  /**\n   * 根据已经存在的节点或 combo 创建新的 combo\n   * @param combo combo ID 或 Combo 配置\n   * @param children 添加到 Combo 中的元素，包括节点和 combo\n   */\n\n\n  AbstractGraph.prototype.createCombo = function (combo, children) {\n    var _this = this;\n\n    this.set('comboSorted', false); // step 1: 创建新的 Combo\n\n    var comboId = '';\n    var comboConfig;\n    if (!combo) return;\n\n    if (isString(combo)) {\n      comboId = combo;\n      comboConfig = {\n        id: combo\n      };\n    } else {\n      comboId = combo.id;\n\n      if (!comboId) {\n        console.warn('Create combo failed. Please assign a unique string id for the adding combo.');\n        return;\n      }\n\n      comboConfig = combo;\n    } // step2: 更新 children，根据类型添加 comboId 或 parentId\n\n\n    var trees = children.map(function (elementId) {\n      var item = _this.findById(elementId);\n\n      var model = item.getModel();\n      var type = '';\n      if (item.getType) type = item.getType();\n      var cItem = {\n        id: item.getID(),\n        itemType: type\n      };\n\n      if (type === 'combo') {\n        cItem.parentId = comboId;\n        model.parentId = comboId;\n      } else if (type === 'node') {\n        cItem.comboId = comboId;\n        model.comboId = comboId;\n      }\n\n      return cItem;\n    });\n    comboConfig.children = trees; // step 3: 添加 Combo，addItem 时会将子将元素添加到 Combo 中\n\n    this.addItem('combo', comboConfig, false);\n    this.set('comboSorted', false); // step4: 更新 comboTrees 结构\n\n    var comboTrees = this.get('comboTrees');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (child.id === comboId) {\n          child.itemType = 'combo';\n          child.children = trees;\n          return false;\n        }\n\n        return true;\n      });\n    });\n\n    if (comboTrees) {\n      this.sortCombos();\n    }\n  };\n  /**\n   * 解散 combo\n   * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\n   */\n\n\n  AbstractGraph.prototype.uncombo = function (combo) {\n    var _this = this;\n\n    var _a;\n\n    var self = this;\n    var comboItem = combo;\n\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item is not a combo!');\n      return;\n    }\n\n    var parentId = comboItem.getModel().parentId;\n    var comboTrees = self.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n    var itemMap = this.get('itemMap');\n    var comboId = comboItem.get('id');\n    var treeToBeUncombo;\n    var brothers = [];\n    var comboItems = this.get('combos');\n    var parentItem = this.findById(parentId);\n    comboTrees.forEach(function (ctree) {\n      if (treeToBeUncombo) return; // terminate the forEach\n\n      traverseTreeUp(ctree, function (subtree) {\n        var _a; // find the combo to be uncomboed, delete the combo from map and cache\n\n\n        if (subtree.id === comboId) {\n          treeToBeUncombo = subtree; // delete the related edges\n\n          var edgeIds = comboItem.getEdges().map(function (edge) {\n            return edge.getID();\n          });\n          edgeIds.forEach(function (edgeId) {\n            _this.removeItem(edgeId, false);\n          });\n          var index = comboItems.indexOf(comboItem);\n          comboItems.splice(index, 1);\n          delete itemMap[comboId];\n          comboItem.destroy();\n\n          _this.emit('afterremoveitem', {\n            item: comboItem,\n            type: 'combo'\n          });\n        } // find the parent to remove the combo from the combo's brothers array and add the combo's children to the combo's brothers array in the tree\n\n\n        if (parentId && treeToBeUncombo && subtree.id === parentId) {\n          parentItem.removeCombo(comboItem);\n          brothers = subtree.children; // the combo's brothers\n          // remove the combo from its brothers array\n\n          var index = brothers.indexOf(treeToBeUncombo);\n\n          if (index !== -1) {\n            brothers.splice(index, 1);\n          } // append the combo's children to the combo's brothers array\n\n\n          (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            var item = _this.findById(child.id);\n\n            var childModel = item.getModel();\n\n            if (item.getType && item.getType() === 'combo') {\n              child.parentId = parentId;\n              delete child.comboId;\n              childModel.parentId = parentId; // update the parentId of the model\n\n              delete childModel.comboId;\n            } else if (item.getType && item.getType() === 'node') {\n              child.comboId = parentId;\n              childModel.comboId = parentId; // update the parentId of the model\n            }\n\n            parentItem.addChild(item);\n            brothers.push(child);\n          });\n          return false;\n        }\n\n        return true;\n      });\n    }); // if the parentId is not found, remove the combo from the roots\n\n    if (!parentId && treeToBeUncombo) {\n      var index = comboTrees.indexOf(treeToBeUncombo);\n      comboTrees.splice(index, 1); // modify the parentId of the children\n\n      (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n        child.parentId = undefined;\n\n        var childModel = _this.findById(child.id).getModel();\n\n        delete childModel.parentId; // update the parentId of the model\n\n        delete childModel.comboId; // update the comboId of the model\n\n        if (child.itemType !== 'node') comboTrees.push(child);\n      });\n    }\n  };\n  /**\n   * 根据 combo 位置更新内部节点位置 followCombo = true\n   * 或根据内部元素的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围，followCombo = false\n   */\n\n\n  AbstractGraph.prototype.updateCombos = function (followCombo) {\n    var _this = this;\n\n    if (followCombo === void 0) {\n      followCombo = false;\n    }\n\n    var self = this;\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        var _a;\n\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (((_a = childItem === null || childItem === void 0 ? void 0 : childItem.getType) === null || _a === void 0 ? void 0 : _a.call(childItem)) === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true);\n\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, false);\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children, followCombo); // 更新 Combo 后，还原已有的状态\n\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, true);\n          });\n        }\n\n        return true;\n      });\n    });\n    self.sortCombos();\n  };\n  /**\n   * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\n   * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\n   */\n\n\n  AbstractGraph.prototype.updateCombo = function (combo) {\n    var _this = this;\n\n    var self = this;\n    var comboItem = combo;\n    var comboId;\n\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item to be updated is not a combo!');\n      return;\n    }\n\n    comboId = comboItem.get('id');\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true); // || !item.getStateStyle(stateName)\n\n\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, false);\n            }\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\n\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, true);\n            }\n          });\n          if (comboId) comboId = child.parentId;\n        }\n\n        return true;\n      });\n    });\n  };\n  /**\n   * 更新树结构，例如移动子树等\n   * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\n   * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\n   */\n\n\n  AbstractGraph.prototype.updateComboTree = function (item, parentId, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n    this.set('comboSorted', false);\n    var uItem;\n\n    if (isString(item)) {\n      uItem = self.findById(item);\n    } else {\n      uItem = item;\n    }\n\n    var model = uItem.getModel();\n    var oldParentId = model.comboId || model.parentId;\n    var type = '';\n    if (uItem.getType) type = uItem.getType(); // 若 item 是 Combo，且 parentId 是其子孙 combo 的 id，则警告并终止\n\n    if (parentId && type === 'combo') {\n      var comboTrees = this.get('comboTrees');\n      var valid_1 = true;\n      var itemSubTree_1;\n      (comboTrees || []).forEach(function (ctree) {\n        if (itemSubTree_1) return;\n        traverseTree(ctree, function (subTree) {\n          if (itemSubTree_1) return; // 找到从 item 开始的子树\n\n          if (subTree.id === uItem.getID()) {\n            itemSubTree_1 = subTree;\n          }\n\n          return true;\n        });\n      }); // 在以 item 为根的子树中寻找与 parentId 相同的后继元素\n\n      traverseTree(itemSubTree_1, function (subTree) {\n        if (subTree.id === parentId) {\n          valid_1 = false;\n          return false;\n        }\n\n        return true;\n      }); // parentId 是 item 的一个后继元素，不能进行更新\n\n      if (!valid_1) {\n        console.warn('Failed to update the combo tree! The parentId points to a descendant of the combo!');\n        return;\n      }\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var beforeData = {},\n          afterData = {};\n\n      if (type === 'combo') {\n        beforeData.combos = [{\n          id: model.id,\n          parentId: model.parentId\n        }];\n        afterData.combos = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      } else if (type === 'node') {\n        beforeData.nodes = [{\n          id: model.id,\n          parentId: model.comboId\n        }];\n        afterData.nodes = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      }\n\n      this.pushStack('updateComboTree', {\n        before: beforeData,\n        after: afterData\n      });\n    } // 当 combo 存在 parentId 或 comboId 时，才将其移除\n\n\n    if (model.parentId || model.comboId) {\n      var combo = this.findById(model.parentId || model.comboId);\n\n      if (combo) {\n        combo.removeChild(uItem);\n      }\n    }\n\n    if (type === 'combo') {\n      model.parentId = parentId;\n    } else if (type === 'node') {\n      model.comboId = parentId;\n    } // 只有当移入到指定 combo 时才添加\n\n\n    if (parentId) {\n      var parentCombo = this.findById(parentId);\n\n      if (parentCombo) {\n        // 将元素添加到 parentCombo 中\n        parentCombo.addChild(uItem);\n      }\n    } // 如果原先有父亲 combo，则从原父 combo 的子元素数组中删除\n\n\n    if (oldParentId) {\n      var parentCombo = this.findById(oldParentId);\n\n      if (parentCombo) {\n        // 将元素从 parentCombo 中移除\n        parentCombo.removeChild(uItem);\n      }\n    }\n\n    var newComboTrees = reconstructTree(this.get('comboTrees'), model.id, parentId);\n    this.set('comboTrees', newComboTrees);\n    this.updateCombos();\n  };\n  /**\n   * 导出图数据\n   * @return {object} data\n   */\n\n\n  AbstractGraph.prototype.save = function () {\n    var nodes = [];\n    var edges = [];\n    var combos = [];\n    each(this.get('nodes'), function (node) {\n      nodes.push(node.getModel());\n    });\n    each(this.get('edges'), function (edge) {\n      edges.push(edge.getModel());\n    });\n    each(this.get('combos'), function (combo) {\n      combos.push(combo.getModel());\n    });\n    return {\n      nodes: nodes,\n      edges: edges,\n      combos: combos\n    };\n  };\n  /**\n   * 改变画布大小\n   * @param  {number} width  画布宽度\n   * @param  {number} height 画布高度\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeSize = function (width, height) {\n    var viewController = this.get('viewController');\n    viewController.changeSize(width, height);\n    return this;\n  };\n  /**\n   * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\n   */\n\n\n  AbstractGraph.prototype.refresh = function () {\n    var self = this;\n    self.emit('beforegraphrefresh');\n\n    if (self.get('animate')) {\n      self.positionsAnimate();\n    } else {\n      var nodes = self.get('nodes');\n      var edges = self.get('edges');\n      var vedges = self.get('edges');\n      each(nodes, function (node) {\n        node.refresh();\n      });\n      each(edges, function (edge) {\n        edge.refresh();\n      });\n      each(vedges, function (vedge) {\n        vedge.refresh();\n      });\n    }\n\n    self.emit('aftergraphrefresh');\n    self.autoPaint();\n  };\n  /**\n   * 获取当前图中所有节点的item实例\n   * @return {INode} item数组\n   */\n\n\n  AbstractGraph.prototype.getNodes = function () {\n    return this.get('nodes');\n  };\n  /**\n   * 获取当前图中所有边的item实例\n   * @return {IEdge} item数组\n   */\n\n\n  AbstractGraph.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取图中所有的 combo 实例\n   */\n\n\n  AbstractGraph.prototype.getCombos = function () {\n    return this.get('combos');\n  };\n  /**\n   * 获取指定 Combo 中所有的节点\n   * @param comboId combo ID\n   */\n\n\n  AbstractGraph.prototype.getComboChildren = function (combo) {\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo does not exist!');\n      return;\n    }\n\n    return combo.getChildren();\n  };\n  /**\n   * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\n   */\n\n\n  AbstractGraph.prototype.positionsAnimate = function (referComboModel) {\n    var self = this;\n    self.emit('beforeanimate');\n    var animateCfg = self.get('animateCfg');\n    var onFrame = animateCfg.onFrame;\n    var nodes = referComboModel ? self.getNodes().concat(self.getCombos()) : self.getNodes();\n    var toNodes = nodes.map(function (node) {\n      var model = node.getModel();\n      return {\n        id: model.id,\n        x: model.x,\n        y: model.y\n      };\n    });\n    self.stopAnimate();\n    var canvas = self.get('canvas');\n    self.animating = true;\n    canvas.animate(function (ratio) {\n      each(toNodes, function (data) {\n        var node = self.findById(data.id);\n\n        if (!node || node.destroyed) {\n          return;\n        }\n\n        var originAttrs = node.get('originAttrs');\n        var model = node.get('model');\n        var containerMatrix = node.getContainer().getMatrix();\n\n        if (originAttrs === undefined || originAttrs === null) {\n          // 变换前存在位置，设置到 originAttrs 上。否则标记 0 表示变换前不存在位置，不需要计算动画\n          if (containerMatrix) {\n            originAttrs = {\n              x: containerMatrix[6],\n              y: containerMatrix[7]\n            };\n          }\n\n          node.set('originAttrs', originAttrs || 0);\n        }\n\n        if (onFrame) {\n          var attrs = onFrame(node, ratio, data, originAttrs || {\n            x: 0,\n            y: 0\n          });\n          node.set('model', Object.assign(model, attrs));\n        } else if (originAttrs) {\n          // 变换前存在位置，进行动画\n          model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;\n          model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;\n        } else {\n          // 若在变换前不存在位置信息，则直接放到最终位置上\n          model.x = data.x;\n          model.y = data.y;\n        }\n      });\n      self.refreshPositions(referComboModel);\n    }, {\n      duration: animateCfg.duration,\n      easing: animateCfg.easing,\n      callback: function callback() {\n        each(nodes, function (node) {\n          node.set('originAttrs', null);\n        });\n\n        if (animateCfg.callback) {\n          animateCfg.callback();\n        }\n\n        self.emit('afteranimate');\n        self.animating = false;\n      }\n    });\n  };\n  /**\n   * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\n   */\n\n\n  AbstractGraph.prototype.refreshPositions = function (referComboModel) {\n    var self = this;\n    self.emit('beforegraphrefreshposition');\n    var nodes = self.get('nodes');\n    var edges = self.get('edges');\n    var vedges = self.get('vedges');\n    var combos = self.get('combos');\n    var model;\n    var updatedNodes = {};\n\n    var updateItems = function updateItems(items) {\n      each(items, function (item) {\n        model = item.getModel();\n        var originAttrs = item.get('originAttrs');\n\n        if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {\n          return;\n        }\n\n        var changed = item.updatePosition({\n          x: model.x,\n          y: model.y\n        });\n        updatedNodes[model.id] = changed;\n        if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;\n      });\n    };\n\n    updateItems(nodes);\n\n    if (combos && combos.length !== 0) {\n      if (referComboModel) {\n        updateItems(combos);\n        self.updateCombos();\n      } else {\n        self.updateCombos();\n      }\n    }\n\n    each(edges, function (edge) {\n      var sourceModel = edge.getSource().getModel();\n      var target = edge.getTarget(); // 避免 target 是纯对象的情况下调用 getModel 方法\n      // 拖动生成边的时候 target 会是纯对象\n\n      if (!isPlainObject(target)) {\n        var targetModel = target.getModel();\n\n        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {\n          edge.refresh();\n        }\n      }\n    });\n    each(vedges, function (vedge) {\n      vedge.refresh();\n    });\n    self.emit('aftergraphrefreshposition');\n    self.autoPaint();\n  };\n\n  AbstractGraph.prototype.stopAnimate = function () {\n    if (this.isAnimating()) {\n      this.get('canvas').stopAnimate();\n    }\n  };\n\n  AbstractGraph.prototype.isAnimating = function () {\n    return this.animating;\n  };\n  /**\n   * 获取当前视口伸缩比例\n   * @return {number} 比例\n   */\n\n\n  AbstractGraph.prototype.getZoom = function () {\n    var matrix = this.get('group').getMatrix();\n    return matrix ? matrix[0] : 1;\n  };\n  /**\n   * 获取当前的行为模式\n   * @return {string} 当前行为模式\n   */\n\n\n  AbstractGraph.prototype.getCurrentMode = function () {\n    var modeController = this.get('modeController');\n    return modeController.getMode();\n  };\n  /**\n   * 切换行为模式\n   * @param {string} mode 指定模式\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.setMode = function (mode) {\n    var modeController = this.get('modeController');\n    modeController.setMode(mode);\n    return this;\n  };\n  /**\n   * 清除画布元素\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.clear = function (avoidEmit) {\n    var _a;\n\n    if (avoidEmit === void 0) {\n      avoidEmit = false;\n    }\n\n    (_a = this.get('canvas')) === null || _a === void 0 ? void 0 : _a.clear();\n    this.initGroups(); // 清空画布时同时清除数据\n\n    this.set({\n      itemMap: {},\n      nodes: [],\n      edges: [],\n      groups: [],\n      combos: [],\n      comboTrees: []\n    });\n    if (!avoidEmit) this.emit('afterrender');\n    return this;\n  };\n  /**\n   * 更换布局配置项\n   * @param {object} cfg 新布局配置项\n   * @param {'center' | 'begin'} align 对齐方式，可选中心（center）对齐到对齐点，或左上角（begin）对齐到对齐点\n   * @param {IPoint} alignPoint 画布上的对齐点，为 Canvas 坐标系（Canvas DOM）\n   * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\n   * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\n   */\n\n\n  AbstractGraph.prototype.updateLayout = function (cfg, align, alignPoint, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var layoutController = this.get('layoutController');\n\n    if (isString(cfg)) {\n      cfg = {\n        type: cfg\n      };\n    } // align the graph after layout\n\n\n    if (align) {\n      var toPoint_1 = alignPoint;\n\n      if (!toPoint_1) {\n        if (align === 'begin') toPoint_1 = {\n          x: 0,\n          y: 0\n        };else toPoint_1 = {\n          x: this.getWidth() / 2,\n          y: this.getHeight() / 2\n        };\n      } // translate to point coordinate system\n\n\n      toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);\n      var forceTypes = ['force', 'gForce', 'fruchterman']; // if it is force layout, only center takes effect, and assign center force\n\n      if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {\n        cfg.center = [toPoint_1.x, toPoint_1.y];\n      } else {\n        this.once('afterlayout', function (e) {\n          var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];\n          toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];\n\n          var _a = _this.getGroup().getCanvasBBox(),\n              minX = _a.minX,\n              maxX = _a.maxX,\n              minY = _a.minY,\n              maxY = _a.maxY;\n\n          var bboxPoint = {\n            x: (minX + maxX) / 2,\n            y: (minY + maxY) / 2\n          };\n\n          if (align === 'begin') {\n            bboxPoint.x = minX;\n            bboxPoint.y = minY;\n          }\n\n          _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);\n        });\n      }\n    }\n\n    var oriLayoutCfg = __assign({}, this.get('layout'));\n\n    var layoutCfg = {};\n    Object.assign(layoutCfg, oriLayoutCfg, cfg);\n    if (cfg.pipes && !cfg.type) delete layoutCfg.type;else if (!cfg.pipes && layoutCfg.type) delete layoutCfg.pipes;\n    this.set('layout', layoutCfg);\n    if (!layoutController) return;\n\n    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {\n      // no type or same type, or switch the gpu and cpu, update layout\n      layoutController.updateLayoutCfg(layoutCfg);\n    } else {\n      // has different type, change layout\n      layoutController.changeLayout(layoutCfg);\n    }\n\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('layout', {\n        before: oriLayoutCfg,\n        after: layoutCfg\n      });\n    }\n  };\n  /**\n   * 销毁布局，changeData 时不会再使用原来的布局方法对新数据进行布局\n   */\n\n\n  AbstractGraph.prototype.destroyLayout = function () {\n    var layoutController = this.get('layoutController');\n    layoutController === null || layoutController === void 0 ? void 0 : layoutController.destroyLayout();\n  };\n  /**\n   * 重新以当前示例中配置的属性进行一次布局\n   */\n\n\n  AbstractGraph.prototype.layout = function () {\n    var _a;\n\n    var layoutController = this.get('layoutController');\n    var layoutCfg = this.get('layout');\n    if (!layoutCfg || !layoutController) return;\n\n    if (layoutCfg.workerEnabled) {\n      // 如果使用web worker布局\n      layoutController.layout();\n      return;\n    }\n\n    if ((_a = layoutController.layoutMethods) === null || _a === void 0 ? void 0 : _a.length) {\n      layoutController.relayout(true);\n    } else {\n      layoutController.layout();\n    }\n  };\n  /**\n   * 收起指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.collapseCombo = function (combo, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (this.destroyed) return;\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo) {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.collapseCombo(combo, stack);\n    comboModel.collapsed = true; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cNodesCombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate the forEach\n\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false; // if the combo is found\n\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          // if the combo is found, concat the descendant nodes and combos\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cNodesCombos = cNodesCombos.concat(item.getNodes());\n            cNodesCombos = cNodesCombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var addedVEdgeMap = {};\n    edges.forEach(function (edge) {\n      var _a = edge.getModel(),\n          isVEdge = _a.isVEdge,\n          _b = _a.size,\n          size = _b === void 0 ? 1 : _b;\n\n      if (edge.isVisible() && !isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var otherEnd = null;\n      var otherEndIsSource;\n\n      if (source.getModel().id === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {\n        // source is the current combo, or descent node/combo is the source but not the target)\n        otherEnd = target;\n        otherEndIsSource = false;\n      } else if (target.getModel().id === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // target is the current combo, or descent node/combo is the target but not the source)\n        otherEnd = source;\n        otherEndIsSource = true;\n      }\n\n      if (otherEnd) {\n        if (isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var otherEndModel = otherEnd.getModel();\n\n        while (!otherEnd.isVisible()) {\n          var otherEndPId = otherEndModel.parentId,\n              otherEndCId = otherEndModel.comboId;\n          var otherEndParentId = otherEndPId || otherEndCId;\n          otherEnd = _this.findById(otherEndParentId);\n          if (!otherEnd || !otherEndParentId) return; // all the ancestors are hidden, then ignore the edge\n\n          otherEndModel = otherEnd.getModel();\n        }\n\n        var otherEndId = otherEndModel.id;\n        var vEdgeInfo = otherEndIsSource ? {\n          source: otherEndId,\n          target: comboModel.id,\n          size: size,\n          isVEdge: true\n        } : {\n          source: comboModel.id,\n          target: otherEndId,\n          size: size,\n          isVEdge: true\n        };\n        var key = \"\".concat(vEdgeInfo.source, \"-\").concat(vEdgeInfo.target);\n\n        if (addedVEdgeMap[key]) {\n          addedVEdgeMap[key].size += size;\n          return;\n        }\n\n        addedVEdgeMap[key] = vEdgeInfo;\n      }\n    }); // update the width of the virtual edges, which is the sum of merged actual edges\n    // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n    this.addItems(Object.values(addedVEdgeMap).map(function (edgeInfo) {\n      return {\n        type: 'vedge',\n        model: edgeInfo\n      };\n    }), false);\n    this.emit('aftercollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n  };\n  /**\n   * 展开指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.expandCombo = function (combo, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.expandCombo(combo, stack);\n    comboModel.collapsed = false; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cNodesCombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate\n\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cNodesCombos = cNodesCombos.concat(item.getNodes());\n            cNodesCombos = cNodesCombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var addedVEdgeMap = {};\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var sourceId = source.get('id');\n      var targetId = target.get('id');\n      var otherEnd = null;\n      var otherEndIsSource;\n\n      if (sourceId === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {\n        // the source is in the combo, the target is not\n        otherEnd = target;\n        otherEndIsSource = false;\n      } else if (targetId === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // the target is in the combo, the source is not\n        otherEnd = source;\n        otherEndIsSource = true;\n      } else if (cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // both source and target are in the combo, if the target and source are both visible, show the edge\n        if (source.isVisible() && target.isVisible()) {\n          edge.show();\n        }\n      }\n\n      if (otherEnd) {\n        var _a = edge.getModel(),\n            isVEdge = _a.isVEdge,\n            _b = _a.size,\n            size = _b === void 0 ? 1 : _b; // ignore the virtual edges\n\n\n        if (isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var otherEndModel = otherEnd.getModel(); // find the nearest visible ancestor\n\n        while (!otherEnd.isVisible()) {\n          var otherEndPId = otherEndModel.parentId,\n              otherEndCId = otherEndModel.comboId;\n          var otherEndParentId = otherEndPId || otherEndCId;\n          otherEnd = _this.findById(otherEndParentId);\n\n          if (!otherEnd || !otherEndParentId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          otherEndModel = otherEnd.getModel();\n        }\n\n        var otherEndId = otherEndModel.id;\n        var selfEnd = otherEndIsSource ? target : source;\n        var selfEndModel = selfEnd.getModel(); // find the nearest visible ancestor\n\n        while (!selfEnd.isVisible()) {\n          var selfEndPId = otherEndModel.parentId,\n              selfEndCId = otherEndModel.comboId;\n          var selfEndParentId = selfEndPId || selfEndCId;\n          selfEnd = _this.findById(selfEndParentId);\n\n          if (!selfEnd || !selfEndParentId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (selfEndModel.comboId === comboModel.id || selfEndModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          selfEndModel = selfEnd.getModel();\n        }\n\n        var selfEndId = selfEndModel.id;\n\n        if (otherEndId) {\n          var vEdgeInfo = otherEndIsSource ? {\n            source: otherEndId,\n            target: selfEndId,\n            isVEdge: true,\n            size: size\n          } : {\n            source: selfEndId,\n            target: otherEndId,\n            isVEdge: true,\n            size: size\n          };\n          var vedgeId = \"\".concat(vEdgeInfo.source, \"-\").concat(vEdgeInfo.target); // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n          if (addedVEdgeMap[vedgeId]) {\n            addedVEdgeMap[vedgeId].size += size;\n            return;\n          }\n\n          addedVEdgeMap[vedgeId] = vEdgeInfo;\n        }\n      }\n    });\n    this.addItems(Object.values(addedVEdgeMap).map(function (edgeInfo) {\n      return {\n        type: 'vedge',\n        model: edgeInfo\n      };\n    }), false);\n    this.emit('aftercollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n  };\n\n  AbstractGraph.prototype.collapseExpandCombo = function (combo, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') return;\n    var comboModel = combo.getModel(); // if one ancestor combo of the combo is collapsed, it should not be collapsed or expanded\n\n    var parentItem = this.findById(comboModel.parentId);\n\n    while (parentItem) {\n      var parentModel = parentItem.getModel();\n\n      if (parentModel.collapsed) {\n        console.warn(\"Fail to expand the combo since it's ancestor combo is collapsed.\");\n        parentItem = undefined;\n        return;\n      }\n\n      parentItem = this.findById(parentModel.parentId);\n    }\n\n    var collapsed = comboModel.collapsed; // 该群组已经处于收起状态，需要展开\n\n    if (collapsed) {\n      this.expandCombo(combo, stack);\n    } else {\n      this.collapseCombo(combo, stack);\n    }\n\n    this.updateCombo(combo);\n  };\n  /**\n   * 获取节点所有的邻居节点\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @returns {INode[]}\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNeighbors = function (node, type) {\n    var item = node;\n\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n\n    return item.getNeighbors(type);\n  };\n  /**\n   * 获取 node 的度数\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\n   * @returns {Number | Object} 该节点的度数\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNodeDegree = function (node, type, refresh) {\n    if (type === void 0) {\n      type = undefined;\n    }\n\n    if (refresh === void 0) {\n      refresh = false;\n    }\n\n    var item = node;\n\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n\n    var degrees = this.get('degrees');\n\n    if (!degrees || refresh) {\n      degrees = getDegree(this.save());\n      this.set('degrees', degrees);\n    }\n\n    var nodeDegrees = degrees[item.getID()];\n    var res = 0; // 如果是通过 addItem 后面新增加的节点，此时它的所有度数都为 0\n\n    if (!nodeDegrees) {\n      return 0;\n    }\n\n    switch (type) {\n      case 'in':\n        res = nodeDegrees.inDegree;\n        break;\n\n      case 'out':\n        res = nodeDegrees.outDegree;\n        break;\n\n      case 'all':\n        res = nodeDegrees;\n        break;\n\n      default:\n        res = nodeDegrees.degree;\n        break;\n    }\n\n    return res;\n  };\n\n  AbstractGraph.prototype.getUndoStack = function () {\n    return this.undoStack;\n  };\n\n  AbstractGraph.prototype.getRedoStack = function () {\n    return this.redoStack;\n  };\n  /**\n   * 获取 undo 和 redo 栈的数据\n   */\n\n\n  AbstractGraph.prototype.getStackData = function () {\n    if (!this.get('enabledStack')) {\n      return null;\n    }\n\n    return {\n      undoStack: this.undoStack.toArray(),\n      redoStack: this.redoStack.toArray()\n    };\n  };\n  /**\n   * 清空 undo stack & redo stack\n   */\n\n\n  AbstractGraph.prototype.clearStack = function () {\n    if (this.get('enabledStack')) {\n      this.undoStack.clear();\n      this.redoStack.clear();\n    }\n  };\n  /**\n   * 将操作类型和操作数据入栈\n   * @param action 操作类型\n   * @param data 入栈的数据\n   * @param stackType 栈的类型\n   */\n\n\n  AbstractGraph.prototype.pushStack = function (action, data, stackType) {\n    if (action === void 0) {\n      action = 'update';\n    }\n\n    if (stackType === void 0) {\n      stackType = 'undo';\n    }\n\n    if (!this.get('enabledStack')) {\n      console.warn('请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !');\n      return;\n    }\n\n    var stackData = data ? clone(data) : {\n      before: {},\n      after: clone(this.save())\n    };\n\n    if (stackType === 'redo') {\n      this.redoStack.push({\n        action: action,\n        data: stackData\n      });\n    } else {\n      this.undoStack.push({\n        action: action,\n        data: stackData\n      });\n    }\n\n    this.emit('stackchange', {\n      undoStack: this.undoStack,\n      redoStack: this.redoStack\n    });\n  };\n  /**\n   * 获取邻接矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 邻接矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getAdjMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    return currentAdjMatrix;\n  };\n  /**\n   * 获取最短路径矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 最短路径矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getShortestPathMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    var currentShourtestPathMatrix = this.get('shortestPathMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    if (!currentShourtestPathMatrix || !cache) {\n      currentShourtestPathMatrix = floydWarshall(this.save(), directed);\n      this.set('shortestPathMatrix', currentShourtestPathMatrix);\n    }\n\n    return currentShourtestPathMatrix;\n  };\n  /**\n   * 重新定义监听函数，复写参数类型\n   */\n\n\n  AbstractGraph.prototype.on = function (eventName, callback, once) {\n    return _super.prototype.on.call(this, eventName, callback, once);\n  };\n  /**\n   * 销毁画布\n   */\n\n\n  AbstractGraph.prototype.destroy = function () {\n    var _a, _b, _c, _d, _e;\n\n    this.clear(); // 清空栈数据\n\n    this.clearStack();\n    (_a = this.get('itemController')) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this.get('modeController')) === null || _b === void 0 ? void 0 : _b.destroy();\n    (_c = this.get('viewController')) === null || _c === void 0 ? void 0 : _c.destroy();\n    (_d = this.get('stateController')) === null || _d === void 0 ? void 0 : _d.destroy();\n    (_e = this.get('canvas')) === null || _e === void 0 ? void 0 : _e.destroy();\n    this.cfg = null;\n    this.destroyed = true;\n    this.redoStack = null;\n    this.undoStack = null;\n  };\n  /**\n   * 创建凸包或凹包轮廓\n   * @param cfg HullCfg 轮廓配置项\n   */\n\n\n  AbstractGraph.prototype.createHull = function (cfg) {\n    if (!cfg.members || cfg.members.length < 1) {\n      console.warn('Create hull failed! The members is empty.');\n      return;\n    }\n\n    var parent = this.get('hullGroup');\n    var hullMap = this.get('hullMap');\n\n    if (!hullMap) {\n      hullMap = {};\n      this.set('hullMap', hullMap);\n    }\n\n    if (!parent || parent.get('destroyed')) {\n      parent = this.get('group').addGroup({\n        id: 'hullGroup'\n      });\n      parent.toBack();\n      this.set('hullGroup', parent);\n    }\n\n    if (hullMap[cfg.id]) {\n      console.warn('Existed hull id.');\n      return hullMap[cfg.id];\n    }\n\n    var group = parent.addGroup({\n      id: \"\".concat(cfg.id, \"-container\")\n    });\n    var hull = new Hull(this, __assign(__assign({}, cfg), {\n      group: group\n    }));\n    var hullId = hull.id;\n    hullMap[hullId] = hull;\n    return hull;\n  };\n  /**\n   * 获取当前 graph 中存在的包裹轮廓\n   * @return {[key: string]: Hull} Hull 的 map，hullId 对应的 hull 实例\n   */\n\n\n  AbstractGraph.prototype.getHulls = function () {\n    return this.get('hullMap');\n  };\n  /**\n   * 根据 hullId 获取对应的 hull\n   * @return Hull\n   */\n\n\n  AbstractGraph.prototype.getHullById = function (hullId) {\n    return this.get('hullMap')[hullId];\n  };\n\n  AbstractGraph.prototype.removeHull = function (hull) {\n    var _a;\n\n    var hullInstance;\n\n    if (isString(hull)) {\n      hullInstance = this.getHullById(hull);\n    } else {\n      hullInstance = hull;\n    }\n\n    (_a = this.get('hullMap')) === null || _a === void 0 ? true : delete _a[hullInstance.id];\n    hullInstance.destroy();\n  };\n\n  AbstractGraph.prototype.removeHulls = function () {\n    var hulls = this.getHulls();\n    if (!hulls || !Object.keys(hulls).length) return;\n    Object.keys(hulls).forEach(function (key) {\n      var hull = hulls[key];\n      hull.destroy();\n    });\n    this.set('hullMap', {});\n  };\n\n  return AbstractGraph;\n}(EventEmitter);\n\nexport default AbstractGraph;","map":{"version":3,"names":["__assign","__extends","__spreadArray","EventEmitter","ext","clone","deepMix","each","isPlainObject","isString","debounce","getDegree","getAdjMatrix","getAdjacentMatrix","Stack","floydWarshall","lerp","move","dataValidation","singleDataValidation","Global","ItemController","ModeController","StateController","ViewController","plainCombosToTrees","traverseTree","reconstructTree","traverseTreeUp","getAnimateCfgWithCallback","Hull","transform","NODE","AbstractGraph","_super","cfg","_this","call","sortCombos","comboSorted","get","destroyed","set","depthMap","dataDepthMap","comboTrees","forEach","cTree","child","depth","push","id","edges","getEdges","concat","edgeItem","edge","getModel","sourceDepth","source","targetDepth","target","Math","max","array","length","i","item","findById","toFront","getDefaultCfg","init","animating","enabledStack","undoStack","maxStep","redoStack","prototype","initCanvas","viewController","modeController","itemController","stateController","initLayoutController","initEventController","initGroups","initPlugins","canvas","el","_a","group","addGroup","className","rootContainerClassName","edgeGroup","edgeContainerClassName","nodeGroup","nodeContainerClassName","comboGroup","comboContainerClassName","toBack","delegateGroup","delegateContainerClassName","container","undefined","width","height","renderer","modes","plugins","data","fitViewPadding","minZoom","maxZoom","event","groupByTypes","directed","autoPaint","nodes","combos","vedges","itemMap","linkCenter","defaultNode","defaultEdge","nodeStateStyles","edgeStateStyles","states","animate","animateCfg","onFrame","duration","easing","callback","tooltips","key","val","getGroup","getContainer","getMinZoom","setMinZoom","ratio","getMaxZoom","setMaxZoom","getWidth","getHeight","clearItemStates","updateStates","node","nodeFn","edgeFn","combo","comboFn","find","type","fn","result","items","findAll","findAllByState","state","additionalFilter","hasState","translate","dx","dy","matrix","getMatrix","animateConfig","emit","action","x","getCanvasBBox","y","setMatrix","moveTo","fitView","padding","rules","fitViewByRules","fitCenter","addBehaviors","behaviors","manipulateBehaviors","removeBehaviors","updateBehavior","behavior","newCfg","mode","zoom","center","currentZoom","getZoom","targetZoom","finalRatio","failed","aniMatrix_1","initialRatio_1","targetRatio_1","scale","zoomTo","toRatio","focusItem","isAnimate","curAniamteCfg","focus","paint","draw","getPointByClient","clientX","clientY","getClientByPoint","getPointByCanvas","canvasX","canvasY","getCanvasByPoint","getGraphCenterPoint","bbox","minX","maxX","minY","maxY","getViewPortCenterPoint","showItem","stack","object","changeItemVisibility","getID","getType","before","after","visible","pushStack","hideItem","refreshItem","setAutoPaint","auto","self","remove","removeItem","nodeItem","console","warn","deletedModel","itemType","model","comboId","updateComboTree","newComboTrees","innerAddItem","itemMap_1","foundParent_1","ctree","parentId","newCombo","children","addItem","childItem","updateCombo","collapsed","setTimeout","collapseCombo","parentCombo","itemMap_2","foundParent_2","foundNode_1","cloneNode","addChild","sortCombo","currentComboSorted","addedModel","addItems","returnItems","returnItem","add","updateItem","currentItem","UnupdateModel","getStates","setItemState","afterModel","update","value","updateState","priorityState","render","clearStack","Error","_b","_c","clear","map","addCombos","layoutController","layout","success","getCombos","nodesArr","getNodes","edgesArr","read","diffItems","models","containerMatrix","changeData","propsData","save","removeHulls","localRefresh","combosData","destroy","indexOf","comboItems","combosLength","splice","getLayoutType","positionsAnimate","createCombo","comboConfig","trees","elementId","cItem","uncombo","comboItem","treeToBeUncombo","brothers","parentItem","subtree","edgeIds","edgeId","index","removeCombo","childModel","updateCombos","followCombo","getStateStyle","uItem","oldParentId","valid_1","itemSubTree_1","subTree","beforeData","afterData","removeChild","changeSize","refresh","vedge","getComboChildren","getChildren","referComboModel","toNodes","stopAnimate","originAttrs","attrs","Object","assign","refreshPositions","updatedNodes","updateItems","changed","updatePosition","sourceModel","getSource","getTarget","targetModel","isComboEdge","isAnimating","getCurrentMode","getMode","setMode","avoidEmit","groups","updateLayout","align","alignPoint","toPoint_1","forceTypes","includes","layoutType","once","e","bboxPoint","oriLayoutCfg","layoutCfg","pipes","isLayoutTypeSame","gpuEnabled","updateLayoutCfg","changeLayout","destroyLayout","workerEnabled","layoutMethods","relayout","comboModel","cNodesCombos","found","addedVEdgeMap","isVEdge","size","isVisible","otherEnd","otherEndIsSource","otherEndModel","otherEndPId","otherEndCId","otherEndParentId","otherEndId","vEdgeInfo","values","edgeInfo","expandCombo","sourceId","targetId","show","selfEnd","selfEndModel","selfEndPId","selfEndCId","selfEndParentId","selfEndId","vedgeId","collapseExpandCombo","parentModel","getNeighbors","getNodeDegree","degrees","nodeDegrees","res","inDegree","outDegree","degree","getUndoStack","getRedoStack","getStackData","toArray","stackType","stackData","cache","currentAdjMatrix","getShortestPathMatrix","currentShourtestPathMatrix","on","eventName","_d","_e","createHull","members","parent","hullMap","hull","hullId","getHulls","getHullById","removeHull","hullInstance","hulls","keys"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/g6-core/es/graph/graph.js"],"sourcesContent":["import { __assign, __extends, __spreadArray } from \"tslib\";\nimport EventEmitter from '@antv/event-emitter';\nimport { ext } from '@antv/matrix-util';\nimport { clone, deepMix, each, isPlainObject, isString, debounce } from '@antv/util';\nimport { getDegree, getAdjMatrix as getAdjacentMatrix, Stack, floydWarshall } from '@antv/algorithm';\nimport { lerp, move } from '../util/math';\nimport { dataValidation, singleDataValidation } from '../util/validation';\nimport Global from '../global';\nimport { ItemController, ModeController, StateController, ViewController } from './controller';\nimport { plainCombosToTrees, traverseTree, reconstructTree, traverseTreeUp, getAnimateCfgWithCallback } from '../util/graphic';\nimport Hull from '../item/hull';\nvar transform = ext.transform;\nvar NODE = 'node';\n\nvar AbstractGraph =\n/** @class */\nfunction (_super) {\n  __extends(AbstractGraph, _super);\n\n  function AbstractGraph(cfg) {\n    var _this = _super.call(this) || this;\n    /**\n     * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\n     * @param {GraphData} data 数据\n     */\n\n\n    _this.sortCombos = debounce(function () {\n      var comboSorted = _this.get('comboSorted');\n\n      if (!_this || _this.destroyed || comboSorted) return;\n\n      _this.set('comboSorted', true);\n\n      var depthMap = [];\n      var dataDepthMap = {};\n\n      var comboTrees = _this.get('comboTrees');\n\n      (comboTrees || []).forEach(function (cTree) {\n        traverseTree(cTree, function (child) {\n          if (depthMap[child.depth]) depthMap[child.depth].push(child.id);else depthMap[child.depth] = [child.id];\n          dataDepthMap[child.id] = child.depth;\n          return true;\n        });\n      });\n\n      var edges = _this.getEdges().concat(_this.get('vedges'));\n\n      (edges || []).forEach(function (edgeItem) {\n        var edge = edgeItem.getModel();\n        var sourceDepth = dataDepthMap[edge.source] || 0;\n        var targetDepth = dataDepthMap[edge.target] || 0;\n        var depth = Math.max(sourceDepth, targetDepth);\n        if (depthMap[depth]) depthMap[depth].push(edge.id);else depthMap[depth] = [edge.id];\n      });\n      depthMap.forEach(function (array) {\n        if (!array || !array.length) return;\n\n        for (var i = array.length - 1; i >= 0; i--) {\n          var item = _this.findById(array[i]);\n\n          if (item) item.toFront();\n        }\n      });\n    }, 500, false);\n    _this.cfg = deepMix(_this.getDefaultCfg(), cfg);\n\n    _this.init();\n\n    _this.animating = false;\n    _this.destroyed = false; // 启用 stack 后，实例化 undoStack 和 redoStack\n\n    if (_this.cfg.enabledStack) {\n      // 实例化 undo 和 redo 栈\n      _this.undoStack = new Stack(_this.cfg.maxStep);\n      _this.redoStack = new Stack(_this.cfg.maxStep);\n    }\n\n    return _this;\n  }\n\n  AbstractGraph.prototype.init = function () {\n    this.initCanvas(); // instance controller\n\n    var viewController = new ViewController(this);\n    var modeController = new ModeController(this);\n    var itemController = new ItemController(this);\n    var stateController = new StateController(this);\n    this.set({\n      viewController: viewController,\n      modeController: modeController,\n      itemController: itemController,\n      stateController: stateController\n    }); // 初始化布局机制\n\n    this.initLayoutController(); // 初始化事件机制\n\n    this.initEventController();\n    this.initGroups();\n    /** 初始化插件 */\n\n    this.initPlugins();\n  }; // 初始化所有 Group\n\n\n  AbstractGraph.prototype.initGroups = function () {\n    var canvas = this.get('canvas');\n    if (!canvas) return;\n    var el = canvas.get('el');\n    var _a = (el || {}).id,\n        id = _a === void 0 ? 'g6' : _a;\n    var group = canvas.addGroup({\n      id: \"\".concat(id, \"-root\"),\n      className: Global.rootContainerClassName\n    });\n\n    if (this.get('groupByTypes')) {\n      var edgeGroup = group.addGroup({\n        id: \"\".concat(id, \"-edge\"),\n        className: Global.edgeContainerClassName\n      });\n      var nodeGroup = group.addGroup({\n        id: \"\".concat(id, \"-node\"),\n        className: Global.nodeContainerClassName\n      });\n      var comboGroup = group.addGroup({\n        id: \"\".concat(id, \"-combo\"),\n        className: Global.comboContainerClassName\n      }); // 用于存储自定义的群组\n\n      comboGroup.toBack();\n      this.set({\n        nodeGroup: nodeGroup,\n        edgeGroup: edgeGroup,\n        comboGroup: comboGroup\n      });\n    }\n\n    var delegateGroup = group.addGroup({\n      id: \"\".concat(id, \"-delegate\"),\n      className: Global.delegateContainerClassName\n    });\n    this.set({\n      delegateGroup: delegateGroup\n    });\n    this.set('group', group);\n  }; // eslint-disable-next-line class-methods-use-this\n\n\n  AbstractGraph.prototype.getDefaultCfg = function () {\n    return {\n      /**\n       * Container could be dom object or dom id\n       */\n      container: undefined,\n\n      /**\n       * Canvas width\n       * unit pixel if undefined force fit width\n       */\n      width: undefined,\n\n      /**\n       * Canvas height\n       * unit pixel if undefined force fit height\n       */\n      height: undefined,\n\n      /**\n       * renderer canvas or svg\n       * @type {string}\n       */\n      renderer: 'canvas',\n\n      /**\n       * control graph behaviors\n       */\n      modes: {},\n\n      /**\n       * 注册插件\n       */\n      plugins: [],\n\n      /**\n       * source data\n       */\n      data: {},\n\n      /**\n       * Fit view padding (client scale)\n       */\n      fitViewPadding: 10,\n\n      /**\n       * Minimum scale size\n       */\n      minZoom: 0.02,\n\n      /**\n       * Maxmum scale size\n       */\n      maxZoom: 10,\n\n      /**\n       *  capture events\n       */\n      event: true,\n\n      /**\n       * group node & edges into different graphic groups\n       */\n      groupByTypes: true,\n\n      /**\n       * determine if it's a directed graph\n       */\n      directed: false,\n\n      /**\n       * when data or shape changed, should canvas draw automatically\n       */\n      autoPaint: true,\n\n      /**\n       * store all the node instances\n       */\n      nodes: [],\n\n      /**\n       * store all the edge instances\n       */\n      edges: [],\n\n      /**\n       * store all the combo instances\n       */\n      combos: [],\n\n      /**\n       * store all the edge instances which are virtual edges related to collapsed combo\n       */\n      vedges: [],\n\n      /**\n       * all the instances indexed by id\n       */\n      itemMap: {},\n\n      /**\n       * 边直接连接到节点的中心，不再考虑锚点\n       */\n      linkCenter: false,\n\n      /**\n       * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：\n       * defaultNode: {\n       *  type: 'rect',\n       *  size: [60, 40],\n       *  style: {\n       *    //... 样式配置项\n       *  }\n       * }\n       * 若数据项为 { id: 'node', x: 100, y: 100 }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }\n       * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }\n       */\n      defaultNode: {},\n\n      /**\n       * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode\n       */\n      defaultEdge: {},\n\n      /**\n       * 节点默认样式，也可以添加状态样式\n       * 例如：\n       * const graph = new G6.Graph({\n       *  nodeStateStyles: {\n       *    selected: { fill: '#ccc', stroke: '#666' },\n       *    active: { lineWidth: 2 }\n       *  },\n       *  ...\n       * });\n       *\n       */\n      nodeStateStyles: {},\n\n      /**\n       * 边默认样式，用法同nodeStateStyle\n       */\n      edgeStateStyles: {},\n\n      /**\n       * graph 状态\n       */\n      states: {},\n\n      /**\n       * 是否启用全局动画\n       */\n      animate: false,\n\n      /**\n       * 动画设置,仅在 animate 为 true 时有效\n       */\n      animateCfg: {\n        /**\n         * 帧回调函数，用于自定义节点运动路径，为空时线性运动\n         */\n        onFrame: undefined,\n\n        /**\n         * 动画时长(ms)\n         */\n        duration: 500,\n\n        /**\n         * 指定动画动效\n         */\n        easing: 'easeLinear'\n      },\n      callback: undefined,\n      // 默认不启用 undo & redo 功能\n      enabledStack: false,\n      // 只有当 enabledStack 为 true 时才起作用\n      maxStep: 10,\n      // 存储图上的 tooltip dom，方便销毁\n      tooltips: []\n    };\n  };\n  /**\n   * 将值设置到 this.cfg 变量上面\n   * @param key 键 或 对象值\n   * @param val 值\n   */\n\n\n  AbstractGraph.prototype.set = function (key, val) {\n    if (isPlainObject(key)) {\n      this.cfg = __assign(__assign({}, this.cfg), key);\n    } else {\n      this.cfg[key] = val;\n    }\n\n    if (key === 'enabledStack' && val && !this.undoStack && !this.redoStack) {\n      this.undoStack = new Stack(this.cfg.maxStep);\n      this.redoStack = new Stack(this.cfg.maxStep);\n    }\n\n    return this;\n  };\n  /**\n   * 获取 this.cfg 中的值\n   * @param key 键\n   */\n\n\n  AbstractGraph.prototype.get = function (key) {\n    var _a;\n\n    return (_a = this.cfg) === null || _a === void 0 ? void 0 : _a[key];\n  };\n  /**\n   * 获取 graph 的根图形分组\n   * @return 根 group\n   */\n\n\n  AbstractGraph.prototype.getGroup = function () {\n    return this.get('group');\n  };\n  /**\n   * 获取 graph 的 DOM 容器\n   * @return DOM 容器\n   */\n\n\n  AbstractGraph.prototype.getContainer = function () {\n    return this.get('container');\n  };\n  /**\n   * 获取 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.getMinZoom = function () {\n    return this.get('minZoom');\n  };\n  /**\n   * 设置 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.setMinZoom = function (ratio) {\n    return this.set('minZoom', ratio);\n  };\n  /**\n   * 获取 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.getMaxZoom = function () {\n    return this.get('maxZoom');\n  };\n  /**\n   * 设置 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.setMaxZoom = function (ratio) {\n    return this.set('maxZoom', ratio);\n  };\n  /**\n   * 获取 graph 的宽度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getWidth = function () {\n    return this.get('width');\n  };\n  /**\n   * 获取 graph 的高度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getHeight = function () {\n    return this.get('height');\n  };\n  /**\n   * 清理元素多个状态\n   * @param {string|Item} item 元素id或元素实例\n   * @param {string[]} states 状态\n   */\n\n\n  AbstractGraph.prototype.clearItemStates = function (item, states) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n\n    if (!states) {\n      states = item.get('states');\n    }\n\n    itemController.clearItemStates(item, states);\n    var stateController = this.get('stateController');\n    stateController.updateStates(item, states, false);\n  };\n  /**\n   * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\n   * 若是自定义节点切在各种状态下\n   * graph.node(node => {\n   *  return {\n   *    type: 'rect',\n   *    label: node.id,\n   *    style: { fill: '#666' },\n   *    stateStyles: {\n   *       selected: { fill: 'blue' },\n   *       custom: { fill: 'green' }\n   *     }\n   *   }\n   * });\n   * @param {function} nodeFn 指定每个节点样式\n   */\n\n\n  AbstractGraph.prototype.node = function (nodeFn) {\n    if (typeof nodeFn === 'function') {\n      this.set('nodeMapper', nodeFn);\n    }\n  };\n  /**\n   * 设置各个边样式\n   * @param {function} edgeFn 指定每个边的样式,用法同 node\n   */\n\n\n  AbstractGraph.prototype.edge = function (edgeFn) {\n    if (typeof edgeFn === 'function') {\n      this.set('edgeMapper', edgeFn);\n    }\n  };\n  /**\n   * 设置各个 combo 的配置\n   * @param comboFn\n   */\n\n\n  AbstractGraph.prototype.combo = function (comboFn) {\n    if (typeof comboFn === 'function') {\n      this.set('comboMapper', comboFn);\n    }\n  };\n  /**\n   * 根据 ID 查询图元素实例\n   * @param id 图元素 ID\n   */\n\n\n  AbstractGraph.prototype.findById = function (id) {\n    return this.get('itemMap')[id];\n  };\n  /**\n   * 根据对应规则查找单个元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge | group)\n   * @param {(item: T, index: number) => T} fn 指定规则\n   * @return {T} 元素实例\n   */\n\n\n  AbstractGraph.prototype.find = function (type, fn) {\n    var result;\n    var items = this.get(\"\".concat(type, \"s\")); // eslint-disable-next-line consistent-return\n\n    each(items, function (item, i) {\n      if (fn(item, i)) {\n        result = item;\n        return result;\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有满足规则的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} fn 指定规则\n   * @return {array} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAll = function (type, fn) {\n    var result = [];\n    each(this.get(\"\".concat(type, \"s\")), function (item, i) {\n      if (fn(item, i)) {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有处于指定状态的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} state 状态\n   * @return {object} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAllByState = function (type, state, additionalFilter) {\n    if (additionalFilter) {\n      return this.findAll(type, function (item) {\n        return item.hasState(state) && additionalFilter(item);\n      });\n    } else {\n      return this.findAll(type, function (item) {\n        return item.hasState(state);\n      });\n    }\n  };\n  /**\n   * 平移画布\n   * @param dx 水平方向位移\n   * @param dy 垂直方向位移\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.translate = function (dx, dy, animate, animateCfg) {\n    var _this = this;\n\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix());\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    if (animate) {\n      var animateConfig = getAnimateCfgWithCallback({\n        animateCfg: animateCfg,\n        callback: function callback() {\n          return _this.emit('viewportchange', {\n            action: 'translate',\n            matrix: group.getMatrix()\n          });\n        }\n      });\n      move(group, {\n        x: group.getCanvasBBox().x + dx,\n        y: group.getCanvasBBox().y + dy\n      }, animate, animateConfig || {\n        duration: 500,\n        easing: 'easeCubic'\n      });\n    } else {\n      matrix = transform(matrix, [['t', dx, dy]]);\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'translate',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n  };\n  /**\n   * 平移画布到某点\n   * @param {number} x 水平坐标\n   * @param {number} y 垂直坐标\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.moveTo = function (x, y, animate, animateCfg) {\n    var group = this.get('group');\n    move(group, {\n      x: x,\n      y: y\n    }, animate, animateCfg || {\n      duration: 500,\n      easing: 'easeCubic'\n    });\n    this.emit('viewportchange', {\n      action: 'move',\n      matrix: group.getMatrix()\n    });\n  };\n  /**\n   * 调整视口适应视图\n   * @param {object} padding 四周围边距\n   * @param {FitViewRules} rules fitView的规则\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.fitView = function (padding, rules, animate, animateCfg) {\n    if (padding) {\n      this.set('fitViewPadding', padding);\n    }\n\n    var viewController = this.get('viewController');\n\n    if (rules) {\n      viewController.fitViewByRules(rules, animate, animateCfg);\n    } else {\n      viewController.fitView(animate, animateCfg);\n    }\n\n    this.autoPaint();\n  };\n  /**\n   * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.fitCenter = function (animate, animateCfg) {\n    var viewController = this.get('viewController');\n    viewController.fitCenter(animate, animateCfg);\n    this.autoPaint();\n  };\n  /**\n   * 新增行为\n   * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\n   * @param {string | string[]} modes 添加到对应的模式\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.addBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, true);\n    return this;\n  };\n  /**\n   * 移除行为\n   * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\n   * @param {string | string[]} modes 从指定的模式中移除\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.removeBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, false);\n    return this;\n  };\n  /**\n   * 更新行为参数\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.updateBehavior = function (behavior, newCfg, mode) {\n    var modeController = this.get('modeController');\n    modeController.updateBehavior(behavior, newCfg, mode);\n    return this;\n  };\n  /**\n   * 伸缩窗口\n   * @param ratio 伸缩比例\n   * @param center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n\n\n  AbstractGraph.prototype.zoom = function (ratio, center, animate, animateCfg) {\n    var _this = this;\n\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix()) || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    var minZoom = this.get('minZoom');\n    var maxZoom = this.get('maxZoom');\n    var currentZoom = this.getZoom() || 1;\n    var targetZoom = currentZoom * ratio;\n    var finalRatio = ratio;\n    var failed = false;\n\n    if (minZoom && targetZoom < minZoom) {\n      finalRatio = minZoom / currentZoom;\n      failed = true;\n    } else if (maxZoom && targetZoom > maxZoom) {\n      finalRatio = maxZoom / currentZoom;\n      failed = true;\n    }\n\n    if (center) {\n      matrix = transform(matrix, [['t', -center.x, -center.y], ['s', finalRatio, finalRatio], ['t', center.x, center.y]]);\n    } else {\n      matrix = transform(matrix, [['s', finalRatio, finalRatio]]);\n    }\n\n    if (animate) {\n      // Clone the original matrix to perform the animation\n      var aniMatrix_1 = clone(group.getMatrix());\n\n      if (!aniMatrix_1) {\n        aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      }\n\n      var initialRatio_1 = aniMatrix_1[0];\n      var targetRatio_1 = initialRatio_1 * finalRatio;\n      var animateConfig = getAnimateCfgWithCallback({\n        animateCfg: animateCfg,\n        callback: function callback() {\n          return _this.emit('viewportchange', {\n            action: 'zoom',\n            matrix: group.getMatrix()\n          });\n        }\n      });\n      group.animate(function (ratio) {\n        if (ratio === 1) {\n          // Reuse the first transformation\n          aniMatrix_1 = matrix;\n        } else {\n          var scale = lerp(initialRatio_1, targetRatio_1, ratio) / aniMatrix_1[0];\n\n          if (center) {\n            aniMatrix_1 = transform(aniMatrix_1, [['t', -center.x, -center.y], ['s', scale, scale], ['t', center.x, center.y]]);\n          } else {\n            aniMatrix_1 = transform(aniMatrix_1, [['s', scale, scale]]);\n          }\n        }\n\n        return {\n          matrix: aniMatrix_1\n        };\n      }, animateConfig);\n    } else {\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'zoom',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n\n    return !failed;\n  };\n  /**\n   * 伸缩视口到一固定比例\n   * @param {number} toRatio 伸缩比例\n   * @param {Point} center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n\n\n  AbstractGraph.prototype.zoomTo = function (toRatio, center, animate, animateCfg) {\n    var ratio = toRatio / this.getZoom();\n    return this.zoom(ratio, center, animate, animateCfg);\n  };\n  /**\n   * 将元素移动到视口中心\n   * @param {Item} item 指定元素\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.focusItem = function (item, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    var isAnimate = false;\n    if (animate) isAnimate = true;else if (animate === undefined) isAnimate = this.get('animate');\n    var curAniamteCfg = {};\n    if (animateCfg) curAniamteCfg = animateCfg;else if (animateCfg === undefined) curAniamteCfg = this.get('animateCfg');\n    viewController.focus(item, isAnimate, curAniamteCfg);\n    this.autoPaint();\n  };\n  /**\n   * 自动重绘\n   * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\n   */\n\n\n  AbstractGraph.prototype.autoPaint = function () {\n    if (this.get('autoPaint')) {\n      this.paint();\n    }\n  };\n  /**\n   * 仅画布重新绘制\n   */\n\n\n  AbstractGraph.prototype.paint = function () {\n    this.emit('beforepaint');\n    this.get('canvas').draw();\n    this.emit('afterpaint');\n  };\n  /**\n   * 将屏幕坐标转换为视口坐标\n   * @param {number} clientX 屏幕x坐标\n   * @param {number} clientY 屏幕y坐标\n   * @return {Point} 视口坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByClient = function (clientX, clientY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByClient(clientX, clientY);\n  };\n  /**\n   * 将绘制坐标转换为屏幕坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {Point} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getClientByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getClientByPoint(x, y);\n  };\n  /**\n   * 将画布坐标转换为绘制坐标\n   * @param {number} canvasX 画布 x 坐标\n   * @param {number} canvasY 画布 y 坐标\n   * @return {object} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByCanvas(canvasX, canvasY);\n  };\n  /**\n   * 将绘制坐标转换为画布坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {object} 画布坐标\n   */\n\n\n  AbstractGraph.prototype.getCanvasByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getCanvasByPoint(x, y);\n  };\n  /**\n   * 获取图内容的中心绘制坐标\n   * @return {object} 中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getGraphCenterPoint = function () {\n    var bbox = this.get('group').getCanvasBBox();\n    return {\n      x: (bbox.minX + bbox.maxX) / 2,\n      y: (bbox.minY + bbox.maxY) / 2\n    };\n  };\n  /**\n   * 获取视口中心绘制坐标\n   * @return {object} 视口中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getViewPortCenterPoint = function () {\n    return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);\n  };\n  /**\n   * 显示元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.showItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, true);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.nodes = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.edges = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.combos = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 隐藏元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.hideItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, false);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.nodes = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.edges = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.combos = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 刷新元素\n   * @param {string|object} item 元素id或元素实例\n   */\n\n\n  AbstractGraph.prototype.refreshItem = function (item) {\n    var itemController = this.get('itemController');\n    itemController.refreshItem(item);\n  };\n  /**\n   * 设置是否在更新/刷新后自动重绘\n   * @param {boolean} auto 自动重绘\n   */\n\n\n  AbstractGraph.prototype.setAutoPaint = function (auto) {\n    var self = this;\n    self.set('autoPaint', auto);\n    var canvas = self.get('canvas');\n    canvas.set('autoDraw', auto);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.remove = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.removeItem(item, stack);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.removeItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var nodeItem = item;\n    if (isString(item)) nodeItem = this.findById(item);\n\n    if (!nodeItem && isString(item)) {\n      console.warn(\"The item \".concat(item, \" to be removed does not exist!\"));\n    } else if (nodeItem) {\n      var type = '';\n      if (nodeItem.getType) type = nodeItem.getType(); // 将删除的元素入栈\n\n      if (stack && this.get('enabledStack')) {\n        var deletedModel = __assign(__assign({}, nodeItem.getModel()), {\n          itemType: type\n        });\n\n        var before = {};\n\n        switch (type) {\n          case 'node':\n            {\n              before.nodes = [deletedModel];\n              before.edges = [];\n              var edges = nodeItem.getEdges();\n\n              for (var i = edges.length - 1; i >= 0; i--) {\n                before.edges.push(__assign(__assign({}, edges[i].getModel()), {\n                  itemType: 'edge'\n                }));\n              }\n\n              break;\n            }\n\n          case 'edge':\n            before.edges = [deletedModel];\n            break;\n\n          case 'combo':\n            before.combos = [deletedModel];\n            break;\n\n          default:\n            break;\n        }\n\n        this.pushStack('delete', {\n          before: before,\n          after: {}\n        });\n      }\n\n      if (type === 'node') {\n        var model = nodeItem.getModel(); // 如果删除的是节点，且该节点存在于某个 Combo 中，则需要先将 node 从 combo 中移除，否则删除节点后，操作 combo 会出错\n\n        if (model.comboId) {\n          this.updateComboTree(nodeItem, undefined, false);\n        }\n      }\n\n      var itemController = this.get('itemController');\n      itemController.removeItem(nodeItem);\n\n      if (type === 'combo') {\n        var newComboTrees = reconstructTree(this.get('comboTrees'));\n        this.set('comboTrees', newComboTrees);\n      }\n    }\n  };\n\n  AbstractGraph.prototype.innerAddItem = function (type, model, itemController) {\n    var _this = this; // 添加节点、边或combo之前，先验证数据是否符合规范\n\n\n    if (!singleDataValidation(type, model)) {\n      return false;\n    }\n\n    if (model.id && this.findById(model.id)) {\n      console.warn(\"This item exists already. Be sure the id %c\".concat(model.id, \"%c is unique.\"), 'font-size: 20px; color: red;', '');\n      return;\n    }\n\n    var item;\n    var comboTrees = this.get('comboTrees') || [];\n\n    if (type === 'combo') {\n      var itemMap_1 = this.get('itemMap');\n      var foundParent_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundParent_1) return; // terminate the forEach after the tree containing the item is done\n\n        traverseTreeUp(ctree, function (child) {\n          // find the parent\n          if (model.parentId === child.id) {\n            foundParent_1 = true;\n\n            var newCombo = __assign({\n              id: model.id,\n              depth: child.depth + 2\n            }, model);\n\n            if (child.children) child.children.push(newCombo);else child.children = [newCombo];\n            model.depth = newCombo.depth;\n            item = itemController.addItem(type, model);\n          }\n\n          var childItem = itemMap_1[child.id]; // after the parent is found, update all the ancestors\n\n          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === 'combo') {\n            itemController.updateCombo(childItem, child.children);\n          }\n\n          return true;\n        });\n      }); // if the parent is not found, add it to the root\n\n      if (!foundParent_1) {\n        var newCombo = __assign({\n          id: model.id,\n          depth: 0\n        }, model);\n\n        model.depth = newCombo.depth;\n        comboTrees.push(newCombo);\n        item = itemController.addItem(type, model);\n      }\n\n      this.set('comboTrees', comboTrees);\n\n      if (model.collapsed) {\n        setTimeout(function () {\n          if (item && !item.destroyed) {\n            _this.collapseCombo(item, false);\n\n            _this.updateCombo(item);\n          }\n        }, 0);\n      }\n    } else if (type === 'node' && isString(model.comboId) && comboTrees) {\n      var parentCombo = this.findById(model.comboId);\n\n      if (parentCombo && parentCombo.getType && parentCombo.getType() !== 'combo') {\n        console.warn(\"'\".concat(model.comboId, \"' is not a id of a combo in the graph, the node will be added without combo.\"));\n      }\n\n      item = itemController.addItem(type, model);\n      var itemMap_2 = this.get('itemMap');\n      var foundParent_2 = false,\n          foundNode_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundNode_1 || foundParent_2) return; // terminate the forEach\n\n        traverseTreeUp(ctree, function (child) {\n          if (child.id === model.id) {\n            // if the item exists in the tree already, terminate\n            foundNode_1 = true;\n            return false;\n          }\n\n          if (model.comboId === child.id && !foundNode_1) {\n            // found the parent, add the item to the children of its parent in the tree\n            foundParent_2 = true;\n            var cloneNode = clone(model);\n            cloneNode.itemType = 'node';\n            if (child.children) child.children.push(cloneNode);else child.children = [cloneNode];\n            cloneNode.depth = child.depth + 1;\n          } // update the size of all the ancestors\n\n\n          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === 'combo') {\n            itemController.updateCombo(itemMap_2[child.id], child.children);\n          }\n\n          return true;\n        });\n      });\n    } else {\n      item = itemController.addItem(type, model);\n    }\n\n    if (type === 'node' && model.comboId || type === 'combo' && model.parentId) {\n      // add the combo to the parent's children array\n      var parentCombo = this.findById(model.comboId || model.parentId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() === 'combo') parentCombo.addChild(item);\n    }\n\n    return item;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.addItem = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController');\n    var item = this.innerAddItem(type, model, itemController);\n\n    if (item === false || item === true) {\n      return item;\n    }\n\n    var combos = this.get('combos');\n\n    if (combos && combos.length > 0) {\n      this.sortCombos();\n    }\n\n    this.autoPaint();\n\n    if (stack && this.get('enabledStack')) {\n      var addedModel = __assign(__assign({}, item.getModel()), {\n        itemType: type\n      });\n\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          after.nodes = [addedModel];\n          break;\n\n        case 'edge':\n          after.edges = [addedModel];\n          break;\n\n        case 'combo':\n          after.combos = [addedModel];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('add', {\n        before: {},\n        after: after\n      });\n    }\n\n    return item;\n  };\n\n  AbstractGraph.prototype.addItems = function (items, stack, sortCombo) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController');\n    var returnItems = []; // 1. add anything that is not an edge.\n    // Add undefined as a placeholder for the next cycle. This way we return items matching the input order\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item.type !== 'edge' && item.type !== 'vedge') {\n        returnItems.push(this.innerAddItem(item.type, item.model, itemController));\n      } else {\n        returnItems.push(undefined);\n      }\n    } // 2. add all the edges\n\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item.type === 'edge' || item.type === 'vedge') {\n        returnItems[i] = this.innerAddItem(item.type, item.model, itemController);\n      }\n    }\n\n    if (sortCombo) {\n      var combos = this.get('combos');\n\n      if (combos && combos.length > 0) {\n        this.sortCombos();\n      }\n    }\n\n    this.autoPaint();\n\n    if (stack && this.get('enabledStack')) {\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n\n      for (var i = 0; i < items.length; i++) {\n        var type = items[i].type;\n        var returnItem = returnItems[i];\n\n        if (!!returnItem && returnItem !== true) {\n          var addedModel = __assign(__assign({}, returnItem.getModel()), {\n            itemType: type\n          });\n\n          switch (type) {\n            case 'node':\n              after.nodes.push(addedModel);\n              break;\n\n            case 'edge':\n              after.edges.push(addedModel);\n              break;\n\n            case 'combo':\n              after.combos.push(addedModel);\n              break;\n\n            default:\n              break;\n          }\n        }\n      }\n\n      this.pushStack('addItems', {\n        before: {},\n        after: after\n      });\n    }\n\n    return returnItems;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.add = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    return this.addItem(type, model, stack, sortCombo);\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   */\n\n\n  AbstractGraph.prototype.updateItem = function (item, cfg, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var currentItem;\n\n    if (isString(item)) {\n      currentItem = this.findById(item);\n    } else {\n      currentItem = item;\n    }\n\n    var UnupdateModel = clone(currentItem.getModel());\n    var type = '';\n    if (currentItem.getType) type = currentItem.getType();\n\n    var states = __spreadArray([], currentItem.getStates(), true);\n\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, false);\n      });\n    }\n\n    itemController.updateItem(currentItem, cfg);\n\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, true);\n      });\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var before = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n\n      var afterModel = __assign({\n        id: UnupdateModel.id\n      }, cfg);\n\n      switch (type) {\n        case 'node':\n          before.nodes.push(UnupdateModel);\n          after.nodes.push(afterModel);\n          break;\n\n        case 'edge':\n          before.edges.push(UnupdateModel);\n          after.edges.push(afterModel);\n          break;\n\n        case 'combo':\n          before.combos.push(UnupdateModel);\n          after.combos.push(afterModel);\n          break;\n\n        default:\n          break;\n      }\n\n      if (type === 'node') {\n        before.nodes.push(UnupdateModel);\n      }\n\n      this.pushStack('update', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.update = function (item, cfg, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.updateItem(item, cfg, stack);\n  };\n  /**\n   * 设置元素状态\n   * @param {Item} item 元素id或元素实例\n   * @param {string} state 状态名称\n   * @param {string | boolean} value 是否启用状态 或 状态值\n   */\n\n\n  AbstractGraph.prototype.setItemState = function (item, state, value) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n    itemController.setItemState(item, state, value);\n    var stateController = this.get('stateController');\n\n    if (isString(value)) {\n      stateController.updateState(item, \"\".concat(state, \":\").concat(value), true);\n    } else {\n      stateController.updateState(item, state, value);\n    }\n  };\n  /**\n   * 将指定状态的优先级提升为最高优先级\n   * @param {Item} item 元素id或元素实例\n   * @param state 状态名称\n   */\n\n\n  AbstractGraph.prototype.priorityState = function (item, state) {\n    var itemController = this.get('itemController');\n    itemController.priorityState(item, state);\n  };\n  /**\n   * 设置视图初始化数据\n   * @param {GraphData} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.data = function (data) {\n    dataValidation(data);\n    this.set('data', data);\n  };\n  /**\n   * 根据data接口的数据渲染视图\n   */\n\n\n  AbstractGraph.prototype.render = function () {\n    var self = this;\n    this.set('comboSorted', false);\n    var data = this.get('data');\n\n    if (this.get('enabledStack')) {\n      // render 之前清空 redo 和 undo 栈\n      this.clearStack();\n    }\n\n    if (!data) {\n      throw new Error('data must be defined first');\n    }\n\n    var _a = data.nodes,\n        nodes = _a === void 0 ? [] : _a,\n        _b = data.edges,\n        edges = _b === void 0 ? [] : _b,\n        _c = data.combos,\n        combos = _c === void 0 ? [] : _c;\n    this.clear(true);\n    this.emit('beforerender');\n    self.addItems(nodes.map(function (node) {\n      return {\n        type: 'node',\n        model: node\n      };\n    }), false, false); // process the data to tree structure\n\n    if ((combos === null || combos === void 0 ? void 0 : combos.length) !== 0) {\n      var comboTrees = plainCombosToTrees(combos, nodes);\n      this.set('comboTrees', comboTrees); // add combos\n\n      self.addCombos(combos);\n    }\n\n    self.addItems(edges.map(function (edge) {\n      return {\n        type: 'edge',\n        model: edge\n      };\n    }), false, false);\n    var animate = self.get('animate');\n\n    if (self.get('fitView') || self.get('fitCenter')) {\n      self.set('animate', false);\n    } // layout\n\n\n    var layoutController = self.get('layoutController');\n\n    if (layoutController) {\n      layoutController.layout(success);\n      if (this.destroyed) return;\n    } else {\n      success();\n    } // 将在 onLayoutEnd 中被调用\n\n\n    function success() {\n      // 自底向上将 collapsed 的 combo 合起\n      (self.get('comboTrees') || []).forEach(function (ctree) {\n        traverseTreeUp(ctree, function (child) {\n          var item = self.findById(child.id);\n\n          if (item.getType() === 'combo' && child.collapsed) {\n            self.collapseCombo(child.id, false);\n            self.updateCombo(item);\n          }\n\n          return true;\n        });\n      }); // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\n\n      if (self.get('fitView')) {\n        self.fitView();\n      } else if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n\n      self.autoPaint();\n      self.emit('afterrender');\n\n      if (self.get('fitView') || self.get('fitCenter')) {\n        self.set('animate', animate);\n      }\n\n      setTimeout(function () {\n        var _a;\n\n        (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n          combo.set('animate', true);\n        });\n      }, 0);\n    }\n\n    if (!this.get('groupByTypes')) {\n      if (combos && combos.length !== 0) {\n        this.sortCombos();\n      } else {\n        // 为提升性能，选择数量少的进行操作\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\n          var nodesArr = this.getNodes(); // 遍历节点实例，将所有节点提前。\n\n          nodesArr.forEach(function (node) {\n            node.toFront();\n          });\n        } else {\n          var edgesArr = this.getEdges(); // 遍历节点实例，将所有节点提前。\n\n          edgesArr.forEach(function (edge) {\n            edge.toBack();\n          });\n        }\n      }\n    }\n\n    if (this.get('enabledStack')) {\n      this.pushStack('render');\n    }\n  };\n  /**\n   * 接收数据进行渲染\n   * @Param {Object} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.read = function (data) {\n    this.data(data);\n    this.render();\n  }; // 比较item\n\n\n  AbstractGraph.prototype.diffItems = function (type, items, models) {\n    var self = this;\n    var item;\n    var itemMap = this.get('itemMap');\n    each(models, function (model) {\n      item = itemMap[model.id];\n\n      if (item) {\n        if (self.get('animate') && type === NODE) {\n          var containerMatrix = item.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          item.set('originAttrs', {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          });\n        }\n\n        self.updateItem(item, model, false);\n      } else {\n        item = self.addItem(type, model, false);\n      }\n\n      if (item) items[\"\".concat(type, \"s\")].push(item);\n    });\n  };\n  /**\n   * 更改源数据，根据新数据重新渲染视图\n   * @param {GraphData | TreeGraphData} data 源数据\n   * @param {boolean} 是否入栈，默认为true\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeData = function (propsData, stack) {\n    var _this = this;\n\n    var _a;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n    var data = propsData || self.get('data');\n\n    if (!dataValidation(data)) {\n      return this;\n    }\n\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('changedata', {\n        before: self.save(),\n        after: data\n      });\n    }\n\n    this.set('comboSorted', false); // 删除 hulls\n\n    this.removeHulls(); // 更改数据源后，取消所有状态\n\n    this.getNodes().map(function (node) {\n      return self.clearItemStates(node);\n    });\n    this.getEdges().map(function (edge) {\n      return self.clearItemStates(edge);\n    });\n    var canvas = this.get('canvas');\n    var localRefresh = canvas.get('localRefresh');\n    canvas.set('localRefresh', false);\n\n    if (!self.get('data')) {\n      self.data(data);\n      self.render();\n    }\n\n    var itemMap = this.get('itemMap');\n    var items = {\n      nodes: [],\n      edges: []\n    };\n    var combosData = data.combos;\n\n    if (combosData) {\n      var comboTrees = plainCombosToTrees(combosData, data.nodes);\n      this.set('comboTrees', comboTrees);\n    } else {\n      this.set('comboTrees', []);\n    }\n\n    this.diffItems('node', items, data.nodes);\n    each(itemMap, function (item, id) {\n      itemMap[id].getModel().depth = 0;\n      if (item.getType && item.getType() === 'edge') return;\n\n      if (item.getType && item.getType() === 'combo') {\n        delete itemMap[id];\n        item.destroy();\n      } else if (items.nodes.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    }); // clear the destroyed combos here to avoid removing sub nodes before removing the parent combo\n\n    var comboItems = this.getCombos();\n    var combosLength = comboItems.length;\n\n    for (var i = combosLength - 1; i >= 0; i--) {\n      if (comboItems[i].destroyed) {\n        comboItems.splice(i, 1);\n      }\n    } // process the data to tree structure\n\n\n    if (combosData) {\n      // add combos\n      self.addCombos(combosData);\n\n      if (!this.get('groupByTypes')) {\n        this.sortCombos();\n      }\n    }\n\n    this.diffItems('edge', items, data.edges);\n    each(itemMap, function (item, id) {\n      if (item.getType && (item.getType() === 'node' || item.getType() === 'combo')) return;\n\n      if (items.edges.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    }); // 自底向上将 collapsed 的 combo 合起\n\n    (this.get('comboTrees') || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        var item = _this.findById(child.id);\n\n        if (item.getType() === 'combo' && child.collapsed) {\n          _this.collapseCombo(child.id, false);\n        }\n\n        return true;\n      });\n    });\n    this.set({\n      nodes: items.nodes,\n      edges: items.edges\n    });\n    var layoutController = this.get('layoutController');\n\n    if (layoutController) {\n      layoutController.changeData(function () {\n        setTimeout(function () {\n          var _a;\n\n          (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n            combo.set('animate', true);\n          });\n        }, 0);\n      });\n\n      if (self.get('animate') && !layoutController.getLayoutType()) {\n        // 如果没有指定布局\n        self.positionsAnimate();\n        (_a = self.getCombos()) === null || _a === void 0 ? void 0 : _a.forEach(function (combo) {\n          return combo.set('animate', true);\n        });\n      } else {\n        self.autoPaint();\n      }\n    }\n\n    setTimeout(function () {\n      canvas.set('localRefresh', localRefresh);\n    }, 16);\n    return this;\n  };\n  /**\n   * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\n   * @param {ComboConfig[]} combos 平铺的 combos 数据\n   */\n\n\n  AbstractGraph.prototype.addCombos = function (combos) {\n    var self = this;\n    var comboTrees = self.get('comboTrees');\n    var itemController = this.get('itemController');\n    itemController.addCombos(comboTrees, combos);\n  };\n  /**\n   * 根据已经存在的节点或 combo 创建新的 combo\n   * @param combo combo ID 或 Combo 配置\n   * @param children 添加到 Combo 中的元素，包括节点和 combo\n   */\n\n\n  AbstractGraph.prototype.createCombo = function (combo, children) {\n    var _this = this;\n\n    this.set('comboSorted', false); // step 1: 创建新的 Combo\n\n    var comboId = '';\n    var comboConfig;\n    if (!combo) return;\n\n    if (isString(combo)) {\n      comboId = combo;\n      comboConfig = {\n        id: combo\n      };\n    } else {\n      comboId = combo.id;\n\n      if (!comboId) {\n        console.warn('Create combo failed. Please assign a unique string id for the adding combo.');\n        return;\n      }\n\n      comboConfig = combo;\n    } // step2: 更新 children，根据类型添加 comboId 或 parentId\n\n\n    var trees = children.map(function (elementId) {\n      var item = _this.findById(elementId);\n\n      var model = item.getModel();\n      var type = '';\n      if (item.getType) type = item.getType();\n      var cItem = {\n        id: item.getID(),\n        itemType: type\n      };\n\n      if (type === 'combo') {\n        cItem.parentId = comboId;\n        model.parentId = comboId;\n      } else if (type === 'node') {\n        cItem.comboId = comboId;\n        model.comboId = comboId;\n      }\n\n      return cItem;\n    });\n    comboConfig.children = trees; // step 3: 添加 Combo，addItem 时会将子将元素添加到 Combo 中\n\n    this.addItem('combo', comboConfig, false);\n    this.set('comboSorted', false); // step4: 更新 comboTrees 结构\n\n    var comboTrees = this.get('comboTrees');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (child.id === comboId) {\n          child.itemType = 'combo';\n          child.children = trees;\n          return false;\n        }\n\n        return true;\n      });\n    });\n\n    if (comboTrees) {\n      this.sortCombos();\n    }\n  };\n  /**\n   * 解散 combo\n   * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\n   */\n\n\n  AbstractGraph.prototype.uncombo = function (combo) {\n    var _this = this;\n\n    var _a;\n\n    var self = this;\n    var comboItem = combo;\n\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item is not a combo!');\n      return;\n    }\n\n    var parentId = comboItem.getModel().parentId;\n    var comboTrees = self.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n    var itemMap = this.get('itemMap');\n    var comboId = comboItem.get('id');\n    var treeToBeUncombo;\n    var brothers = [];\n    var comboItems = this.get('combos');\n    var parentItem = this.findById(parentId);\n    comboTrees.forEach(function (ctree) {\n      if (treeToBeUncombo) return; // terminate the forEach\n\n      traverseTreeUp(ctree, function (subtree) {\n        var _a; // find the combo to be uncomboed, delete the combo from map and cache\n\n\n        if (subtree.id === comboId) {\n          treeToBeUncombo = subtree; // delete the related edges\n\n          var edgeIds = comboItem.getEdges().map(function (edge) {\n            return edge.getID();\n          });\n          edgeIds.forEach(function (edgeId) {\n            _this.removeItem(edgeId, false);\n          });\n          var index = comboItems.indexOf(comboItem);\n          comboItems.splice(index, 1);\n          delete itemMap[comboId];\n          comboItem.destroy();\n\n          _this.emit('afterremoveitem', {\n            item: comboItem,\n            type: 'combo'\n          });\n        } // find the parent to remove the combo from the combo's brothers array and add the combo's children to the combo's brothers array in the tree\n\n\n        if (parentId && treeToBeUncombo && subtree.id === parentId) {\n          parentItem.removeCombo(comboItem);\n          brothers = subtree.children; // the combo's brothers\n          // remove the combo from its brothers array\n\n          var index = brothers.indexOf(treeToBeUncombo);\n\n          if (index !== -1) {\n            brothers.splice(index, 1);\n          } // append the combo's children to the combo's brothers array\n\n\n          (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            var item = _this.findById(child.id);\n\n            var childModel = item.getModel();\n\n            if (item.getType && item.getType() === 'combo') {\n              child.parentId = parentId;\n              delete child.comboId;\n              childModel.parentId = parentId; // update the parentId of the model\n\n              delete childModel.comboId;\n            } else if (item.getType && item.getType() === 'node') {\n              child.comboId = parentId;\n              childModel.comboId = parentId; // update the parentId of the model\n            }\n\n            parentItem.addChild(item);\n            brothers.push(child);\n          });\n          return false;\n        }\n\n        return true;\n      });\n    }); // if the parentId is not found, remove the combo from the roots\n\n    if (!parentId && treeToBeUncombo) {\n      var index = comboTrees.indexOf(treeToBeUncombo);\n      comboTrees.splice(index, 1); // modify the parentId of the children\n\n      (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n        child.parentId = undefined;\n\n        var childModel = _this.findById(child.id).getModel();\n\n        delete childModel.parentId; // update the parentId of the model\n\n        delete childModel.comboId; // update the comboId of the model\n\n        if (child.itemType !== 'node') comboTrees.push(child);\n      });\n    }\n  };\n  /**\n   * 根据 combo 位置更新内部节点位置 followCombo = true\n   * 或根据内部元素的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围，followCombo = false\n   */\n\n\n  AbstractGraph.prototype.updateCombos = function (followCombo) {\n    var _this = this;\n\n    if (followCombo === void 0) {\n      followCombo = false;\n    }\n\n    var self = this;\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        var _a;\n\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (((_a = childItem === null || childItem === void 0 ? void 0 : childItem.getType) === null || _a === void 0 ? void 0 : _a.call(childItem)) === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true);\n\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, false);\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children, followCombo); // 更新 Combo 后，还原已有的状态\n\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, true);\n          });\n        }\n\n        return true;\n      });\n    });\n    self.sortCombos();\n  };\n  /**\n   * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\n   * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\n   */\n\n\n  AbstractGraph.prototype.updateCombo = function (combo) {\n    var _this = this;\n\n    var self = this;\n    var comboItem = combo;\n    var comboId;\n\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item to be updated is not a combo!');\n      return;\n    }\n\n    comboId = comboItem.get('id');\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true); // || !item.getStateStyle(stateName)\n\n\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, false);\n            }\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\n\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, true);\n            }\n          });\n          if (comboId) comboId = child.parentId;\n        }\n\n        return true;\n      });\n    });\n  };\n  /**\n   * 更新树结构，例如移动子树等\n   * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\n   * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\n   */\n\n\n  AbstractGraph.prototype.updateComboTree = function (item, parentId, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n    this.set('comboSorted', false);\n    var uItem;\n\n    if (isString(item)) {\n      uItem = self.findById(item);\n    } else {\n      uItem = item;\n    }\n\n    var model = uItem.getModel();\n    var oldParentId = model.comboId || model.parentId;\n    var type = '';\n    if (uItem.getType) type = uItem.getType(); // 若 item 是 Combo，且 parentId 是其子孙 combo 的 id，则警告并终止\n\n    if (parentId && type === 'combo') {\n      var comboTrees = this.get('comboTrees');\n      var valid_1 = true;\n      var itemSubTree_1;\n      (comboTrees || []).forEach(function (ctree) {\n        if (itemSubTree_1) return;\n        traverseTree(ctree, function (subTree) {\n          if (itemSubTree_1) return; // 找到从 item 开始的子树\n\n          if (subTree.id === uItem.getID()) {\n            itemSubTree_1 = subTree;\n          }\n\n          return true;\n        });\n      }); // 在以 item 为根的子树中寻找与 parentId 相同的后继元素\n\n      traverseTree(itemSubTree_1, function (subTree) {\n        if (subTree.id === parentId) {\n          valid_1 = false;\n          return false;\n        }\n\n        return true;\n      }); // parentId 是 item 的一个后继元素，不能进行更新\n\n      if (!valid_1) {\n        console.warn('Failed to update the combo tree! The parentId points to a descendant of the combo!');\n        return;\n      }\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var beforeData = {},\n          afterData = {};\n\n      if (type === 'combo') {\n        beforeData.combos = [{\n          id: model.id,\n          parentId: model.parentId\n        }];\n        afterData.combos = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      } else if (type === 'node') {\n        beforeData.nodes = [{\n          id: model.id,\n          parentId: model.comboId\n        }];\n        afterData.nodes = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      }\n\n      this.pushStack('updateComboTree', {\n        before: beforeData,\n        after: afterData\n      });\n    } // 当 combo 存在 parentId 或 comboId 时，才将其移除\n\n\n    if (model.parentId || model.comboId) {\n      var combo = this.findById(model.parentId || model.comboId);\n\n      if (combo) {\n        combo.removeChild(uItem);\n      }\n    }\n\n    if (type === 'combo') {\n      model.parentId = parentId;\n    } else if (type === 'node') {\n      model.comboId = parentId;\n    } // 只有当移入到指定 combo 时才添加\n\n\n    if (parentId) {\n      var parentCombo = this.findById(parentId);\n\n      if (parentCombo) {\n        // 将元素添加到 parentCombo 中\n        parentCombo.addChild(uItem);\n      }\n    } // 如果原先有父亲 combo，则从原父 combo 的子元素数组中删除\n\n\n    if (oldParentId) {\n      var parentCombo = this.findById(oldParentId);\n\n      if (parentCombo) {\n        // 将元素从 parentCombo 中移除\n        parentCombo.removeChild(uItem);\n      }\n    }\n\n    var newComboTrees = reconstructTree(this.get('comboTrees'), model.id, parentId);\n    this.set('comboTrees', newComboTrees);\n    this.updateCombos();\n  };\n  /**\n   * 导出图数据\n   * @return {object} data\n   */\n\n\n  AbstractGraph.prototype.save = function () {\n    var nodes = [];\n    var edges = [];\n    var combos = [];\n    each(this.get('nodes'), function (node) {\n      nodes.push(node.getModel());\n    });\n    each(this.get('edges'), function (edge) {\n      edges.push(edge.getModel());\n    });\n    each(this.get('combos'), function (combo) {\n      combos.push(combo.getModel());\n    });\n    return {\n      nodes: nodes,\n      edges: edges,\n      combos: combos\n    };\n  };\n  /**\n   * 改变画布大小\n   * @param  {number} width  画布宽度\n   * @param  {number} height 画布高度\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeSize = function (width, height) {\n    var viewController = this.get('viewController');\n    viewController.changeSize(width, height);\n    return this;\n  };\n  /**\n   * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\n   */\n\n\n  AbstractGraph.prototype.refresh = function () {\n    var self = this;\n    self.emit('beforegraphrefresh');\n\n    if (self.get('animate')) {\n      self.positionsAnimate();\n    } else {\n      var nodes = self.get('nodes');\n      var edges = self.get('edges');\n      var vedges = self.get('edges');\n      each(nodes, function (node) {\n        node.refresh();\n      });\n      each(edges, function (edge) {\n        edge.refresh();\n      });\n      each(vedges, function (vedge) {\n        vedge.refresh();\n      });\n    }\n\n    self.emit('aftergraphrefresh');\n    self.autoPaint();\n  };\n  /**\n   * 获取当前图中所有节点的item实例\n   * @return {INode} item数组\n   */\n\n\n  AbstractGraph.prototype.getNodes = function () {\n    return this.get('nodes');\n  };\n  /**\n   * 获取当前图中所有边的item实例\n   * @return {IEdge} item数组\n   */\n\n\n  AbstractGraph.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取图中所有的 combo 实例\n   */\n\n\n  AbstractGraph.prototype.getCombos = function () {\n    return this.get('combos');\n  };\n  /**\n   * 获取指定 Combo 中所有的节点\n   * @param comboId combo ID\n   */\n\n\n  AbstractGraph.prototype.getComboChildren = function (combo) {\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo does not exist!');\n      return;\n    }\n\n    return combo.getChildren();\n  };\n  /**\n   * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\n   */\n\n\n  AbstractGraph.prototype.positionsAnimate = function (referComboModel) {\n    var self = this;\n    self.emit('beforeanimate');\n    var animateCfg = self.get('animateCfg');\n    var onFrame = animateCfg.onFrame;\n    var nodes = referComboModel ? self.getNodes().concat(self.getCombos()) : self.getNodes();\n    var toNodes = nodes.map(function (node) {\n      var model = node.getModel();\n      return {\n        id: model.id,\n        x: model.x,\n        y: model.y\n      };\n    });\n    self.stopAnimate();\n    var canvas = self.get('canvas');\n    self.animating = true;\n    canvas.animate(function (ratio) {\n      each(toNodes, function (data) {\n        var node = self.findById(data.id);\n\n        if (!node || node.destroyed) {\n          return;\n        }\n\n        var originAttrs = node.get('originAttrs');\n        var model = node.get('model');\n        var containerMatrix = node.getContainer().getMatrix();\n\n        if (originAttrs === undefined || originAttrs === null) {\n          // 变换前存在位置，设置到 originAttrs 上。否则标记 0 表示变换前不存在位置，不需要计算动画\n          if (containerMatrix) {\n            originAttrs = {\n              x: containerMatrix[6],\n              y: containerMatrix[7]\n            };\n          }\n\n          node.set('originAttrs', originAttrs || 0);\n        }\n\n        if (onFrame) {\n          var attrs = onFrame(node, ratio, data, originAttrs || {\n            x: 0,\n            y: 0\n          });\n          node.set('model', Object.assign(model, attrs));\n        } else if (originAttrs) {\n          // 变换前存在位置，进行动画\n          model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;\n          model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;\n        } else {\n          // 若在变换前不存在位置信息，则直接放到最终位置上\n          model.x = data.x;\n          model.y = data.y;\n        }\n      });\n      self.refreshPositions(referComboModel);\n    }, {\n      duration: animateCfg.duration,\n      easing: animateCfg.easing,\n      callback: function callback() {\n        each(nodes, function (node) {\n          node.set('originAttrs', null);\n        });\n\n        if (animateCfg.callback) {\n          animateCfg.callback();\n        }\n\n        self.emit('afteranimate');\n        self.animating = false;\n      }\n    });\n  };\n  /**\n   * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\n   */\n\n\n  AbstractGraph.prototype.refreshPositions = function (referComboModel) {\n    var self = this;\n    self.emit('beforegraphrefreshposition');\n    var nodes = self.get('nodes');\n    var edges = self.get('edges');\n    var vedges = self.get('vedges');\n    var combos = self.get('combos');\n    var model;\n    var updatedNodes = {};\n\n    var updateItems = function updateItems(items) {\n      each(items, function (item) {\n        model = item.getModel();\n        var originAttrs = item.get('originAttrs');\n\n        if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {\n          return;\n        }\n\n        var changed = item.updatePosition({\n          x: model.x,\n          y: model.y\n        });\n        updatedNodes[model.id] = changed;\n        if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;\n      });\n    };\n\n    updateItems(nodes);\n\n    if (combos && combos.length !== 0) {\n      if (referComboModel) {\n        updateItems(combos);\n        self.updateCombos();\n      } else {\n        self.updateCombos();\n      }\n    }\n\n    each(edges, function (edge) {\n      var sourceModel = edge.getSource().getModel();\n      var target = edge.getTarget(); // 避免 target 是纯对象的情况下调用 getModel 方法\n      // 拖动生成边的时候 target 会是纯对象\n\n      if (!isPlainObject(target)) {\n        var targetModel = target.getModel();\n\n        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {\n          edge.refresh();\n        }\n      }\n    });\n    each(vedges, function (vedge) {\n      vedge.refresh();\n    });\n    self.emit('aftergraphrefreshposition');\n    self.autoPaint();\n  };\n\n  AbstractGraph.prototype.stopAnimate = function () {\n    if (this.isAnimating()) {\n      this.get('canvas').stopAnimate();\n    }\n  };\n\n  AbstractGraph.prototype.isAnimating = function () {\n    return this.animating;\n  };\n  /**\n   * 获取当前视口伸缩比例\n   * @return {number} 比例\n   */\n\n\n  AbstractGraph.prototype.getZoom = function () {\n    var matrix = this.get('group').getMatrix();\n    return matrix ? matrix[0] : 1;\n  };\n  /**\n   * 获取当前的行为模式\n   * @return {string} 当前行为模式\n   */\n\n\n  AbstractGraph.prototype.getCurrentMode = function () {\n    var modeController = this.get('modeController');\n    return modeController.getMode();\n  };\n  /**\n   * 切换行为模式\n   * @param {string} mode 指定模式\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.setMode = function (mode) {\n    var modeController = this.get('modeController');\n    modeController.setMode(mode);\n    return this;\n  };\n  /**\n   * 清除画布元素\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.clear = function (avoidEmit) {\n    var _a;\n\n    if (avoidEmit === void 0) {\n      avoidEmit = false;\n    }\n\n    (_a = this.get('canvas')) === null || _a === void 0 ? void 0 : _a.clear();\n    this.initGroups(); // 清空画布时同时清除数据\n\n    this.set({\n      itemMap: {},\n      nodes: [],\n      edges: [],\n      groups: [],\n      combos: [],\n      comboTrees: []\n    });\n    if (!avoidEmit) this.emit('afterrender');\n    return this;\n  };\n  /**\n   * 更换布局配置项\n   * @param {object} cfg 新布局配置项\n   * @param {'center' | 'begin'} align 对齐方式，可选中心（center）对齐到对齐点，或左上角（begin）对齐到对齐点\n   * @param {IPoint} alignPoint 画布上的对齐点，为 Canvas 坐标系（Canvas DOM）\n   * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\n   * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\n   */\n\n\n  AbstractGraph.prototype.updateLayout = function (cfg, align, alignPoint, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var layoutController = this.get('layoutController');\n\n    if (isString(cfg)) {\n      cfg = {\n        type: cfg\n      };\n    } // align the graph after layout\n\n\n    if (align) {\n      var toPoint_1 = alignPoint;\n\n      if (!toPoint_1) {\n        if (align === 'begin') toPoint_1 = {\n          x: 0,\n          y: 0\n        };else toPoint_1 = {\n          x: this.getWidth() / 2,\n          y: this.getHeight() / 2\n        };\n      } // translate to point coordinate system\n\n\n      toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);\n      var forceTypes = ['force', 'gForce', 'fruchterman']; // if it is force layout, only center takes effect, and assign center force\n\n      if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {\n        cfg.center = [toPoint_1.x, toPoint_1.y];\n      } else {\n        this.once('afterlayout', function (e) {\n          var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];\n          toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];\n\n          var _a = _this.getGroup().getCanvasBBox(),\n              minX = _a.minX,\n              maxX = _a.maxX,\n              minY = _a.minY,\n              maxY = _a.maxY;\n\n          var bboxPoint = {\n            x: (minX + maxX) / 2,\n            y: (minY + maxY) / 2\n          };\n\n          if (align === 'begin') {\n            bboxPoint.x = minX;\n            bboxPoint.y = minY;\n          }\n\n          _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);\n        });\n      }\n    }\n\n    var oriLayoutCfg = __assign({}, this.get('layout'));\n\n    var layoutCfg = {};\n    Object.assign(layoutCfg, oriLayoutCfg, cfg);\n    if (cfg.pipes && !cfg.type) delete layoutCfg.type;else if (!cfg.pipes && layoutCfg.type) delete layoutCfg.pipes;\n    this.set('layout', layoutCfg);\n    if (!layoutController) return;\n\n    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {\n      // no type or same type, or switch the gpu and cpu, update layout\n      layoutController.updateLayoutCfg(layoutCfg);\n    } else {\n      // has different type, change layout\n      layoutController.changeLayout(layoutCfg);\n    }\n\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('layout', {\n        before: oriLayoutCfg,\n        after: layoutCfg\n      });\n    }\n  };\n  /**\n   * 销毁布局，changeData 时不会再使用原来的布局方法对新数据进行布局\n   */\n\n\n  AbstractGraph.prototype.destroyLayout = function () {\n    var layoutController = this.get('layoutController');\n    layoutController === null || layoutController === void 0 ? void 0 : layoutController.destroyLayout();\n  };\n  /**\n   * 重新以当前示例中配置的属性进行一次布局\n   */\n\n\n  AbstractGraph.prototype.layout = function () {\n    var _a;\n\n    var layoutController = this.get('layoutController');\n    var layoutCfg = this.get('layout');\n    if (!layoutCfg || !layoutController) return;\n\n    if (layoutCfg.workerEnabled) {\n      // 如果使用web worker布局\n      layoutController.layout();\n      return;\n    }\n\n    if ((_a = layoutController.layoutMethods) === null || _a === void 0 ? void 0 : _a.length) {\n      layoutController.relayout(true);\n    } else {\n      layoutController.layout();\n    }\n  };\n  /**\n   * 收起指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.collapseCombo = function (combo, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (this.destroyed) return;\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo) {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.collapseCombo(combo, stack);\n    comboModel.collapsed = true; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cNodesCombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate the forEach\n\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false; // if the combo is found\n\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          // if the combo is found, concat the descendant nodes and combos\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cNodesCombos = cNodesCombos.concat(item.getNodes());\n            cNodesCombos = cNodesCombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var addedVEdgeMap = {};\n    edges.forEach(function (edge) {\n      var _a = edge.getModel(),\n          isVEdge = _a.isVEdge,\n          _b = _a.size,\n          size = _b === void 0 ? 1 : _b;\n\n      if (edge.isVisible() && !isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var otherEnd = null;\n      var otherEndIsSource;\n\n      if (source.getModel().id === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {\n        // source is the current combo, or descent node/combo is the source but not the target)\n        otherEnd = target;\n        otherEndIsSource = false;\n      } else if (target.getModel().id === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // target is the current combo, or descent node/combo is the target but not the source)\n        otherEnd = source;\n        otherEndIsSource = true;\n      }\n\n      if (otherEnd) {\n        if (isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var otherEndModel = otherEnd.getModel();\n\n        while (!otherEnd.isVisible()) {\n          var otherEndPId = otherEndModel.parentId,\n              otherEndCId = otherEndModel.comboId;\n          var otherEndParentId = otherEndPId || otherEndCId;\n          otherEnd = _this.findById(otherEndParentId);\n          if (!otherEnd || !otherEndParentId) return; // all the ancestors are hidden, then ignore the edge\n\n          otherEndModel = otherEnd.getModel();\n        }\n\n        var otherEndId = otherEndModel.id;\n        var vEdgeInfo = otherEndIsSource ? {\n          source: otherEndId,\n          target: comboModel.id,\n          size: size,\n          isVEdge: true\n        } : {\n          source: comboModel.id,\n          target: otherEndId,\n          size: size,\n          isVEdge: true\n        };\n        var key = \"\".concat(vEdgeInfo.source, \"-\").concat(vEdgeInfo.target);\n\n        if (addedVEdgeMap[key]) {\n          addedVEdgeMap[key].size += size;\n          return;\n        }\n\n        addedVEdgeMap[key] = vEdgeInfo;\n      }\n    }); // update the width of the virtual edges, which is the sum of merged actual edges\n    // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n    this.addItems(Object.values(addedVEdgeMap).map(function (edgeInfo) {\n      return {\n        type: 'vedge',\n        model: edgeInfo\n      };\n    }), false);\n    this.emit('aftercollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n  };\n  /**\n   * 展开指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.expandCombo = function (combo, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.expandCombo(combo, stack);\n    comboModel.collapsed = false; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cNodesCombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate\n\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cNodesCombos = cNodesCombos.concat(item.getNodes());\n            cNodesCombos = cNodesCombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var addedVEdgeMap = {};\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var sourceId = source.get('id');\n      var targetId = target.get('id');\n      var otherEnd = null;\n      var otherEndIsSource;\n\n      if (sourceId === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {\n        // the source is in the combo, the target is not\n        otherEnd = target;\n        otherEndIsSource = false;\n      } else if (targetId === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // the target is in the combo, the source is not\n        otherEnd = source;\n        otherEndIsSource = true;\n      } else if (cNodesCombos.includes(source) && cNodesCombos.includes(target)) {\n        // both source and target are in the combo, if the target and source are both visible, show the edge\n        if (source.isVisible() && target.isVisible()) {\n          edge.show();\n        }\n      }\n\n      if (otherEnd) {\n        var _a = edge.getModel(),\n            isVEdge = _a.isVEdge,\n            _b = _a.size,\n            size = _b === void 0 ? 1 : _b; // ignore the virtual edges\n\n\n        if (isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var otherEndModel = otherEnd.getModel(); // find the nearest visible ancestor\n\n        while (!otherEnd.isVisible()) {\n          var otherEndPId = otherEndModel.parentId,\n              otherEndCId = otherEndModel.comboId;\n          var otherEndParentId = otherEndPId || otherEndCId;\n          otherEnd = _this.findById(otherEndParentId);\n\n          if (!otherEnd || !otherEndParentId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          otherEndModel = otherEnd.getModel();\n        }\n\n        var otherEndId = otherEndModel.id;\n        var selfEnd = otherEndIsSource ? target : source;\n        var selfEndModel = selfEnd.getModel(); // find the nearest visible ancestor\n\n        while (!selfEnd.isVisible()) {\n          var selfEndPId = otherEndModel.parentId,\n              selfEndCId = otherEndModel.comboId;\n          var selfEndParentId = selfEndPId || selfEndCId;\n          selfEnd = _this.findById(selfEndParentId);\n\n          if (!selfEnd || !selfEndParentId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (selfEndModel.comboId === comboModel.id || selfEndModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          selfEndModel = selfEnd.getModel();\n        }\n\n        var selfEndId = selfEndModel.id;\n\n        if (otherEndId) {\n          var vEdgeInfo = otherEndIsSource ? {\n            source: otherEndId,\n            target: selfEndId,\n            isVEdge: true,\n            size: size\n          } : {\n            source: selfEndId,\n            target: otherEndId,\n            isVEdge: true,\n            size: size\n          };\n          var vedgeId = \"\".concat(vEdgeInfo.source, \"-\").concat(vEdgeInfo.target); // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n          if (addedVEdgeMap[vedgeId]) {\n            addedVEdgeMap[vedgeId].size += size;\n            return;\n          }\n\n          addedVEdgeMap[vedgeId] = vEdgeInfo;\n        }\n      }\n    });\n    this.addItems(Object.values(addedVEdgeMap).map(function (edgeInfo) {\n      return {\n        type: 'vedge',\n        model: edgeInfo\n      };\n    }), false);\n    this.emit('aftercollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n  };\n\n  AbstractGraph.prototype.collapseExpandCombo = function (combo, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') return;\n    var comboModel = combo.getModel(); // if one ancestor combo of the combo is collapsed, it should not be collapsed or expanded\n\n    var parentItem = this.findById(comboModel.parentId);\n\n    while (parentItem) {\n      var parentModel = parentItem.getModel();\n\n      if (parentModel.collapsed) {\n        console.warn(\"Fail to expand the combo since it's ancestor combo is collapsed.\");\n        parentItem = undefined;\n        return;\n      }\n\n      parentItem = this.findById(parentModel.parentId);\n    }\n\n    var collapsed = comboModel.collapsed; // 该群组已经处于收起状态，需要展开\n\n    if (collapsed) {\n      this.expandCombo(combo, stack);\n    } else {\n      this.collapseCombo(combo, stack);\n    }\n\n    this.updateCombo(combo);\n  };\n  /**\n   * 获取节点所有的邻居节点\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @returns {INode[]}\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNeighbors = function (node, type) {\n    var item = node;\n\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n\n    return item.getNeighbors(type);\n  };\n  /**\n   * 获取 node 的度数\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\n   * @returns {Number | Object} 该节点的度数\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNodeDegree = function (node, type, refresh) {\n    if (type === void 0) {\n      type = undefined;\n    }\n\n    if (refresh === void 0) {\n      refresh = false;\n    }\n\n    var item = node;\n\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n\n    var degrees = this.get('degrees');\n\n    if (!degrees || refresh) {\n      degrees = getDegree(this.save());\n      this.set('degrees', degrees);\n    }\n\n    var nodeDegrees = degrees[item.getID()];\n    var res = 0; // 如果是通过 addItem 后面新增加的节点，此时它的所有度数都为 0\n\n    if (!nodeDegrees) {\n      return 0;\n    }\n\n    switch (type) {\n      case 'in':\n        res = nodeDegrees.inDegree;\n        break;\n\n      case 'out':\n        res = nodeDegrees.outDegree;\n        break;\n\n      case 'all':\n        res = nodeDegrees;\n        break;\n\n      default:\n        res = nodeDegrees.degree;\n        break;\n    }\n\n    return res;\n  };\n\n  AbstractGraph.prototype.getUndoStack = function () {\n    return this.undoStack;\n  };\n\n  AbstractGraph.prototype.getRedoStack = function () {\n    return this.redoStack;\n  };\n  /**\n   * 获取 undo 和 redo 栈的数据\n   */\n\n\n  AbstractGraph.prototype.getStackData = function () {\n    if (!this.get('enabledStack')) {\n      return null;\n    }\n\n    return {\n      undoStack: this.undoStack.toArray(),\n      redoStack: this.redoStack.toArray()\n    };\n  };\n  /**\n   * 清空 undo stack & redo stack\n   */\n\n\n  AbstractGraph.prototype.clearStack = function () {\n    if (this.get('enabledStack')) {\n      this.undoStack.clear();\n      this.redoStack.clear();\n    }\n  };\n  /**\n   * 将操作类型和操作数据入栈\n   * @param action 操作类型\n   * @param data 入栈的数据\n   * @param stackType 栈的类型\n   */\n\n\n  AbstractGraph.prototype.pushStack = function (action, data, stackType) {\n    if (action === void 0) {\n      action = 'update';\n    }\n\n    if (stackType === void 0) {\n      stackType = 'undo';\n    }\n\n    if (!this.get('enabledStack')) {\n      console.warn('请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !');\n      return;\n    }\n\n    var stackData = data ? clone(data) : {\n      before: {},\n      after: clone(this.save())\n    };\n\n    if (stackType === 'redo') {\n      this.redoStack.push({\n        action: action,\n        data: stackData\n      });\n    } else {\n      this.undoStack.push({\n        action: action,\n        data: stackData\n      });\n    }\n\n    this.emit('stackchange', {\n      undoStack: this.undoStack,\n      redoStack: this.redoStack\n    });\n  };\n  /**\n   * 获取邻接矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 邻接矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getAdjMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    return currentAdjMatrix;\n  };\n  /**\n   * 获取最短路径矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 最短路径矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getShortestPathMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    var currentShourtestPathMatrix = this.get('shortestPathMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    if (!currentShourtestPathMatrix || !cache) {\n      currentShourtestPathMatrix = floydWarshall(this.save(), directed);\n      this.set('shortestPathMatrix', currentShourtestPathMatrix);\n    }\n\n    return currentShourtestPathMatrix;\n  };\n  /**\n   * 重新定义监听函数，复写参数类型\n   */\n\n\n  AbstractGraph.prototype.on = function (eventName, callback, once) {\n    return _super.prototype.on.call(this, eventName, callback, once);\n  };\n  /**\n   * 销毁画布\n   */\n\n\n  AbstractGraph.prototype.destroy = function () {\n    var _a, _b, _c, _d, _e;\n\n    this.clear(); // 清空栈数据\n\n    this.clearStack();\n    (_a = this.get('itemController')) === null || _a === void 0 ? void 0 : _a.destroy();\n    (_b = this.get('modeController')) === null || _b === void 0 ? void 0 : _b.destroy();\n    (_c = this.get('viewController')) === null || _c === void 0 ? void 0 : _c.destroy();\n    (_d = this.get('stateController')) === null || _d === void 0 ? void 0 : _d.destroy();\n    (_e = this.get('canvas')) === null || _e === void 0 ? void 0 : _e.destroy();\n    this.cfg = null;\n    this.destroyed = true;\n    this.redoStack = null;\n    this.undoStack = null;\n  };\n  /**\n   * 创建凸包或凹包轮廓\n   * @param cfg HullCfg 轮廓配置项\n   */\n\n\n  AbstractGraph.prototype.createHull = function (cfg) {\n    if (!cfg.members || cfg.members.length < 1) {\n      console.warn('Create hull failed! The members is empty.');\n      return;\n    }\n\n    var parent = this.get('hullGroup');\n    var hullMap = this.get('hullMap');\n\n    if (!hullMap) {\n      hullMap = {};\n      this.set('hullMap', hullMap);\n    }\n\n    if (!parent || parent.get('destroyed')) {\n      parent = this.get('group').addGroup({\n        id: 'hullGroup'\n      });\n      parent.toBack();\n      this.set('hullGroup', parent);\n    }\n\n    if (hullMap[cfg.id]) {\n      console.warn('Existed hull id.');\n      return hullMap[cfg.id];\n    }\n\n    var group = parent.addGroup({\n      id: \"\".concat(cfg.id, \"-container\")\n    });\n    var hull = new Hull(this, __assign(__assign({}, cfg), {\n      group: group\n    }));\n    var hullId = hull.id;\n    hullMap[hullId] = hull;\n    return hull;\n  };\n  /**\n   * 获取当前 graph 中存在的包裹轮廓\n   * @return {[key: string]: Hull} Hull 的 map，hullId 对应的 hull 实例\n   */\n\n\n  AbstractGraph.prototype.getHulls = function () {\n    return this.get('hullMap');\n  };\n  /**\n   * 根据 hullId 获取对应的 hull\n   * @return Hull\n   */\n\n\n  AbstractGraph.prototype.getHullById = function (hullId) {\n    return this.get('hullMap')[hullId];\n  };\n\n  AbstractGraph.prototype.removeHull = function (hull) {\n    var _a;\n\n    var hullInstance;\n\n    if (isString(hull)) {\n      hullInstance = this.getHullById(hull);\n    } else {\n      hullInstance = hull;\n    }\n\n    (_a = this.get('hullMap')) === null || _a === void 0 ? true : delete _a[hullInstance.id];\n    hullInstance.destroy();\n  };\n\n  AbstractGraph.prototype.removeHulls = function () {\n    var hulls = this.getHulls();\n    if (!hulls || !Object.keys(hulls).length) return;\n    Object.keys(hulls).forEach(function (key) {\n      var hull = hulls[key];\n      hull.destroy();\n    });\n    this.set('hullMap', {});\n  };\n\n  return AbstractGraph;\n}(EventEmitter);\n\nexport default AbstractGraph;"],"mappings":"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"},"metadata":{},"sourceType":"module"}