{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _unionFind = _interopRequireDefault(require(\"./structs/union-find\"));\n\nvar _binaryHeap = _interopRequireDefault(require(\"./structs/binary-heap\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\n\n\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new _binaryHeap.default(compareWeight);\n  (0, _util.getEdgesByNodeId)(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      (0, _util.getEdgesByNodeId)(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      (0, _util.getEdgesByNodeId)(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n\n  var disjointSet = new _unionFind.default(nodes.map(function (n) {\n    return n.id;\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\n\nvar _default = minimumSpanningTree;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_unionFind","_interopRequireDefault","require","_binaryHeap","_util","obj","__esModule","primMST","graphData","weight","selectedEdges","_a","nodes","_b","edges","length","currNode","visited","Set","add","compareWeight","a","b","edgeQueue","getEdgesByNodeId","id","forEach","edge","insert","isEmpty","currEdge","delMin","source","target","has","push","kruskalMST","weightEdges","map","sort","disjointSet","n","curEdge","shift","connected","union","minimumSpanningTree","algo","algos","prim","kruskal","_default"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/lib/mts.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _unionFind = _interopRequireDefault(require(\"./structs/union-find\"));\n\nvar _binaryHeap = _interopRequireDefault(require(\"./structs/binary-heap\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new _binaryHeap.default(compareWeight);\n  (0, _util.getEdgesByNodeId)(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      (0, _util.getEdgesByNodeId)(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      (0, _util.getEdgesByNodeId)(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n\n  var disjointSet = new _unionFind.default(nodes.map(function (n) {\n    return n.id;\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\n\nvar _default = minimumSpanningTree;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}