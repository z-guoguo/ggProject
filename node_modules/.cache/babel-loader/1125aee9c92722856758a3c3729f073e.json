{"ast":null,"code":"import getAdjMatrix from './adjacent-matrix';\nimport { uniqueId } from './util';\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\n\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = getAdjMatrix(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      }); // find the cluster with max weight\n\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true; // remove from origin cluster\n\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster\n\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n\n    if (state_1 === \"break\") break;\n  } // delete the empty clusters\n\n\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default labelPropagation;","map":{"version":3,"names":["getAdjMatrix","uniqueId","labelPropagation","graphData","directed","weightPropertyName","maxIteration","_a","nodes","_b","edges","clusters","nodeMap","forEach","node","i","cid","clusterId","id","idx","adjMatrix","ks","neighbors","row","k","iid","entry","j","jid","push","iter","_loop_1","changed","neighborClusters","Object","keys","neighborId","neighborWeight","neighborNode","neighborClusterId","maxWeight","Infinity","bestClusterIds","length","selfClusterIdx","indexOf","splice","selfCluster","nodeInSelfClusterIdx","randomIdx","Math","floor","random","bestCluster","state_1","cluster","clusterEdges","clusterEdgeMap","edge","source","target","weight","sourceClusterId","targetClusterId","newEdgeId","concat","count","newEdge","clustersArray"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/es/label-propagation.js"],"sourcesContent":["import getAdjMatrix from './adjacent-matrix';\nimport { uniqueId } from './util';\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\n\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (maxIteration === void 0) {\n    maxIteration = 1000;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = getAdjMatrix(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {};\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n  var iter = 0;\n\n  var _loop_1 = function _loop_1() {\n    var changed = false;\n    nodes.forEach(function (node) {\n      var neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\n        var neighborWeight = neighbors[node.id][neighborId];\n        var neighborNode = nodeMap[neighborId].node;\n        var neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      }); // find the cluster with max weight\n\n      var maxWeight = -Infinity;\n      var bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(function (clusterId) {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true; // remove from origin cluster\n\n        var selfCluster = clusters[node.clusterId];\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster\n\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) return \"break\";\n    iter++;\n  };\n\n  while (iter < maxIteration) {\n    var state_1 = _loop_1();\n\n    if (state_1 === \"break\") break;\n  } // delete the empty clusters\n\n\n  Object.keys(clusters).forEach(function (clusterId) {\n    var cluster = clusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(clusters).forEach(function (clusterId) {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default labelPropagation;"],"mappings":"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"},"metadata":{},"sourceType":"module"}