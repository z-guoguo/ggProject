{"ast":null,"code":"import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { getEdgesByNodeId } from './util';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\n\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n\n  var disjointSet = new UnionFind(nodes.map(function (n) {\n    return n.id;\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\n\nexport default minimumSpanningTree;","map":{"version":3,"names":["UnionFind","MinBinaryHeap","getEdgesByNodeId","primMST","graphData","weight","selectedEdges","_a","nodes","_b","edges","length","currNode","visited","Set","add","compareWeight","a","b","edgeQueue","id","forEach","edge","insert","isEmpty","currEdge","delMin","source","target","has","push","kruskalMST","weightEdges","map","sort","disjointSet","n","curEdge","shift","connected","union","minimumSpanningTree","algo","algos","prim","kruskal"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/es/mts.js"],"sourcesContent":["import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { getEdgesByNodeId } from './util';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\n\nvar primMST = function primMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.source;\n    var target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graphData, weight) {\n  var selectedEdges = [];\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var weightEdges = edges.map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    weightEdges.sort(function (a, b) {\n      return a.weight - b.weight;\n    });\n  }\n\n  var disjointSet = new UnionFind(nodes.map(function (n) {\n    return n.id;\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (weightEdges.length > 0) {\n    var curEdge = weightEdges.shift();\n    var source = curEdge.source;\n    var target = curEdge.target;\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\n\n\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n  return algos[algo](graphData, weight);\n};\n\nexport default minimumSpanningTree;"],"mappings":"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"},"metadata":{},"sourceType":"module"}