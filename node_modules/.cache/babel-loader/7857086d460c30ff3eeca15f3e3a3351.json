{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt } from '../../util';\nimport { Marker } from '../marker';\n\nfunction qualify(value) {\n  return typeof value === 'string' || ObjectExt.isPlainObject(value);\n}\n\nexport const sourceMarker = {\n  qualify,\n\n  set(marker, {\n    view,\n    attrs\n  }) {\n    return createMarker('marker-start', marker, view, attrs);\n  }\n\n};\nexport const targetMarker = {\n  qualify,\n\n  set(marker, {\n    view,\n    attrs\n  }) {\n    return createMarker('marker-end', marker, view, attrs, {\n      transform: 'rotate(180)'\n    });\n  }\n\n};\nexport const vertexMarker = {\n  qualify,\n\n  set(marker, {\n    view,\n    attrs\n  }) {\n    return createMarker('marker-mid', marker, view, attrs);\n  }\n\n};\n\nfunction createMarker(type, marker, view, attrs, manual = {}) {\n  const def = typeof marker === 'string' ? {\n    name: marker\n  } : marker;\n\n  const {\n    name,\n    args\n  } = def,\n        others = __rest(def, [\"name\", \"args\"]);\n\n  let preset = others;\n\n  if (name && typeof name === 'string') {\n    const fn = Marker.registry.get(name);\n\n    if (fn) {\n      preset = fn(Object.assign(Object.assign({}, others), args));\n    } else {\n      return Marker.registry.onNotFound(name);\n    }\n  }\n\n  const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);\n  return {\n    [type]: `url(#${view.graph.defineMarker(options)})`\n  };\n}\n\nfunction normalizeAttr(attr, type) {\n  const result = {}; // The context 'fill' is disregared here. The usual case is to use the\n  // marker with a connection(for which 'fill' attribute is set to 'none').\n\n  const stroke = attr.stroke;\n\n  if (typeof stroke === 'string') {\n    result.stroke = stroke;\n    result.fill = stroke;\n  } // Again the context 'fill-opacity' is ignored.\n\n\n  let strokeOpacity = attr.strokeOpacity;\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr['stroke-opacity'];\n  }\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr.opacity;\n  }\n\n  if (strokeOpacity != null) {\n    result['stroke-opacity'] = strokeOpacity;\n    result['fill-opacity'] = strokeOpacity;\n  }\n\n  if (type !== 'marker-mid') {\n    const strokeWidth = parseFloat(attr.strokeWidth || attr['stroke-width']);\n\n    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {\n      const offset = Math.ceil(strokeWidth / 2);\n      result.refX = type === 'marker-start' ? offset : -offset;\n    }\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["ObjectExt","Marker","qualify","value","isPlainObject","sourceMarker","set","marker","view","attrs","createMarker","targetMarker","transform","vertexMarker","type","manual","def","name","args","others","preset","fn","registry","get","onNotFound","options","normalizeAttr","graph","defineMarker","attr","result","stroke","fill","strokeOpacity","opacity","strokeWidth","parseFloat","Number","isFinite","offset","Math","ceil","refX"],"sourceRoot":"","sources":["../../../src/registry/attr/marker.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}