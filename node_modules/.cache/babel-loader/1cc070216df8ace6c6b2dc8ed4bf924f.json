{"ast":null,"code":"import { clone } from '@antv/util';\nimport getAdjMatrix from './adjacent-matrix';\nimport Vector from './utils/vector';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot } from './utils/data-preprocessing';\n\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n\n  modularity *= 1 / param;\n  return modularity;\n}; // 模块惯性度，衡量属性相似度\n\n\nvar getInertialModularity = function getInertialModularity(nodes, allPropertiesWeight) {\n  if (nodes === void 0) {\n    nodes = [];\n  }\n\n  var length = nodes.length;\n  var totalProperties = new Vector([]);\n\n  for (var i = 0; i < length; i++) {\n    totalProperties = totalProperties.add(new Vector(allPropertiesWeight[i]));\n  } // 均值向量\n\n\n  var avgProperties = totalProperties.avg(length);\n  avgProperties.normalize(); // 节点集合的方差: 节点v与均值向量的平方欧式距离之和\n\n  var variance = 0;\n\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new Vector(allPropertiesWeight[i]);\n    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);\n    variance += squareEuclideanDistance;\n  } // 任意两点间的欧式平方距离\n\n\n  var squareEuclideanDistanceInfo = [];\n  nodes.forEach(function () {\n    squareEuclideanDistanceInfo.push([]);\n  });\n\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new Vector(allPropertiesWeight[i]);\n    nodes[i]['clusterInertial'] = 0;\n\n    for (var j = 0; j < length; j++) {\n      if (i === j) {\n        squareEuclideanDistanceInfo[i][j] = 0;\n        continue;\n      }\n\n      var propertiesj = new Vector(allPropertiesWeight[j]);\n      squareEuclideanDistanceInfo[i][j] = propertiesi.squareEuclideanDistance(propertiesj);\n      nodes[i]['clusterInertial'] += squareEuclideanDistanceInfo[i][j];\n    }\n  } // 计算模块惯性度\n\n\n  var inertialModularity = 0;\n  var param = 2 * length * variance;\n\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (i === j || clusteri !== clusterj) continue;\n      var inertial = nodes[i].clusterInertial * nodes[j].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i][j] / param;\n      inertialModularity += inertial;\n    }\n  }\n\n  return Number(inertialModularity.toFixed(4));\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold 差值阈值\n * @param inertialModularity 是否使用惯性模块度（即节点属性相似性）\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param inertialWeight 惯性模块度权重\n */\n\n\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  }\n\n  if (inertialModularity === void 0) {\n    inertialModularity = false;\n  }\n\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n\n  if (inertialWeight === void 0) {\n    inertialWeight = 1;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var allPropertiesWeight = [];\n\n  if (inertialModularity) {\n    nodes.forEach(function (node, index) {\n      node.properties = node.properties || {};\n      node.originIndex = index;\n    });\n    var nodeTypeInfo_1 = [];\n\n    if (nodes.every(function (node) {\n      return node.hasOwnProperty('nodeType');\n    })) {\n      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function (node) {\n        return node.nodeType;\n      })));\n      nodes.forEach(function (node) {\n        node.properties.nodeType = nodeTypeInfo_1.findIndex(function (nodeType) {\n          return nodeType === node.nodeType;\n        });\n      });\n    } // 所有节点属性集合\n\n\n    var properties = getAllProperties(nodes, propertyKey); // 所有节点属性one-hot特征向量集合\n\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  }\n\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = getAdjMatrix(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {}; // the sum of the weights of all edges in the graph\n\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n  var finalNodes = [];\n  var finalClusters = {};\n\n  while (true) {\n    if (inertialModularity && nodes.every(function (node) {\n      return node.hasOwnProperty('properties');\n    })) {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;\n    } else {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    } // 第一次迭代previousModularity直接赋值\n\n\n    if (iter === 0) {\n      previousModularity = totalModularity;\n      finalNodes = nodes;\n      finalClusters = clusters;\n    }\n\n    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold; // 总模块度增加才更新最优解\n\n    if (totalModularity > previousModularity) {\n      finalNodes = nodes.map(function (node) {\n        return {\n          node: node,\n          clusterId: node.clusterId\n        };\n      });\n      finalClusters = clone(clusters);\n      previousModularity = totalModularity;\n    } // whether to terminate the iterations\n\n\n    if (increaseWithinThreshold || iter > 100) {\n      break;\n    }\n\n    ;\n    iter++; // pre compute some values for current clusters\n\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n            target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    }); // move the nodes to increase the delta modularity\n\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m); // sum of weights of edges from node to nodes in cluster\n\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      }); // the modurarity for **removing** the node i from the origin cluster of node i\n\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam; // nodes for **removing** node i into this neighbor cluster\n\n      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function (scNode) {\n        return scNode.id !== node.id;\n      });\n      var propertiesWeightRemove = [];\n      selfClusterNodesAfterRemove.forEach(function (nodeRemove, index) {\n        propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];\n      }); // the inertialModularity for **removing** the node i from the origin cluster of node i\n\n      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight; // the neightbors of the node\n\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId; // if the node and the neighbor of node are in the same cluster, reutrn\n\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes; // if the cluster is empty, remove the cluster and return\n\n        if (!clusterNodes || !clusterNodes.length) return; // sum of weights of edges from node to nodes in cluster\n\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        }); // the modurarity for **adding** node i into this neighbor cluster\n\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam; // nodes for **adding** node i into this neighbor cluster\n\n        var clusterNodesAfterAdd = clusterNodes.concat([node]);\n        var propertiesWeightAdd = [];\n        clusterNodesAfterAdd.forEach(function (nodeAdd, index) {\n          propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];\n        }); // the inertialModularity for **adding** node i into this neighbor cluster\n\n        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight; // the increase modurarity is the difference between addModurarity and removeModurarity\n\n        var increase = addModurarity - removeModurarity;\n\n        if (inertialModularity) {\n          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);\n        } // find the best cluster to move node i into\n\n\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      }); // if found a best cluster to move into\n\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id; // move the node to the best cluster\n\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node); // remove from origin cluster\n\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n              target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        }); // the nodes of the clusters to move into and remove are changed, update their sumTot\n\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  } // delete the empty clusters, assign increasing clusterId\n\n\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    var cluster = finalClusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete finalClusters[clusterId];\n      return;\n    }\n\n    var newId = String(clusterIdx + 1);\n\n    if (newId === clusterId) {\n      return;\n    }\n\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    finalClusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete finalClusters[clusterId];\n    clusterIdx++;\n  }); // restore node clusterId\n\n  finalNodes.forEach(function (nodeInfo) {\n    var node = nodeInfo.node,\n        clusterId = nodeInfo.clusterId;\n    if (!node) return;\n    node.clusterId = clusterId;\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    if (!sourceClusterId || !targetClusterId) return;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    clustersArray.push(finalClusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default louvain;","map":{"version":3,"names":["clone","getAdjMatrix","Vector","getAllProperties","oneHot","getModularity","nodes","adjMatrix","ks","m","length","param","modularity","i","clusteri","clusterId","j","clusterj","entry","ki","kj","getInertialModularity","allPropertiesWeight","totalProperties","add","avgProperties","avg","normalize","variance","propertiesi","squareEuclideanDistance","squareEuclideanDistanceInfo","forEach","push","propertiesj","inertialModularity","inertial","clusterInertial","Math","pow","Number","toFixed","louvain","graphData","directed","weightPropertyName","threshold","propertyKey","involvedKeys","uninvolvedKeys","inertialWeight","undefined","_a","_b","edges","node","index","properties","originIndex","nodeTypeInfo_1","every","hasOwnProperty","Array","from","Set","map","nodeType","findIndex","uniqueId","clusters","nodeMap","cid","String","id","idx","neighbors","row","k","iid","jid","totalModularity","Infinity","previousModularity","iter","finalNodes","finalClusters","increaseWithinThreshold","Object","keys","sumTot","edge","source","target","sourceClusterId","targetClusterId","selfCluster","bestIncrease","bestCluster","commonParam","kiin","selfClusterNodes","scNode","scNodeIdx","removeModurarity","selfClusterNodesAfterRemove","filter","propertiesWeightRemove","nodeRemove","removeInertialModularity","nodeNeighborIds","neighborNodeId","neighborNode","neighborClusterId","neighborCluster","clusterNodes","neighborClusterKiin","cNode","cNodeIdx","addModurarity","clusterNodesAfterAdd","concat","propertiesWeightAdd","nodeAdd","addInertialModularity","increase","previousClusterId_1","nodeInSelfClusterIdx","indexOf","splice","neighborClusterSumTot_1","selfClusterSumTot_1","newClusterIdMap","clusterIdx","cluster","newId","item","nodeInfo","clusterEdges","clusterEdgeMap","weight","newEdgeId","count","newEdge","clustersArray"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/es/louvain.js"],"sourcesContent":["import { clone } from '@antv/util';\nimport getAdjMatrix from './adjacent-matrix';\nimport Vector from './utils/vector';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot } from './utils/data-preprocessing';\n\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\n  var length = adjMatrix.length;\n  var param = 2 * m;\n  var modularity = 0;\n\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      var entry = adjMatrix[i][j] || 0;\n      var ki = ks[i] || 0;\n      var kj = ks[j] || 0;\n      modularity += entry - ki * kj / param;\n    }\n  }\n\n  modularity *= 1 / param;\n  return modularity;\n}; // 模块惯性度，衡量属性相似度\n\n\nvar getInertialModularity = function getInertialModularity(nodes, allPropertiesWeight) {\n  if (nodes === void 0) {\n    nodes = [];\n  }\n\n  var length = nodes.length;\n  var totalProperties = new Vector([]);\n\n  for (var i = 0; i < length; i++) {\n    totalProperties = totalProperties.add(new Vector(allPropertiesWeight[i]));\n  } // 均值向量\n\n\n  var avgProperties = totalProperties.avg(length);\n  avgProperties.normalize(); // 节点集合的方差: 节点v与均值向量的平方欧式距离之和\n\n  var variance = 0;\n\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new Vector(allPropertiesWeight[i]);\n    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);\n    variance += squareEuclideanDistance;\n  } // 任意两点间的欧式平方距离\n\n\n  var squareEuclideanDistanceInfo = [];\n  nodes.forEach(function () {\n    squareEuclideanDistanceInfo.push([]);\n  });\n\n  for (var i = 0; i < length; i++) {\n    var propertiesi = new Vector(allPropertiesWeight[i]);\n    nodes[i]['clusterInertial'] = 0;\n\n    for (var j = 0; j < length; j++) {\n      if (i === j) {\n        squareEuclideanDistanceInfo[i][j] = 0;\n        continue;\n      }\n\n      var propertiesj = new Vector(allPropertiesWeight[j]);\n      squareEuclideanDistanceInfo[i][j] = propertiesi.squareEuclideanDistance(propertiesj);\n      nodes[i]['clusterInertial'] += squareEuclideanDistanceInfo[i][j];\n    }\n  } // 计算模块惯性度\n\n\n  var inertialModularity = 0;\n  var param = 2 * length * variance;\n\n  for (var i = 0; i < length; i++) {\n    var clusteri = nodes[i].clusterId;\n\n    for (var j = 0; j < length; j++) {\n      var clusterj = nodes[j].clusterId;\n      if (i === j || clusteri !== clusterj) continue;\n      var inertial = nodes[i].clusterInertial * nodes[j].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i][j] / param;\n      inertialModularity += inertial;\n    }\n  }\n\n  return Number(inertialModularity.toFixed(4));\n};\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold 差值阈值\n * @param inertialModularity 是否使用惯性模块度（即节点属性相似性）\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param inertialWeight 惯性模块度权重\n */\n\n\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (weightPropertyName === void 0) {\n    weightPropertyName = 'weight';\n  }\n\n  if (threshold === void 0) {\n    threshold = 0.0001;\n  }\n\n  if (inertialModularity === void 0) {\n    inertialModularity = false;\n  }\n\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n\n  if (inertialWeight === void 0) {\n    inertialWeight = 1;\n  } // the origin data\n\n\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var allPropertiesWeight = [];\n\n  if (inertialModularity) {\n    nodes.forEach(function (node, index) {\n      node.properties = node.properties || {};\n      node.originIndex = index;\n    });\n    var nodeTypeInfo_1 = [];\n\n    if (nodes.every(function (node) {\n      return node.hasOwnProperty('nodeType');\n    })) {\n      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function (node) {\n        return node.nodeType;\n      })));\n      nodes.forEach(function (node) {\n        node.properties.nodeType = nodeTypeInfo_1.findIndex(function (nodeType) {\n          return nodeType === node.nodeType;\n        });\n      });\n    } // 所有节点属性集合\n\n\n    var properties = getAllProperties(nodes, propertyKey); // 所有节点属性one-hot特征向量集合\n\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  }\n\n  var uniqueId = 1;\n  var clusters = {};\n  var nodeMap = {}; // init the clusters and nodeMap\n\n  nodes.forEach(function (node, i) {\n    var cid = String(uniqueId++);\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node: node,\n      idx: i\n    };\n  }); // the adjacent matrix of calNodes inside clusters\n\n  var adjMatrix = getAdjMatrix(graphData, directed); // the sum of each row in adjacent matrix\n\n  var ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n\n  var neighbors = {}; // the sum of the weights of all edges in the graph\n\n  var m = 0;\n  adjMatrix.forEach(function (row, i) {\n    var k = 0;\n    var iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach(function (entry, j) {\n      if (!entry) return;\n      k += entry;\n      var jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n  m /= 2;\n  var totalModularity = Infinity;\n  var previousModularity = Infinity;\n  var iter = 0;\n  var finalNodes = [];\n  var finalClusters = {};\n\n  while (true) {\n    if (inertialModularity && nodes.every(function (node) {\n      return node.hasOwnProperty('properties');\n    })) {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;\n    } else {\n      totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    } // 第一次迭代previousModularity直接赋值\n\n\n    if (iter === 0) {\n      previousModularity = totalModularity;\n      finalNodes = nodes;\n      finalClusters = clusters;\n    }\n\n    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold; // 总模块度增加才更新最优解\n\n    if (totalModularity > previousModularity) {\n      finalNodes = nodes.map(function (node) {\n        return {\n          node: node,\n          clusterId: node.clusterId\n        };\n      });\n      finalClusters = clone(clusters);\n      previousModularity = totalModularity;\n    } // whether to terminate the iterations\n\n\n    if (increaseWithinThreshold || iter > 100) {\n      break;\n    }\n\n    ;\n    iter++; // pre compute some values for current clusters\n\n    Object.keys(clusters).forEach(function (clusterId) {\n      // sum of weights of edges to nodes in cluster\n      var sumTot = 0;\n      edges.forEach(function (edge) {\n        var source = edge.source,\n            target = edge.target;\n        var sourceClusterId = nodeMap[source].node.clusterId;\n        var targetClusterId = nodeMap[target].node.clusterId;\n\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    }); // move the nodes to increase the delta modularity\n\n    nodes.forEach(function (node, i) {\n      var selfCluster = clusters[node.clusterId];\n      var bestIncrease = 0;\n      var bestCluster;\n      var commonParam = ks[i] / (2 * m); // sum of weights of edges from node to nodes in cluster\n\n      var kiin = 0;\n      var selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(function (scNode) {\n        var scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      }); // the modurarity for **removing** the node i from the origin cluster of node i\n\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam; // nodes for **removing** node i into this neighbor cluster\n\n      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function (scNode) {\n        return scNode.id !== node.id;\n      });\n      var propertiesWeightRemove = [];\n      selfClusterNodesAfterRemove.forEach(function (nodeRemove, index) {\n        propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];\n      }); // the inertialModularity for **removing** the node i from the origin cluster of node i\n\n      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight; // the neightbors of the node\n\n      var nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\n        var neighborNode = nodeMap[neighborNodeId].node;\n        var neighborClusterId = neighborNode.clusterId; // if the node and the neighbor of node are in the same cluster, reutrn\n\n        if (neighborClusterId === node.clusterId) return;\n        var neighborCluster = clusters[neighborClusterId];\n        var clusterNodes = neighborCluster.nodes; // if the cluster is empty, remove the cluster and return\n\n        if (!clusterNodes || !clusterNodes.length) return; // sum of weights of edges from node to nodes in cluster\n\n        var neighborClusterKiin = 0;\n        clusterNodes.forEach(function (cNode) {\n          var cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        }); // the modurarity for **adding** node i into this neighbor cluster\n\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam; // nodes for **adding** node i into this neighbor cluster\n\n        var clusterNodesAfterAdd = clusterNodes.concat([node]);\n        var propertiesWeightAdd = [];\n        clusterNodesAfterAdd.forEach(function (nodeAdd, index) {\n          propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];\n        }); // the inertialModularity for **adding** node i into this neighbor cluster\n\n        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight; // the increase modurarity is the difference between addModurarity and removeModurarity\n\n        var increase = addModurarity - removeModurarity;\n\n        if (inertialModularity) {\n          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);\n        } // find the best cluster to move node i into\n\n\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      }); // if found a best cluster to move into\n\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        var previousClusterId_1 = node.clusterId;\n        node.clusterId = bestCluster.id; // move the node to the best cluster\n\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node); // remove from origin cluster\n\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n\n        var neighborClusterSumTot_1 = 0;\n        var selfClusterSumTot_1 = 0;\n        edges.forEach(function (edge) {\n          var source = edge.source,\n              target = edge.target;\n          var sourceClusterId = nodeMap[source].node.clusterId;\n          var targetClusterId = nodeMap[target].node.clusterId;\n\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\n          }\n        }); // the nodes of the clusters to move into and remove are changed, update their sumTot\n\n        bestCluster.sumTot = neighborClusterSumTot_1;\n        selfCluster.sumTot = selfClusterSumTot_1;\n      }\n    });\n  } // delete the empty clusters, assign increasing clusterId\n\n\n  var newClusterIdMap = {};\n  var clusterIdx = 0;\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    var cluster = finalClusters[clusterId];\n\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete finalClusters[clusterId];\n      return;\n    }\n\n    var newId = String(clusterIdx + 1);\n\n    if (newId === clusterId) {\n      return;\n    }\n\n    cluster.id = newId;\n    cluster.nodes = cluster.nodes.map(function (item) {\n      return {\n        id: item.id,\n        clusterId: newId\n      };\n    });\n    finalClusters[newId] = cluster;\n    newClusterIdMap[clusterId] = newId;\n    delete finalClusters[clusterId];\n    clusterIdx++;\n  }); // restore node clusterId\n\n  finalNodes.forEach(function (nodeInfo) {\n    var node = nodeInfo.node,\n        clusterId = nodeInfo.clusterId;\n    if (!node) return;\n    node.clusterId = clusterId;\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\n  }); // get the cluster edges\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var weight = edge[weightPropertyName] || 1;\n    var sourceClusterId = nodeMap[source].node.clusterId;\n    var targetClusterId = nodeMap[target].node.clusterId;\n    if (!sourceClusterId || !targetClusterId) return;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight: weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  var clustersArray = [];\n  Object.keys(finalClusters).forEach(function (clusterId) {\n    clustersArray.push(finalClusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default louvain;"],"mappings":"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"},"metadata":{},"sourceType":"module"}