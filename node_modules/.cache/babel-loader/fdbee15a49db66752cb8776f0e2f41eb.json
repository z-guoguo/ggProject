{"ast":null,"code":"\"use strict\";\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"../util\");\n\nvar twoLayerCrossCount = function (g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = (0, util_1.zipObject)(southLayer, southLayer.map(function (v, i) {\n    return i;\n  }));\n  var unflat = northLayer.map(function (v) {\n    var _a;\n\n    var unsort = (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      return {\n        pos: southPos[e.w] || 0,\n        weight: g.edge(e).weight\n      };\n    });\n    return unsort === null || unsort === void 0 ? void 0 : unsort.sort(function (a, b) {\n      return a.pos - b.pos;\n    });\n  });\n  var southEntries = unflat.flat().filter(function (entry) {\n    return entry !== undefined;\n  }); // Build the accumulator tree\n\n  var firstIndex = 1;\n\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = Array(treeSize).fill(0, 0, treeSize); // Calculate the weighted crossings\n\n  var cc = 0;\n  southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach(function (entry) {\n    if (entry) {\n      var index = entry.pos + firstIndex;\n      tree[index] += entry.weight;\n      var weightSum = 0;\n\n      while (index > 0) {\n        if (index % 2) {\n          weightSum += tree[index + 1];\n        }\n\n        index = index - 1 >> 1;\n        tree[index] += entry.weight;\n      }\n\n      cc += entry.weight * weightSum;\n    }\n  });\n  return cc;\n};\n\nvar crossCount = function (g, layering) {\n  var cc = 0;\n\n  for (var i = 1; i < (layering === null || layering === void 0 ? void 0 : layering.length); i += 1) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n\n  return cc;\n};\n\nexports.default = crossCount;","map":{"version":3,"mappings":"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","names":["twoLayerCrossCount","g","northLayer","southLayer","southPos","map","v","i","unflat","unsort","outEdges","_a","e","pos","w","weight","edge","sort","a","b","southEntries","flat","filter","entry","undefined","firstIndex","length","treeSize","tree","Array","fill","cc","forEach","index","weightSum","crossCount","layering","exports"],"sourceRoot":"","sources":["../../../../../src/layout/dagre/src/order/cross-count.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}