{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.feasibleTreeWithLayer = exports.feasibleTree = void 0;\n\nvar util_1 = require(\"./util\");\n\nvar util_2 = require(\"../util\");\n\nvar graph_1 = require(\"../../graph\");\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\n\n\nvar feasibleTree = function (g) {\n  var t = new graph_1.Graph({\n    directed: false\n  }); // Choose arbitrary node from which to start our tree\n\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n  var edge;\n  var delta;\n\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? (0, util_1.slack)(g, edge) : -(0, util_1.slack)(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n};\n\nexports.feasibleTree = feasibleTree;\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\n\nvar tightTree = function (t, g) {\n  var dfs = function (v) {\n    g.nodeEdges(v).forEach(function (e) {\n      var edgeV = e.v;\n      var w = v === edgeV ? e.w : edgeV;\n\n      if (!t.hasNode(w) && !(0, util_1.slack)(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\n\n\nvar feasibleTreeWithLayer = function (g) {\n  var t = new graph_1.Graph({\n    directed: false\n  }); // Choose arbitrary node from which to start our tree\n\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n  var edge;\n  var delta;\n\n  while (tightTreeWithLayer(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? (0, util_1.slack)(g, edge) : -(0, util_1.slack)(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n};\n\nexports.feasibleTreeWithLayer = feasibleTreeWithLayer;\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\n\nvar tightTreeWithLayer = function (t, g) {\n  var dfs = function (v) {\n    var _a;\n\n    (_a = g.nodeEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n      var edgeV = e.v;\n      var w = v === edgeV ? e.w : edgeV; // 对于指定layer的，直接加入tight-tree，不参与调整\n\n      if (!t.hasNode(w) && (g.node(w).layer !== undefined || !(0, util_1.slack)(g, e))) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\n\n\nvar findMinSlackEdge = function (t, g) {\n  return (0, util_2.minBy)(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return (0, util_1.slack)(g, e);\n    }\n\n    return Infinity;\n  });\n};\n\nvar shiftRanks = function (t, g, delta) {\n  t.nodes().forEach(function (v) {\n    if (!g.node(v).rank) g.node(v).rank = 0;\n    g.node(v).rank += delta;\n  });\n};\n\nexports.default = {\n  feasibleTree: feasibleTree,\n  feasibleTreeWithLayer: feasibleTreeWithLayer\n};","map":{"version":3,"mappings":"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","names":["feasibleTree","g","t","graph_1","directed","start","nodes","size","nodeCount","setNode","edge","delta","tightTree","findMinSlackEdge","hasNode","v","shiftRanks","exports","dfs","nodeEdges","forEach","e","edgeV","w","setEdge","feasibleTreeWithLayer","tightTreeWithLayer","_a","node","layer","undefined","edges","Infinity","rank"],"sourceRoot":"","sources":["../../../../../src/layout/dagre/src/rank/feasible-tree.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}