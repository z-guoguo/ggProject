{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { isArray } from '@antv/util';\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\n\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n};\n\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);else relatedEdges = getEdgesByNodeId(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\n\n  var paths = {};\n\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  } // 兼容之前单路径\n\n\n  var path = {};\n\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\n\nexport default dijkstra;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n\n  var paths = [];\n\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if (isArray(prePath)) paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));else paths.push([prePath, target]);\n    }\n  }\n\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}","map":{"version":3,"names":["__spreadArray","isArray","getOutEdgesNodeId","getEdgesByNodeId","minVertex","D","nodes","marks","minDis","Infinity","minNode","i","length","nodeId","id","dijkstra","graphData","source","directed","weightPropertyName","_a","_b","edges","nodeIds","prevs","forEach","node","push","nodeNum","_loop_1","minNodeId","relatedEdges","edge","edgeTarget","target","edgeSource","w","weight","paths","findAllPaths","path","allPath","foundPaths","_i","prev","prevPaths","prevPaths_1","prePath"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/es/dijkstra.js"],"sourcesContent":["import { __spreadArray } from \"tslib\";\nimport { isArray } from '@antv/util';\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\n\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n};\n\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);else relatedEdges = getEdgesByNodeId(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\n\n  var paths = {};\n\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  } // 兼容之前单路径\n\n\n  var path = {};\n\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\n\nexport default dijkstra;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n\n  var paths = [];\n\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if (isArray(prePath)) paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));else paths.push([prePath, target]);\n    }\n  }\n\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}