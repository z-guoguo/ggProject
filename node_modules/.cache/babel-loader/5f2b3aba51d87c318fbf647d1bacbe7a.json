{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { AST_TOKEN_TYPES, createEntity, isSafari, STORAGE_CLASS } from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { isNumber } from '../utils/is-number';\nimport WebGPUBuffer from './WebGPUBuffer';\n\nvar WebGPUComputeModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n  function WebGPUComputeModel(engine, context) {\n    _classCallCheck(this, WebGPUComputeModel);\n\n    this.engine = engine;\n    this.context = context;\n    this.entity = createEntity();\n    this.uniformGPUBufferLayout = [];\n    this.uniformBuffer = void 0;\n    this.vertexBuffers = {};\n    this.outputBuffer = void 0;\n    this.bindGroupEntries = void 0;\n    this.bindGroup = void 0;\n    this.computePipeline = void 0;\n  }\n\n  _createClass(WebGPUComputeModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var _yield$this$compileCo, computeStage, buffers, uniforms, bufferBindingIndex, offset, mergedUniformData;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.compileComputePipelineStageDescriptor(this.context.shader);\n\n              case 2:\n                _yield$this$compileCo = _context.sent;\n                computeStage = _yield$this$compileCo.computeStage;\n                buffers = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === STORAGE_CLASS.StorageBuffer;\n                });\n                uniforms = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === STORAGE_CLASS.Uniform;\n                });\n                bufferBindingIndex = uniforms.length ? 1 : 0;\n                this.bindGroupEntries = [];\n\n                if (bufferBindingIndex) {\n                  offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n                  // we use std140 layout @see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)\n\n                  mergedUniformData = [];\n                  uniforms.forEach(function (uniform) {\n                    if (isNumber(uniform.data)) {\n                      _this.uniformGPUBufferLayout.push({\n                        name: uniform.name,\n                        offset: offset\n                      });\n\n                      offset += 4; // @ts-ignore\n\n                      mergedUniformData.push(uniform.data);\n                    } else {\n                      var _uniform$data; // @ts-ignore\n\n\n                      var originDataLength = ((_uniform$data = uniform.data) === null || _uniform$data === void 0 ? void 0 : _uniform$data.length) || 1;\n\n                      if (originDataLength === 3) {\n                        // vec3 -> vec4\n                        // @see http://ptgmedia.pearsoncmg.com/images/9780321552624/downloads/0321552628_AppL.pdf\n                        originDataLength = 4; // @ts-ignore\n\n                        uniform.data.push(0);\n                      } // 4 elements per block/line\n\n\n                      var padding = offset / 4 % 4;\n\n                      if (padding > 0) {\n                        var space = 4 - padding;\n\n                        if (originDataLength > 1 && originDataLength <= space) {\n                          if (originDataLength === 2) {\n                            if (space === 3) {\n                              offset += 4;\n                              mergedUniformData.push(0);\n                            } // @ts-ignore\n\n\n                            mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));\n\n                            _this.uniformGPUBufferLayout.push({\n                              name: uniform.name,\n                              offset: offset\n                            });\n                          }\n                        } else {\n                          for (var i = 0; i < space; i++) {\n                            offset += 4;\n                            mergedUniformData.push(0);\n                          } // @ts-ignore\n\n\n                          mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));\n\n                          _this.uniformGPUBufferLayout.push({\n                            name: uniform.name,\n                            offset: offset\n                          });\n                        }\n                      }\n\n                      offset += 4 * originDataLength;\n                    }\n                  });\n                  this.uniformBuffer = new WebGPUBuffer(this.engine, {\n                    // TODO: 处理 Struct 和 boolean\n                    // @ts-ignore\n                    data: mergedUniformData instanceof Array ? // @ts-ignore\n                    new Float32Array(mergedUniformData) : mergedUniformData,\n                    usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n                  });\n                  this.bindGroupEntries.push({\n                    binding: 0,\n                    resource: {\n                      buffer: this.uniformBuffer.get()\n                    }\n                  });\n                } // create GPUBuffers for storeage buffers\n\n\n                buffers.forEach(function (buffer) {\n                  if (buffer.data !== null) {\n                    if (buffer.type === AST_TOKEN_TYPES.Vector4FloatArray || buffer.type === AST_TOKEN_TYPES.FloatArray) {\n                      var gpuBuffer;\n\n                      if (buffer.name === _this.context.output.name) {\n                        gpuBuffer = new WebGPUBuffer(_this.engine, {\n                          // @ts-ignore\n                          data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                          usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                        });\n                        _this.outputBuffer = gpuBuffer;\n                        _this.context.output = {\n                          name: buffer.name,\n                          // @ts-ignore\n                          length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n                          typedArrayConstructor: Float32Array,\n                          gpuBuffer: gpuBuffer.get()\n                        };\n                      } else {\n                        if (buffer.isReferer) {\n                          // @ts-ignore\n                          if (buffer.data.model && buffer.data.model.outputBuffer) {\n                            // @ts-ignore\n                            gpuBuffer = buffer.data.model.outputBuffer;\n                          } else {// referred kernel haven't been executed\n                          }\n                        } else {\n                          gpuBuffer = new WebGPUBuffer(_this.engine, {\n                            // @ts-ignore\n                            data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                            usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                          });\n                        }\n                      } // @ts-ignore\n\n\n                      _this.vertexBuffers[buffer.name] = gpuBuffer;\n\n                      _this.bindGroupEntries.push({\n                        binding: bufferBindingIndex,\n                        resource: {\n                          name: buffer.name,\n                          refer: gpuBuffer ? undefined : buffer.data,\n                          // @ts-ignore\n                          buffer: gpuBuffer ? gpuBuffer.get() : undefined\n                        }\n                      });\n\n                      bufferBindingIndex++;\n                    }\n                  }\n                }); // create compute pipeline layout\n\n                this.computePipeline = this.engine.device.createComputePipeline({\n                  computeStage: computeStage\n                });\n                console.log(this.bindGroupEntries);\n                this.bindGroup = this.engine.device.createBindGroup({\n                  layout: this.computePipeline.getBindGroupLayout(0),\n                  entries: this.bindGroupEntries\n                });\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      if (this.uniformBuffer) {\n        this.uniformBuffer.destroy();\n      }\n\n      Object.keys(this.vertexBuffers).forEach(function (bufferName) {\n        return _this2.vertexBuffers[bufferName].destroy();\n      });\n    }\n  }, {\n    key: \"readData\",\n    value: function () {\n      var _readData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var output, length, typedArrayConstructor, gpuBuffer, byteCount, gpuReadBuffer, encoder, queue, arraybuffer, typedArray;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                output = this.context.output;\n\n                if (!output) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                length = output.length, typedArrayConstructor = output.typedArrayConstructor, gpuBuffer = output.gpuBuffer;\n\n                if (!gpuBuffer) {\n                  _context2.next = 16;\n                  break;\n                } // await gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n                // const arraybuffer = gpuBuffer.getMappedRange();\n                // let arraybuffer;\n                // if (isSafari) {\n                //   arraybuffer = await gpuBuffer.mapReadAsync();\n                // } else {\n\n\n                byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT; // @see https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web\n\n                gpuReadBuffer = this.engine.device.createBuffer({\n                  size: byteCount,\n                  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n                });\n                encoder = this.engine.device.createCommandEncoder();\n                encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);\n                queue = isSafari ? // @ts-ignore\n                this.engine.device.getQueue() : this.engine.device.defaultQueue;\n                queue.submit([encoder.finish()]);\n                _context2.next = 12;\n                return gpuReadBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n\n              case 12:\n                arraybuffer = gpuReadBuffer.getMappedRange();\n                typedArray = new typedArrayConstructor(arraybuffer.slice(0));\n                gpuReadBuffer.unmap();\n                return _context2.abrupt(\"return\", typedArray);\n\n              case 16:\n                return _context2.abrupt(\"return\", new Float32Array());\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function readData() {\n        return _readData.apply(this, arguments);\n      }\n\n      return readData;\n    }()\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (this.engine.currentComputePass) {\n        var _this$engine$currentC;\n\n        this.engine.currentComputePass.setPipeline(this.computePipeline); // this.bindGroupEntries.forEach((entry) => {\n        //   if (!entry.resource.buffer) {\n        //     // get referred kernel's output\n        //     const gpuBuffer = (entry.resource.refer.model as WebGPUComputeModel)\n        //       .outputBuffer;\n        //     this.vertexBuffers[entry.resource.name] = gpuBuffer;\n        //     entry.resource.buffer = gpuBuffer.get();\n        //   }\n        // });\n        // const bindGroup = this.engine.device.createBindGroup({\n        //   layout: this.computePipeline.getBindGroupLayout(0),\n        //   entries: this.bindGroupEntries,\n        // });\n\n        this.engine.currentComputePass.setBindGroup(0, this.bindGroup);\n\n        (_this$engine$currentC = this.engine.currentComputePass).dispatch.apply(_this$engine$currentC, _toConsumableArray(this.context.dispatch));\n      }\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(bufferName, data) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var buffer = this.vertexBuffers[bufferName];\n\n      if (buffer) {\n        buffer.subData({\n          data: data,\n          offset: offset\n        });\n      }\n    }\n  }, {\n    key: \"updateUniform\",\n    value: function updateUniform(uniformName, data) {\n      var layout = this.uniformGPUBufferLayout.find(function (l) {\n        return l.name === uniformName;\n      });\n\n      if (layout) {\n        this.uniformBuffer.subData({\n          data: Number.isFinite(data) ? new Float32Array([data]) : new Float32Array(data),\n          offset: layout.offset\n        });\n      }\n    }\n  }, {\n    key: \"confirmInput\",\n    value: function confirmInput(model, inputName) {\n      // copy output GPUBuffer of kernel\n      var inputBuffer = this.vertexBuffers[inputName];\n      var outputBuffer = model.outputBuffer;\n\n      if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {\n        var encoder = this.engine.device.createCommandEncoder();\n        var _context$output = model.context.output,\n            length = _context$output.length,\n            typedArrayConstructor = _context$output.typedArrayConstructor;\n        var byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT;\n        encoder.copyBufferToBuffer(outputBuffer.get(), 0, inputBuffer.get(), 0, byteCount);\n        var queue = isSafari ? // @ts-ignore\n        this.engine.device.getQueue() : this.engine.device.defaultQueue;\n        queue.submit([encoder.finish()]);\n      }\n    }\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"compileComputePipelineStageDescriptor\",\n    value: function () {\n      var _compileComputePipelineStageDescriptor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(computeCode) {\n        var computeShader, shaderVersion;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                computeShader = computeCode;\n                shaderVersion = '#version 450\\n';\n\n                if (this.engine.options.useWGSL) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 5;\n                return this.compileShaderToSpirV(computeCode, 'compute', shaderVersion);\n\n              case 5:\n                computeShader = _context3.sent;\n\n              case 6:\n                return _context3.abrupt(\"return\", {\n                  computeStage: {\n                    module: this.engine.device.createShaderModule({\n                      code: computeShader,\n                      // @ts-ignore\n                      isWHLSL: isSafari\n                    }),\n                    entryPoint: 'main'\n                  }\n                });\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function compileComputePipelineStageDescriptor(_x) {\n        return _compileComputePipelineStageDescriptor.apply(this, arguments);\n      }\n\n      return compileComputePipelineStageDescriptor;\n    }()\n  }]);\n\n  return WebGPUComputeModel;\n}();\n\nexport { WebGPUComputeModel as default };","map":{"version":3,"mappings":"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","names":["AST_TOKEN_TYPES","createEntity","isSafari","STORAGE_CLASS","WebGPUConstants","isNumber","WebGPUBuffer","WebGPUComputeModel","engine","context","_classCallCheck","entity","uniformGPUBufferLayout","uniformBuffer","vertexBuffers","outputBuffer","bindGroupEntries","bindGroup","computePipeline","compileComputePipelineStageDescriptor","shader","computeStage","buffers","uniforms","filter","uniform","storageClass","StorageBuffer","Uniform","bufferBindingIndex","length","offset","mergedUniformData","forEach","data","_this","push","name","originDataLength","padding","space","_toConsumableArray","i","Array","Float32Array","usage","BufferUsage","CopyDst","binding","resource","buffer","get","type","Vector4FloatArray","FloatArray","gpuBuffer","output","isFinite","Number","Storage","CopySrc","typedArrayConstructor","isReferer","model","refer","undefined","device","createComputePipeline","console","log","createBindGroup","layout","getBindGroupLayout","entries","destroy","Object","keys","bufferName","_this2","byteCount","BYTES_PER_ELEMENT","gpuReadBuffer","createBuffer","size","GPUBufferUsage","COPY_DST","MAP_READ","encoder","createCommandEncoder","copyBufferToBuffer","queue","getQueue","defaultQueue","submit","finish","mapAsync","MapMode","Read","arraybuffer","getMappedRange","typedArray","slice","unmap","currentComputePass","setPipeline","setBindGroup","dispatch","subData","uniformName","find","l","inputName","inputBuffer","source","shaderVersion","compileRawShaderToSpirV","glslang","compileGLSL","computeCode","computeShader","options","useWGSL","compileShaderToSpirV","module","createShaderModule","code","isWHLSL","entryPoint"],"sources":["../../src/webgpu/WebGPUComputeModel.ts"],"sourcesContent":["import {\n  AST_TOKEN_TYPES,\n  createEntity,\n  GLSLContext,\n  IComputeModel,\n  isSafari,\n  STORAGE_CLASS,\n} from '@antv/g-webgpu-core';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { WebGPUEngine } from '.';\nimport { isNumber } from '../utils/is-number';\nimport WebGPUBuffer from './WebGPUBuffer';\n\nexport default class WebGPUComputeModel implements IComputeModel {\n  private entity = createEntity();\n  /**\n   * 用于后续渲染时动态更新\n   */\n  private uniformGPUBufferLayout: Array<{\n    name: string;\n    offset: number;\n  }> = [];\n\n  private uniformBuffer: WebGPUBuffer;\n  private vertexBuffers: Record<string, WebGPUBuffer> = {};\n  private outputBuffer: WebGPUBuffer;\n  private bindGroupEntries: GPUBindGroupEntry[];\n  private bindGroup: GPUBindGroup;\n\n  private computePipeline: GPUComputePipeline;\n\n  constructor(private engine: WebGPUEngine, private context: GLSLContext) {}\n\n  public async init() {\n    const { computeStage } = await this.compileComputePipelineStageDescriptor(\n      this.context.shader!,\n    );\n\n    const buffers = this.context.uniforms.filter(\n      (uniform) => uniform.storageClass === STORAGE_CLASS.StorageBuffer,\n    );\n    const uniforms = this.context.uniforms.filter(\n      (uniform) => uniform.storageClass === STORAGE_CLASS.Uniform,\n    );\n\n    let bufferBindingIndex = uniforms.length ? 1 : 0;\n    this.bindGroupEntries = [];\n    if (bufferBindingIndex) {\n      let offset = 0;\n      // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n      // we use std140 layout @see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)\n      const mergedUniformData: number[] = [];\n      uniforms.forEach((uniform) => {\n        if (isNumber(uniform.data)) {\n          this.uniformGPUBufferLayout.push({\n            name: uniform.name,\n            offset,\n          });\n          offset += 4;\n          // @ts-ignore\n          mergedUniformData.push(uniform.data);\n        } else {\n          // @ts-ignore\n          let originDataLength = uniform.data?.length || 1;\n          if (originDataLength === 3) {\n            // vec3 -> vec4\n            // @see http://ptgmedia.pearsoncmg.com/images/9780321552624/downloads/0321552628_AppL.pdf\n            originDataLength = 4;\n            // @ts-ignore\n            uniform.data.push(0);\n          }\n          // 4 elements per block/line\n          const padding = (offset / 4) % 4;\n          if (padding > 0) {\n            const space = 4 - padding;\n            if (originDataLength > 1 && originDataLength <= space) {\n              if (originDataLength === 2) {\n                if (space === 3) {\n                  offset += 4;\n                  mergedUniformData.push(0);\n                }\n                // @ts-ignore\n                mergedUniformData.push(...uniform.data);\n                this.uniformGPUBufferLayout.push({\n                  name: uniform.name,\n                  offset,\n                });\n              }\n            } else {\n              for (let i = 0; i < space; i++) {\n                offset += 4;\n                mergedUniformData.push(0);\n              }\n              // @ts-ignore\n              mergedUniformData.push(...uniform.data);\n              this.uniformGPUBufferLayout.push({\n                name: uniform.name,\n                offset,\n              });\n            }\n          }\n\n          offset += 4 * originDataLength;\n        }\n      });\n\n      this.uniformBuffer = new WebGPUBuffer(this.engine, {\n        // TODO: 处理 Struct 和 boolean\n        // @ts-ignore\n        data:\n          mergedUniformData instanceof Array\n            ? // @ts-ignore\n              new Float32Array(mergedUniformData)\n            : mergedUniformData,\n        usage:\n          WebGPUConstants.BufferUsage.Uniform |\n          WebGPUConstants.BufferUsage.CopyDst,\n      });\n\n      this.bindGroupEntries.push({\n        binding: 0,\n        resource: {\n          buffer: this.uniformBuffer.get(),\n        },\n      });\n    }\n\n    // create GPUBuffers for storeage buffers\n    buffers.forEach((buffer) => {\n      if (buffer.data !== null) {\n        if (\n          buffer.type === AST_TOKEN_TYPES.Vector4FloatArray ||\n          buffer.type === AST_TOKEN_TYPES.FloatArray\n        ) {\n          let gpuBuffer;\n          if (buffer.name === this.context.output.name) {\n            gpuBuffer = new WebGPUBuffer(this.engine, {\n              // @ts-ignore\n              data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n              usage:\n                WebGPUConstants.BufferUsage.Storage |\n                WebGPUConstants.BufferUsage.CopyDst |\n                WebGPUConstants.BufferUsage.CopySrc,\n            });\n            this.outputBuffer = gpuBuffer;\n            this.context.output = {\n              name: buffer.name,\n              // @ts-ignore\n              length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n              typedArrayConstructor: Float32Array,\n              gpuBuffer: gpuBuffer.get(),\n            };\n          } else {\n            if (buffer.isReferer) {\n              // @ts-ignore\n              if (buffer.data.model && buffer.data.model.outputBuffer) {\n                // @ts-ignore\n                gpuBuffer = (buffer.data.model as WebGPUComputeModel)\n                  .outputBuffer;\n              } else {\n                // referred kernel haven't been executed\n              }\n            } else {\n              gpuBuffer = new WebGPUBuffer(this.engine, {\n                // @ts-ignore\n                data: isFinite(Number(buffer.data))\n                  ? [buffer.data]\n                  : buffer.data,\n                usage:\n                  WebGPUConstants.BufferUsage.Storage |\n                  WebGPUConstants.BufferUsage.CopyDst |\n                  WebGPUConstants.BufferUsage.CopySrc,\n              });\n            }\n          }\n\n          // @ts-ignore\n          this.vertexBuffers[buffer.name] = gpuBuffer;\n          this.bindGroupEntries.push({\n            binding: bufferBindingIndex,\n            resource: {\n              name: buffer.name,\n              refer: gpuBuffer ? undefined : buffer.data,\n              // @ts-ignore\n              buffer: gpuBuffer ? gpuBuffer.get() : undefined,\n            },\n          });\n          bufferBindingIndex++;\n        }\n      }\n    });\n\n    // create compute pipeline layout\n    this.computePipeline = this.engine.device.createComputePipeline({\n      computeStage,\n    });\n\n    console.log(this.bindGroupEntries);\n\n    this.bindGroup = this.engine.device.createBindGroup({\n      layout: this.computePipeline.getBindGroupLayout(0),\n      entries: this.bindGroupEntries,\n    });\n  }\n\n  public destroy(): void {\n    if (this.uniformBuffer) {\n      this.uniformBuffer.destroy();\n    }\n\n    Object.keys(this.vertexBuffers).forEach((bufferName) =>\n      this.vertexBuffers[bufferName].destroy(),\n    );\n  }\n\n  public async readData() {\n    const { output } = this.context;\n    if (output) {\n      const { length, typedArrayConstructor, gpuBuffer } = output;\n      if (gpuBuffer) {\n        // await gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n        // const arraybuffer = gpuBuffer.getMappedRange();\n        // let arraybuffer;\n\n        // if (isSafari) {\n        //   arraybuffer = await gpuBuffer.mapReadAsync();\n        // } else {\n        const byteCount = length! * typedArrayConstructor!.BYTES_PER_ELEMENT;\n\n        // @see https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web\n        const gpuReadBuffer = this.engine.device.createBuffer({\n          size: byteCount,\n          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n        const encoder = this.engine.device.createCommandEncoder();\n        encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);\n        const queue: GPUQueue = isSafari\n          ? // @ts-ignore\n            this.engine.device.getQueue()\n          : this.engine.device.defaultQueue;\n        queue.submit([encoder.finish()]);\n\n        await gpuReadBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n        const arraybuffer = gpuReadBuffer.getMappedRange();\n        const typedArray = new typedArrayConstructor!(arraybuffer.slice(0));\n        gpuReadBuffer.unmap();\n\n        return typedArray;\n      }\n    }\n    return new Float32Array();\n  }\n\n  public run() {\n    if (this.engine.currentComputePass) {\n      this.engine.currentComputePass.setPipeline(this.computePipeline);\n\n      // this.bindGroupEntries.forEach((entry) => {\n      //   if (!entry.resource.buffer) {\n      //     // get referred kernel's output\n      //     const gpuBuffer = (entry.resource.refer.model as WebGPUComputeModel)\n      //       .outputBuffer;\n      //     this.vertexBuffers[entry.resource.name] = gpuBuffer;\n      //     entry.resource.buffer = gpuBuffer.get();\n      //   }\n      // });\n\n      // const bindGroup = this.engine.device.createBindGroup({\n      //   layout: this.computePipeline.getBindGroupLayout(0),\n      //   entries: this.bindGroupEntries,\n      // });\n      this.engine.currentComputePass.setBindGroup(0, this.bindGroup);\n      this.engine.currentComputePass.dispatch(...this.context.dispatch);\n    }\n  }\n\n  public updateBuffer(\n    bufferName: string,\n    data:\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n    offset: number = 0,\n  ) {\n    const buffer = this.vertexBuffers[bufferName];\n    if (buffer) {\n      buffer.subData({ data, offset });\n    }\n  }\n\n  public updateUniform(\n    uniformName: string,\n    data:\n      | number\n      | number[]\n      | Float32Array\n      | Uint8Array\n      | Uint16Array\n      | Uint32Array\n      | Int8Array\n      | Int16Array\n      | Int32Array,\n  ) {\n    const layout = this.uniformGPUBufferLayout.find(\n      (l) => l.name === uniformName,\n    );\n\n    if (layout) {\n      this.uniformBuffer.subData({\n        data: Number.isFinite(data)\n          ? new Float32Array([data as number])\n          : new Float32Array(\n              data as\n                | number[]\n                | Float32Array\n                | Uint8Array\n                | Uint16Array\n                | Uint32Array\n                | Int8Array\n                | Int16Array\n                | Int32Array,\n            ),\n        offset: layout.offset,\n      });\n    }\n  }\n\n  public confirmInput(model: IComputeModel, inputName: string): void {\n    // copy output GPUBuffer of kernel\n    const inputBuffer = this.vertexBuffers[inputName];\n    const outputBuffer = (model as WebGPUComputeModel).outputBuffer;\n\n    if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {\n      const encoder = this.engine.device.createCommandEncoder();\n      const {\n        length,\n        typedArrayConstructor,\n      } = (model as WebGPUComputeModel).context.output;\n      const byteCount = length! * typedArrayConstructor!.BYTES_PER_ELEMENT;\n      encoder.copyBufferToBuffer(\n        outputBuffer.get(),\n        0,\n        inputBuffer.get(),\n        0,\n        byteCount,\n      );\n      const queue: GPUQueue = isSafari\n        ? // @ts-ignore\n          this.engine.device.getQueue()\n        : this.engine.device.defaultQueue;\n      queue.submit([encoder.finish()]);\n    }\n  }\n\n  private compileShaderToSpirV(\n    source: string,\n    type: string,\n    shaderVersion: string,\n  ): Promise<Uint32Array> {\n    return this.compileRawShaderToSpirV(shaderVersion + source, type);\n  }\n\n  private compileRawShaderToSpirV(\n    source: string,\n    type: string,\n  ): Promise<Uint32Array> {\n    return this.engine.glslang.compileGLSL(source, type);\n  }\n\n  private async compileComputePipelineStageDescriptor(\n    computeCode: string,\n  ): Promise<Pick<GPUComputePipelineDescriptor, 'computeStage'>> {\n    let computeShader: Uint32Array | string = computeCode;\n    const shaderVersion = '#version 450\\n';\n    if (!this.engine.options.useWGSL) {\n      computeShader = await this.compileShaderToSpirV(\n        computeCode,\n        'compute',\n        shaderVersion,\n      );\n    }\n\n    return {\n      computeStage: {\n        module: this.engine.device.createShaderModule({\n          code: computeShader,\n          // @ts-ignore\n          isWHLSL: isSafari,\n        }),\n        entryPoint: 'main',\n      },\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}