{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nvar _dec, _class, _temp;\n/**\n * implements renderService with WebGPU API\n * @see https://webgpu.io/\n * @see https://github.com/BabylonJS/Babylon.js/blob/WebGPU/src/Engines/webgpuEngine.ts\n */\n\n\nimport { isSafari } from '@antv/g-webgpu-core'; // import { Glslang } from '@webgpu/glslang/dist/web-devel/glslang.onefile';\n\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { injectable } from 'inversify';\nimport glslang from './glslang';\nimport WebGPUAttribute from './WebGPUAttribute';\nimport WebGPUBuffer from './WebGPUBuffer';\nimport WebGPUComputeModel from './WebGPUComputeModel';\nimport WebGPUElements from './WebGPUElements';\nimport WebGPUFramebuffer from './WebGPUFramebuffer';\nimport WebGPUModel from './WebGPUModel';\nimport WebGPUTexture2D from './WebGPUTexture2D';\nexport\n/**\n * regl renderer\n */\nvar WebGPUEngine = (_dec = injectable(), _dec(_class = (_temp = /*#__PURE__*/function () {\n  function WebGPUEngine() {\n    var _this = this;\n\n    _classCallCheck(this, WebGPUEngine);\n\n    this.supportWebGPU = true;\n    this.useWGSL = false;\n    this.options = void 0;\n    this.canvas = void 0;\n    this.context = void 0;\n    this.glslang = void 0;\n    this.adapter = void 0;\n    this.device = void 0;\n    this.swapChain = void 0;\n    this.mainPassSampleCount = void 0;\n    this.mainTexture = void 0;\n    this.depthTexture = void 0;\n    this.mainColorAttachments = void 0;\n    this.mainTextureExtends = void 0;\n    this.mainDepthAttachment = void 0;\n    this.uploadEncoder = void 0;\n    this.renderEncoder = void 0;\n    this.computeEncoder = void 0;\n    this.renderTargetEncoder = void 0;\n    this.commandBuffers = new Array(4).fill(undefined);\n    this.currentRenderPass = null;\n    this.mainRenderPass = null;\n    this.currentRenderTargetViewDescriptor = void 0;\n    this.currentComputePass = null;\n    this.bundleEncoder = void 0;\n    this.tempBuffers = [];\n    this.currentRenderTarget = null;\n    this.uploadEncoderDescriptor = {\n      label: 'upload'\n    };\n    this.renderEncoderDescriptor = {\n      label: 'render'\n    };\n    this.renderTargetEncoderDescriptor = {\n      label: 'renderTarget'\n    };\n    this.computeEncoderDescriptor = {\n      label: 'compute'\n    };\n    this.pipelines = {};\n    this.computePipelines = {};\n    this.defaultSampleCount = 4;\n    this.clearDepthValue = 1;\n    this.clearStencilValue = 0;\n    this.transientViewport = {\n      x: Infinity,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    this.cachedViewport = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n\n    this.clear = function (options) {\n      var framebuffer = options.framebuffer,\n          color = options.color,\n          depth = options.depth,\n          stencil = options.stencil;\n\n      if (_this.options.supportCompute) {\n        _this.startComputePass();\n      } // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n\n\n      if (_this.currentRenderTarget) {\n        if (_this.currentRenderPass) {\n          _this.endRenderTargetRenderPass();\n        }\n\n        _this.startRenderTargetRenderPass(_this.currentRenderTarget, color ? color : null, !!depth, !!stencil);\n      } else {\n        // if (this.useReverseDepthBuffer) {\n        //     this._depthCullingState.depthFunc = Constants.GREATER;\n        // }\n        _this.mainColorAttachments[0].loadValue = color ? color : WebGPUConstants.LoadOp.Load;\n        _this.mainDepthAttachment.depthLoadValue = depth ? depth : WebGPUConstants.LoadOp.Load;\n        _this.mainDepthAttachment.stencilLoadValue = stencil ? _this.clearStencilValue : WebGPUConstants.LoadOp.Load;\n\n        if (_this.mainRenderPass) {\n          _this.endMainRenderPass();\n        }\n\n        _this.startMainRenderPass();\n      }\n    };\n\n    this.createModel = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n        var model;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                model = new WebGPUModel(_this, options);\n                _context.next = 3;\n                return model.init();\n\n              case 3:\n                return _context.abrupt(\"return\", model);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.createAttribute = function (options) {\n      return new WebGPUAttribute(_this, options);\n    };\n\n    this.createBuffer = function (options) {\n      return new WebGPUBuffer(_this, options);\n    };\n\n    this.createElements = function (options) {\n      return new WebGPUElements(_this, options);\n    };\n\n    this.createTexture2D = function (options) {\n      return new WebGPUTexture2D(_this, options);\n    };\n\n    this.createFramebuffer = function (options) {\n      return new WebGPUFramebuffer(_this, options);\n    };\n\n    this.useFramebuffer = function (framebuffer, drawCommands) {\n      // bind\n      if (_this.currentRenderTarget) {\n        _this.unbindFramebuffer(_this.currentRenderTarget);\n      }\n\n      _this.currentRenderTarget = framebuffer; // TODO: use mipmap options in framebuffer\n\n      _this.currentRenderTargetViewDescriptor = {\n        dimension: WebGPUConstants.TextureViewDimension.E2d,\n        // mipLevelCount: bindWithMipMaps ? WebGPUTextureHelper.computeNumMipmapLevels(texture.width, texture.height) - lodLevel : 1,\n        // baseArrayLayer: faceIndex,\n        // baseMipLevel: lodLevel,\n        arrayLayerCount: 1,\n        aspect: WebGPUConstants.TextureAspect.All\n      };\n      _this.currentRenderPass = null;\n      drawCommands();\n    };\n\n    this.createComputeModel = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context) {\n        var model;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                model = new WebGPUComputeModel(_this, context);\n                _context2.next = 3;\n                return model.init();\n\n              case 3:\n                return _context2.abrupt(\"return\", model);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this.getCanvas = function () {\n      return _this.canvas;\n    };\n\n    this.getGLContext = function () {\n      throw new Error('Method not implemented.');\n    };\n\n    this.viewport = function (_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          width = _ref3.width,\n          height = _ref3.height;\n\n      if (!_this.currentRenderPass) {\n        // call viewport() before current render pass created\n        _this.transientViewport = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n      } else if (_this.transientViewport.x !== Infinity) {\n        var renderPass = _this.getCurrentRenderPass(); // @see https://gpuweb.github.io/gpuweb/#dom-gpurenderpassencoder-setviewport\n\n\n        renderPass.setViewport(_this.transientViewport.x, _this.transientViewport.y, _this.transientViewport.width, _this.transientViewport.height, 0, 1);\n      } else if (x !== _this.cachedViewport.x || y !== _this.cachedViewport.y || width !== _this.cachedViewport.width || height !== _this.cachedViewport.height) {\n        _this.cachedViewport = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n\n        var _renderPass = _this.getCurrentRenderPass();\n\n        _renderPass.setViewport(x, y, width, height, 0, 1);\n      }\n    };\n\n    this.readPixels = function (options) {\n      throw new Error('Method not implemented.');\n    };\n  }\n\n  _createClass(WebGPUEngine, [{\n    key: \"isFloatSupported\",\n    value: function isFloatSupported() {\n      return true;\n    }\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(config) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.canvas = config.canvas;\n                this.options = config;\n                this.useWGSL = !!config.useWGSL;\n                this.mainPassSampleCount = config.antialiasing ? this.defaultSampleCount : 1;\n                _context3.next = 6;\n                return this.initGlslang();\n\n              case 6:\n                this.initContextAndSwapChain();\n                this.initMainAttachments();\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function init(_x3) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"setScissor\",\n    value: function setScissor(scissor) {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.mainTexture) {\n        this.mainTexture.destroy();\n      }\n\n      if (this.depthTexture) {\n        this.depthTexture.destroy();\n      }\n\n      this.tempBuffers.forEach(function (buffer) {\n        return buffer.destroy();\n      });\n      this.tempBuffers = [];\n    }\n  }, {\n    key: \"beginFrame\",\n    value: function beginFrame() {\n      this.uploadEncoder = this.device.createCommandEncoder(this.uploadEncoderDescriptor);\n      this.renderEncoder = this.device.createCommandEncoder(this.renderEncoderDescriptor);\n      this.renderTargetEncoder = this.device.createCommandEncoder(this.renderTargetEncoderDescriptor);\n\n      if (this.options.supportCompute) {\n        this.computeEncoder = this.device.createCommandEncoder(this.computeEncoderDescriptor);\n      }\n    }\n  }, {\n    key: \"endFrame\",\n    value: function endFrame() {\n      if (this.options.supportCompute) {\n        this.endComputePass();\n      }\n\n      this.endMainRenderPass();\n      this.commandBuffers[0] = this.uploadEncoder.finish();\n      this.commandBuffers[1] = this.renderEncoder.finish();\n\n      if (this.options.supportCompute) {\n        this.commandBuffers[2] = this.computeEncoder.finish();\n      }\n\n      this.commandBuffers[3] = this.renderTargetEncoder.finish();\n\n      if (isSafari) {\n        this.device // @ts-ignore\n        .getQueue().submit(this.commandBuffers.filter(function (buffer) {\n          return buffer;\n        }));\n      } else {\n        this.device.defaultQueue.submit(this.commandBuffers.filter(function (buffer) {\n          return buffer;\n        }));\n      }\n    }\n  }, {\n    key: \"getCurrentRenderPass\",\n    value: function getCurrentRenderPass() {\n      if (this.currentRenderTarget && !this.currentRenderPass) {\n        this.startRenderTargetRenderPass(this.currentRenderTarget, null, false, false);\n      } else if (!this.currentRenderPass) {\n        this.startMainRenderPass();\n      }\n\n      return this.currentRenderPass;\n    }\n  }, {\n    key: \"initGlslang\",\n    value: function () {\n      var _initGlslang = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _navigator, _navigator$gpu;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return glslang();\n\n              case 2:\n                this.glslang = _context4.sent;\n                _context4.next = 5;\n                return (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$gpu = _navigator.gpu) === null || _navigator$gpu === void 0 ? void 0 : _navigator$gpu.requestAdapter();\n\n              case 5:\n                this.adapter = _context4.sent;\n                _context4.next = 8;\n                return this.adapter.requestDevice();\n\n              case 8:\n                this.device = _context4.sent;\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function initGlslang() {\n        return _initGlslang.apply(this, arguments);\n      }\n\n      return initGlslang;\n    }()\n  }, {\n    key: \"initContextAndSwapChain\",\n    value: function initContextAndSwapChain() {\n      this.context = this.canvas.getContext(isSafari ? 'gpu' : 'gpupresent');\n      this.swapChain = this.context.configureSwapChain({\n        device: this.device,\n        format: this.options.swapChainFormat,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment | WebGPUConstants.TextureUsage.CopySrc\n      });\n    }\n  }, {\n    key: \"initMainAttachments\",\n    value: function initMainAttachments() {\n      this.mainTextureExtends = {\n        width: this.canvas.width,\n        height: this.canvas.height,\n        depth: 1\n      };\n\n      if (this.options.antialiasing) {\n        var mainTextureDescriptor = {\n          size: this.mainTextureExtends,\n          // TODO: arrayLayerCount is deprecated: use size.depth\n          // arrayLayerCount: 1,\n          mipLevelCount: 1,\n          sampleCount: this.mainPassSampleCount,\n          dimension: WebGPUConstants.TextureDimension.E2d,\n          format: WebGPUConstants.TextureFormat.BGRA8Unorm,\n          usage: WebGPUConstants.TextureUsage.OutputAttachment\n        };\n\n        if (this.mainTexture) {\n          this.mainTexture.destroy();\n        }\n\n        this.mainTexture = this.device.createTexture(mainTextureDescriptor);\n        this.mainColorAttachments = [{\n          attachment: isSafari ? // @ts-ignore\n          this.mainTexture.createDefaultView() : this.mainTexture.createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store\n        }];\n      } else {\n        this.mainColorAttachments = [{\n          attachment: isSafari ? // @ts-ignore\n          this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store\n        }];\n      }\n\n      var depthTextureDescriptor = {\n        size: this.mainTextureExtends,\n        // arrayLayerCount: 1,\n        mipLevelCount: 1,\n        sampleCount: this.mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: isSafari ? 'depth32float-stencil8' : WebGPUConstants.TextureFormat.Depth24PlusStencil8,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment\n      };\n\n      if (this.depthTexture) {\n        this.depthTexture.destroy();\n      }\n\n      this.depthTexture = this.device.createTexture( // @ts-ignore\n      depthTextureDescriptor);\n      this.mainDepthAttachment = {\n        attachment: isSafari ? // @ts-ignore\n        this.depthTexture.createDefaultView() : this.depthTexture.createView(),\n        depthLoadValue: this.clearDepthValue,\n        depthStoreOp: WebGPUConstants.StoreOp.Store,\n        stencilLoadValue: this.clearStencilValue,\n        stencilStoreOp: WebGPUConstants.StoreOp.Store\n      };\n    }\n  }, {\n    key: \"startComputePass\",\n    value: function startComputePass() {\n      if (this.currentComputePass) {\n        this.endComputePass();\n      }\n\n      this.currentComputePass = this.computeEncoder.beginComputePass();\n    }\n  }, {\n    key: \"startMainRenderPass\",\n    value: function startMainRenderPass() {\n      if (this.currentRenderPass && !this.currentRenderTarget) {\n        this.endMainRenderPass();\n      } // Resolve in case of MSAA\n\n\n      if (this.options.antialiasing) {\n        this.mainColorAttachments[0].resolveTarget = isSafari ? // @ts-ignore\n        this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();\n      } else {\n        this.mainColorAttachments[0].attachment = isSafari ? // @ts-ignore\n        this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();\n      }\n\n      this.currentRenderPass = this.renderEncoder.beginRenderPass({\n        colorAttachments: this.mainColorAttachments,\n        depthStencilAttachment: this.mainDepthAttachment // TODO: use framebuffer's depth & stencil\n\n      });\n      this.mainRenderPass = this.currentRenderPass;\n\n      if (this.cachedViewport) {\n        this.viewport(this.cachedViewport);\n      }\n    }\n  }, {\n    key: \"startRenderTargetRenderPass\",\n    value: function startRenderTargetRenderPass(renderTarget, clearColor, clearDepth) {\n      var _renderTarget$get$col, _renderTarget$get$dep;\n\n      var clearStencil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var gpuTexture = (_renderTarget$get$col = renderTarget.get().color) === null || _renderTarget$get$col === void 0 ? void 0 : _renderTarget$get$col.texture;\n      var colorTextureView;\n\n      if (gpuTexture) {\n        colorTextureView = gpuTexture.createView(this.currentRenderTargetViewDescriptor);\n      }\n\n      var depthStencilTexture = (_renderTarget$get$dep = renderTarget.get().depth) === null || _renderTarget$get$dep === void 0 ? void 0 : _renderTarget$get$dep.texture;\n      var depthStencilTextureView;\n\n      if (depthStencilTexture) {\n        depthStencilTextureView = depthStencilTexture.createView();\n      }\n\n      var renderPass = this.renderTargetEncoder.beginRenderPass({\n        colorAttachments: [{\n          attachment: colorTextureView,\n          loadValue: clearColor !== null ? clearColor : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        }],\n        depthStencilAttachment: depthStencilTexture && depthStencilTextureView ? {\n          attachment: depthStencilTextureView,\n          depthLoadValue: clearDepth ? this.clearDepthValue : WebGPUConstants.LoadOp.Load,\n          depthStoreOp: WebGPUConstants.StoreOp.Store,\n          stencilLoadValue: clearStencil ? this.clearStencilValue : WebGPUConstants.LoadOp.Load,\n          stencilStoreOp: WebGPUConstants.StoreOp.Store\n        } : undefined\n      });\n      this.currentRenderPass = renderPass;\n\n      if (this.cachedViewport) {\n        this.viewport(this.cachedViewport);\n      } // TODO WEBGPU set the scissor rect and the stencil reference value\n\n    }\n  }, {\n    key: \"endMainRenderPass\",\n    value: function endMainRenderPass() {\n      if (this.currentRenderPass === this.mainRenderPass && this.currentRenderPass !== null) {\n        this.currentRenderPass.endPass();\n        this.resetCachedViewport();\n        this.currentRenderPass = null;\n        this.mainRenderPass = null;\n      }\n    }\n  }, {\n    key: \"endComputePass\",\n    value: function endComputePass() {\n      if (this.currentComputePass) {\n        this.currentComputePass.endPass();\n        this.currentComputePass = null;\n      }\n    }\n  }, {\n    key: \"endRenderTargetRenderPass\",\n    value: function endRenderTargetRenderPass() {\n      if (this.currentRenderPass) {\n        this.currentRenderPass.endPass();\n        this.resetCachedViewport();\n      }\n    }\n  }, {\n    key: \"resetCachedViewport\",\n    value: function resetCachedViewport() {\n      this.cachedViewport = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"unbindFramebuffer\",\n    value: function unbindFramebuffer(framebuffer) {\n      // unbind\n      if (this.currentRenderPass && this.currentRenderPass !== this.mainRenderPass) {\n        this.endRenderTargetRenderPass();\n      }\n\n      this.transientViewport.x = Infinity;\n      this.currentRenderTarget = null; // if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      //   this._generateMipmaps(texture);\n      // }\n\n      this.currentRenderPass = this.mainRenderPass;\n    }\n  }]);\n\n  return WebGPUEngine;\n}(), _temp)) || _class);","map":{"version":3,"mappings":"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","names":["isSafari","WebGPUConstants","injectable","glslang","WebGPUAttribute","WebGPUBuffer","WebGPUComputeModel","WebGPUElements","WebGPUFramebuffer","WebGPUModel","WebGPUTexture2D","WebGPUEngine","_classCallCheck","supportWebGPU","useWGSL","options","canvas","context","adapter","device","swapChain","mainPassSampleCount","mainTexture","depthTexture","mainColorAttachments","mainTextureExtends","mainDepthAttachment","uploadEncoder","renderEncoder","computeEncoder","renderTargetEncoder","commandBuffers","Array","fill","undefined","currentRenderPass","mainRenderPass","currentRenderTargetViewDescriptor","currentComputePass","bundleEncoder","tempBuffers","currentRenderTarget","uploadEncoderDescriptor","label","renderEncoderDescriptor","renderTargetEncoderDescriptor","computeEncoderDescriptor","pipelines","computePipelines","defaultSampleCount","clearDepthValue","clearStencilValue","transientViewport","x","Infinity","y","width","height","cachedViewport","clear","framebuffer","color","depth","stencil","_this","supportCompute","startComputePass","endRenderTargetRenderPass","startRenderTargetRenderPass","loadValue","LoadOp","Load","depthLoadValue","stencilLoadValue","endMainRenderPass","startMainRenderPass","createModel","model","_context","init","createAttribute","createBuffer","createElements","createTexture2D","createFramebuffer","useFramebuffer","drawCommands","unbindFramebuffer","dimension","TextureViewDimension","E2d","arrayLayerCount","aspect","TextureAspect","All","createComputeModel","_context2","getCanvas","getGLContext","Error","viewport","renderPass","getCurrentRenderPass","setViewport","readPixels","_createClass","key","value","config","antialiasing","_context3","initGlslang","initContextAndSwapChain","initMainAttachments","scissor","destroy","forEach","buffer","createCommandEncoder","endComputePass","finish","getQueue","submit","filter","defaultQueue","_context4","navigator","_navigator","gpu","_navigator$gpu","requestAdapter","requestDevice","getContext","configureSwapChain","format","swapChainFormat","usage","TextureUsage","OutputAttachment","CopySrc","mainTextureDescriptor","size","mipLevelCount","sampleCount","TextureDimension","TextureFormat","BGRA8Unorm","createTexture","attachment","createDefaultView","createView","storeOp","StoreOp","Store","getCurrentTexture","depthTextureDescriptor","Depth24PlusStencil8","depthStoreOp","stencilStoreOp","beginComputePass","resolveTarget","beginRenderPass","colorAttachments","depthStencilAttachment","renderTarget","clearColor","clearDepth","clearStencil","gpuTexture","get","_renderTarget$get$col","texture","colorTextureView","depthStencilTexture","_renderTarget$get$dep","depthStencilTextureView","endPass","resetCachedViewport"],"sources":["../../src/webgpu/index.ts"],"sourcesContent":["/**\n * implements renderService with WebGPU API\n * @see https://webgpu.io/\n * @see https://github.com/BabylonJS/Babylon.js/blob/WebGPU/src/Engines/webgpuEngine.ts\n */\nimport {\n  GLSLContext,\n  IAttribute,\n  IAttributeInitializationOptions,\n  IBuffer,\n  IBufferInitializationOptions,\n  IClearOptions,\n  IElements,\n  IElementsInitializationOptions,\n  IFramebuffer,\n  IFramebufferInitializationOptions,\n  IModel,\n  IModelInitializationOptions,\n  IReadPixelsOptions,\n  IRendererConfig,\n  IRendererService,\n  isSafari,\n  ITexture2D,\n  ITexture2DInitializationOptions,\n  IViewport,\n} from '@antv/g-webgpu-core';\n// import { Glslang } from '@webgpu/glslang/dist/web-devel/glslang.onefile';\nimport * as WebGPUConstants from '@webgpu/types/dist/constants';\nimport { vec4 } from 'gl-matrix';\nimport { injectable } from 'inversify';\nimport glslang from './glslang';\nimport WebGPUAttribute from './WebGPUAttribute';\nimport WebGPUBuffer from './WebGPUBuffer';\nimport WebGPUComputeModel from './WebGPUComputeModel';\nimport WebGPUElements from './WebGPUElements';\nimport WebGPUFramebuffer from './WebGPUFramebuffer';\nimport WebGPUModel from './WebGPUModel';\nimport WebGPUTexture2D from './WebGPUTexture2D';\n\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\ntype WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n/**\n * regl renderer\n */\n@injectable()\nexport class WebGPUEngine implements IRendererService {\n  public supportWebGPU = true;\n  public useWGSL = false;\n\n  public options: IRendererConfig;\n  public canvas: HTMLCanvasElement;\n  public context: GPUCanvasContext;\n  public glslang: any;\n  public adapter: GPUAdapter;\n  public device: GPUDevice;\n  public swapChain: GPUSwapChain;\n\n  public mainPassSampleCount: number;\n\n  public mainTexture: GPUTexture;\n  public depthTexture: GPUTexture;\n  public mainColorAttachments: GPURenderPassColorAttachmentDescriptor[];\n  public mainTextureExtends: GPUExtent3D;\n  public mainDepthAttachment: GPURenderPassDepthStencilAttachmentDescriptor;\n\n  // Frame Life Cycle (recreated each frame)\n  public uploadEncoder: GPUCommandEncoder;\n  public renderEncoder: GPUCommandEncoder;\n  public computeEncoder: GPUCommandEncoder;\n  public renderTargetEncoder: GPUCommandEncoder;\n  public commandBuffers: GPUCommandBuffer[] = new Array(4).fill(undefined);\n\n  // Frame Buffer Life Cycle (recreated for each render target pass)\n  public currentRenderPass: GPURenderPassEncoder | null = null;\n  public mainRenderPass: GPURenderPassEncoder | null = null;\n  public currentRenderTargetViewDescriptor: GPUTextureViewDescriptor;\n  public currentComputePass: GPUComputePassEncoder | null = null;\n  public bundleEncoder: GPURenderBundleEncoder | null;\n  public tempBuffers: GPUBuffer[] = [];\n  public currentRenderTarget: WebGPUFramebuffer | null = null;\n\n  public readonly uploadEncoderDescriptor = { label: 'upload' };\n  public readonly renderEncoderDescriptor = { label: 'render' };\n  public readonly renderTargetEncoderDescriptor = { label: 'renderTarget' };\n  public readonly computeEncoderDescriptor = { label: 'compute' };\n\n  /**\n   * 通过名称访问\n   */\n  private pipelines: {\n    [pipelineName: string]: GPURenderPipeline;\n  } = {};\n  private computePipelines: {\n    [pipelineName: string]: GPUComputePipeline;\n  } = {};\n\n  private readonly defaultSampleCount = 4;\n  private readonly clearDepthValue = 1;\n  private readonly clearStencilValue = 0;\n  private transientViewport: IViewport = {\n    x: Infinity,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n  private cachedViewport: IViewport = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  public isFloatSupported() {\n    return true;\n  }\n\n  public async init(config: IRendererConfig): Promise<void> {\n    this.canvas = config.canvas!;\n    this.options = config;\n    this.useWGSL = !!config.useWGSL;\n    this.mainPassSampleCount = config.antialiasing\n      ? this.defaultSampleCount\n      : 1;\n\n    await this.initGlslang();\n    this.initContextAndSwapChain();\n    this.initMainAttachments();\n  }\n\n  public setScissor(\n    scissor: Partial<{\n      enable: boolean;\n      box: { x: number; y: number; width: number; height: number };\n    }>,\n  ): void {\n    throw new Error('Method not implemented.');\n  }\n\n  public clear = (options: IClearOptions): void => {\n    const { framebuffer, color, depth, stencil } = options;\n\n    if (this.options.supportCompute) {\n      this.startComputePass();\n    }\n\n    // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n    if (this.currentRenderTarget) {\n      if (this.currentRenderPass) {\n        this.endRenderTargetRenderPass();\n      }\n      this.startRenderTargetRenderPass(\n        this.currentRenderTarget!,\n        color ? color : null,\n        !!depth,\n        !!stencil,\n      );\n    } else {\n      // if (this.useReverseDepthBuffer) {\n      //     this._depthCullingState.depthFunc = Constants.GREATER;\n      // }\n\n      this.mainColorAttachments[0].loadValue = color\n        ? color\n        : WebGPUConstants.LoadOp.Load;\n\n      this.mainDepthAttachment.depthLoadValue = depth\n        ? depth\n        : WebGPUConstants.LoadOp.Load;\n      this.mainDepthAttachment.stencilLoadValue = stencil\n        ? this.clearStencilValue\n        : WebGPUConstants.LoadOp.Load;\n\n      if (this.mainRenderPass) {\n        this.endMainRenderPass();\n      }\n\n      this.startMainRenderPass();\n    }\n  };\n\n  public createModel = async (\n    options: IModelInitializationOptions,\n  ): Promise<IModel> => {\n    const model = new WebGPUModel(this, options);\n    await model.init();\n    return model;\n  };\n\n  public createAttribute = (\n    options: IAttributeInitializationOptions,\n  ): IAttribute => {\n    return new WebGPUAttribute(this, options);\n  };\n\n  public createBuffer = (options: IBufferInitializationOptions): IBuffer => {\n    return new WebGPUBuffer(this, options);\n  };\n\n  public createElements = (\n    options: IElementsInitializationOptions,\n  ): IElements => {\n    return new WebGPUElements(this, options);\n  };\n\n  public createTexture2D = (\n    options: ITexture2DInitializationOptions,\n  ): ITexture2D => {\n    return new WebGPUTexture2D(this, options);\n  };\n\n  public createFramebuffer = (\n    options: IFramebufferInitializationOptions,\n  ): IFramebuffer => {\n    return new WebGPUFramebuffer(this, options);\n  };\n\n  public useFramebuffer = (\n    framebuffer: IFramebuffer | null,\n    drawCommands: () => void,\n  ): void => {\n    // bind\n    if (this.currentRenderTarget) {\n      this.unbindFramebuffer(this.currentRenderTarget);\n    }\n    this.currentRenderTarget = framebuffer as WebGPUFramebuffer;\n\n    // TODO: use mipmap options in framebuffer\n    this.currentRenderTargetViewDescriptor = {\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      // mipLevelCount: bindWithMipMaps ? WebGPUTextureHelper.computeNumMipmapLevels(texture.width, texture.height) - lodLevel : 1,\n      // baseArrayLayer: faceIndex,\n      // baseMipLevel: lodLevel,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All,\n    };\n\n    this.currentRenderPass = null;\n\n    drawCommands();\n  };\n\n  public createComputeModel = async (context: GLSLContext) => {\n    const model = new WebGPUComputeModel(this, context);\n    await model.init();\n    return model;\n  };\n\n  public getCanvas = (): HTMLCanvasElement => {\n    return this.canvas;\n  };\n\n  public getGLContext = (): WebGLRenderingContext => {\n    throw new Error('Method not implemented.');\n  };\n\n  public viewport = ({\n    x,\n    y,\n    width,\n    height,\n  }: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  }): void => {\n    if (!this.currentRenderPass) {\n      // call viewport() before current render pass created\n      this.transientViewport = { x, y, width, height };\n    } else if (this.transientViewport.x !== Infinity) {\n      const renderPass = this.getCurrentRenderPass();\n      // @see https://gpuweb.github.io/gpuweb/#dom-gpurenderpassencoder-setviewport\n      renderPass.setViewport(\n        this.transientViewport.x,\n        this.transientViewport.y,\n        this.transientViewport.width,\n        this.transientViewport.height,\n        0,\n        1,\n      );\n    } else if (\n      x !== this.cachedViewport.x ||\n      y !== this.cachedViewport.y ||\n      width !== this.cachedViewport.width ||\n      height !== this.cachedViewport.height\n    ) {\n      this.cachedViewport = { x, y, width, height };\n      const renderPass = this.getCurrentRenderPass();\n      renderPass.setViewport(x, y, width, height, 0, 1);\n    }\n  };\n\n  public readPixels = (options: IReadPixelsOptions): Uint8Array => {\n    throw new Error('Method not implemented.');\n  };\n\n  public destroy(): void {\n    if (this.mainTexture) {\n      this.mainTexture.destroy();\n    }\n    if (this.depthTexture) {\n      this.depthTexture.destroy();\n    }\n    this.tempBuffers.forEach((buffer) => buffer.destroy());\n    this.tempBuffers = [];\n  }\n\n  public beginFrame() {\n    this.uploadEncoder = this.device.createCommandEncoder(\n      this.uploadEncoderDescriptor,\n    );\n    this.renderEncoder = this.device.createCommandEncoder(\n      this.renderEncoderDescriptor,\n    );\n    this.renderTargetEncoder = this.device.createCommandEncoder(\n      this.renderTargetEncoderDescriptor,\n    );\n    if (this.options.supportCompute) {\n      this.computeEncoder = this.device.createCommandEncoder(\n        this.computeEncoderDescriptor,\n      );\n    }\n  }\n\n  public endFrame() {\n    if (this.options.supportCompute) {\n      this.endComputePass();\n    }\n\n    this.endMainRenderPass();\n\n    this.commandBuffers[0] = this.uploadEncoder.finish();\n    this.commandBuffers[1] = this.renderEncoder.finish();\n    if (this.options.supportCompute) {\n      this.commandBuffers[2] = this.computeEncoder.finish();\n    }\n    this.commandBuffers[3] = this.renderTargetEncoder.finish();\n\n    if (isSafari) {\n      this.device\n        // @ts-ignore\n        .getQueue()\n        .submit(this.commandBuffers.filter((buffer) => buffer));\n    } else {\n      this.device.defaultQueue.submit(\n        this.commandBuffers.filter((buffer) => buffer),\n      );\n    }\n  }\n\n  public getCurrentRenderPass(): GPURenderPassEncoder {\n    if (this.currentRenderTarget && !this.currentRenderPass) {\n      this.startRenderTargetRenderPass(\n        this.currentRenderTarget,\n        null,\n        false,\n        false,\n      );\n    } else if (!this.currentRenderPass) {\n      this.startMainRenderPass();\n    }\n\n    return this.currentRenderPass!;\n  }\n\n  private async initGlslang() {\n    this.glslang = await glslang();\n    this.adapter = (await navigator?.gpu?.requestAdapter()) as GPUAdapter;\n    this.device = (await this.adapter.requestDevice()) as GPUDevice;\n  }\n\n  private initContextAndSwapChain() {\n    this.context = (this.canvas.getContext(\n      isSafari ? 'gpu' : 'gpupresent',\n    ) as unknown) as GPUCanvasContext;\n    this.swapChain = this.context.configureSwapChain({\n      device: this.device,\n      format: this.options.swapChainFormat!,\n      usage:\n        WebGPUConstants.TextureUsage.OutputAttachment |\n        WebGPUConstants.TextureUsage.CopySrc,\n    });\n  }\n\n  private initMainAttachments() {\n    this.mainTextureExtends = {\n      width: this.canvas.width,\n      height: this.canvas.height,\n      depth: 1,\n    };\n\n    if (this.options.antialiasing) {\n      const mainTextureDescriptor = {\n        size: this.mainTextureExtends,\n        // TODO: arrayLayerCount is deprecated: use size.depth\n        // arrayLayerCount: 1,\n        mipLevelCount: 1,\n        sampleCount: this.mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: WebGPUConstants.TextureFormat.BGRA8Unorm,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment,\n      };\n\n      if (this.mainTexture) {\n        this.mainTexture.destroy();\n      }\n      this.mainTexture = this.device.createTexture(mainTextureDescriptor);\n      this.mainColorAttachments = [\n        {\n          attachment: isSafari\n            ? // @ts-ignore\n              this.mainTexture.createDefaultView()\n            : this.mainTexture.createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store,\n        },\n      ];\n    } else {\n      this.mainColorAttachments = [\n        {\n          attachment: isSafari\n            ? // @ts-ignore\n              this.swapChain.getCurrentTexture().createDefaultView()\n            : this.swapChain.getCurrentTexture().createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store,\n        },\n      ];\n    }\n\n    const depthTextureDescriptor = {\n      size: this.mainTextureExtends,\n      // arrayLayerCount: 1,\n      mipLevelCount: 1,\n      sampleCount: this.mainPassSampleCount,\n      dimension: WebGPUConstants.TextureDimension.E2d,\n      format: isSafari\n        ? 'depth32float-stencil8'\n        : WebGPUConstants.TextureFormat.Depth24PlusStencil8,\n      usage: WebGPUConstants.TextureUsage.OutputAttachment,\n    };\n\n    if (this.depthTexture) {\n      this.depthTexture.destroy();\n    }\n\n    this.depthTexture = this.device.createTexture(\n      // @ts-ignore\n      depthTextureDescriptor,\n    );\n    this.mainDepthAttachment = {\n      attachment: isSafari\n        ? // @ts-ignore\n          this.depthTexture.createDefaultView()\n        : this.depthTexture.createView(),\n      depthLoadValue: this.clearDepthValue,\n      depthStoreOp: WebGPUConstants.StoreOp.Store,\n      stencilLoadValue: this.clearStencilValue,\n      stencilStoreOp: WebGPUConstants.StoreOp.Store,\n    };\n  }\n\n  private startComputePass() {\n    if (this.currentComputePass) {\n      this.endComputePass();\n    }\n\n    this.currentComputePass = this.computeEncoder.beginComputePass();\n  }\n\n  private startMainRenderPass() {\n    if (this.currentRenderPass && !this.currentRenderTarget) {\n      this.endMainRenderPass();\n    }\n\n    // Resolve in case of MSAA\n    if (this.options.antialiasing) {\n      this.mainColorAttachments[0].resolveTarget = isSafari\n        ? // @ts-ignore\n          this.swapChain.getCurrentTexture().createDefaultView()\n        : this.swapChain.getCurrentTexture().createView();\n    } else {\n      this.mainColorAttachments[0].attachment = isSafari\n        ? // @ts-ignore\n          this.swapChain.getCurrentTexture().createDefaultView()\n        : this.swapChain.getCurrentTexture().createView();\n    }\n\n    this.currentRenderPass = this.renderEncoder.beginRenderPass({\n      colorAttachments: this.mainColorAttachments,\n      depthStencilAttachment: this.mainDepthAttachment, // TODO: use framebuffer's depth & stencil\n    });\n\n    this.mainRenderPass = this.currentRenderPass;\n\n    if (this.cachedViewport) {\n      this.viewport(this.cachedViewport);\n    }\n  }\n\n  private startRenderTargetRenderPass(\n    renderTarget: WebGPUFramebuffer,\n    clearColor: [number, number, number, number] | null,\n    clearDepth: boolean,\n    clearStencil: boolean = false,\n  ) {\n    const gpuTexture = renderTarget.get().color?.texture;\n    let colorTextureView: GPUTextureView;\n    if (gpuTexture) {\n      colorTextureView = gpuTexture.createView(\n        this.currentRenderTargetViewDescriptor,\n      );\n    }\n\n    const depthStencilTexture = renderTarget.get().depth?.texture;\n    let depthStencilTextureView;\n    if (depthStencilTexture) {\n      depthStencilTextureView = depthStencilTexture.createView();\n    }\n\n    const renderPass = this.renderTargetEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          attachment: colorTextureView!,\n          loadValue:\n            clearColor !== null ? clearColor : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store,\n        },\n      ],\n      depthStencilAttachment:\n        depthStencilTexture && depthStencilTextureView\n          ? {\n              attachment: depthStencilTextureView,\n              depthLoadValue: clearDepth\n                ? this.clearDepthValue\n                : WebGPUConstants.LoadOp.Load,\n              depthStoreOp: WebGPUConstants.StoreOp.Store,\n              stencilLoadValue: clearStencil\n                ? this.clearStencilValue\n                : WebGPUConstants.LoadOp.Load,\n              stencilStoreOp: WebGPUConstants.StoreOp.Store,\n            }\n          : undefined,\n    });\n\n    this.currentRenderPass = renderPass;\n\n    if (this.cachedViewport) {\n      this.viewport(this.cachedViewport);\n    }\n\n    // TODO WEBGPU set the scissor rect and the stencil reference value\n  }\n\n  private endMainRenderPass() {\n    if (\n      this.currentRenderPass === this.mainRenderPass &&\n      this.currentRenderPass !== null\n    ) {\n      this.currentRenderPass.endPass();\n      this.resetCachedViewport();\n      this.currentRenderPass = null;\n      this.mainRenderPass = null;\n    }\n  }\n\n  private endComputePass() {\n    if (this.currentComputePass) {\n      this.currentComputePass.endPass();\n      this.currentComputePass = null;\n    }\n  }\n\n  private endRenderTargetRenderPass() {\n    if (this.currentRenderPass) {\n      this.currentRenderPass.endPass();\n      this.resetCachedViewport();\n    }\n  }\n\n  private resetCachedViewport() {\n    this.cachedViewport = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n    };\n  }\n\n  private unbindFramebuffer(framebuffer: WebGPUFramebuffer) {\n    // unbind\n    if (\n      this.currentRenderPass &&\n      this.currentRenderPass !== this.mainRenderPass\n    ) {\n      this.endRenderTargetRenderPass();\n    }\n\n    this.transientViewport.x = Infinity;\n    this.currentRenderTarget = null;\n\n    // if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n    //   this._generateMipmaps(texture);\n    // }\n\n    this.currentRenderPass = this.mainRenderPass;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}