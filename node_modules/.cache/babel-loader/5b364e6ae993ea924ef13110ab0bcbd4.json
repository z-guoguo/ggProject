{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport * as pathUtil from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { map, each, isEqual, head, isArray } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\n\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n        y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\n\n\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\n\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  var path = pathUtil.catmullRom2Bezier(data, false);\n\n  var _a = head(points),\n      x = _a[0],\n      y = _a[1];\n\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\n\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\nexport function dataToRectPath(data, width, height, barWidth) {\n  if (barWidth === void 0) {\n    barWidth = 5;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  var rectPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var param = {\n      x: point[0],\n      y: point[1],\n      y0: height,\n      size: barWidth\n    };\n    var rectPoint = getRectPoints(param);\n    rectPoints.push.apply(rectPoints, rectPoint);\n  }\n\n  return getRectPath(rectPoints);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\n\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\n\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArray([], path, true);\n\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @returns rect points 返回矩形四个顶点信息\n */\n\nexport function getRectPoints(pointInfo) {\n  var x = pointInfo.x,\n      y = pointInfo.y,\n      y0 = pointInfo.y0,\n      size = pointInfo.size; // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n\n  var yMin;\n  var yMax;\n\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  var xMin;\n  var xMax;\n\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }]; // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\n\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  } // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n\n\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n\n    path.push(['z']);\n  }\n\n  return path;\n}","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","pathUtil","Category","Linear","map","each","isEqual","head","isArray","pointsToPath","points","p","idx","command","x","y","getLinePath","getSmoothLinePath","data","push","path","catmullRom2Bezier","_a","unshift","dataToPath","width","height","smooth","values","v","scale","dataToRectPath","barWidth","rectPoints","point","param","y0","size","rectPoint","getRectPoints","apply","getRectPath","getAreaLineY","lineY","Math","max","min","linePathToAreaPath","areaPath","lineYPx","pointInfo","yMin","yMax","xMin","xMax","isClosed","firstPoint","len"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/g6-plugin/es/timeBar/path.js"],"sourcesContent":["var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport * as pathUtil from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { map, each, isEqual, head, isArray } from '@antv/util';\n/**\n * 点数组转 path\n * @param points\n */\n\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n        y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\n\n\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\n\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  var path = pathUtil.catmullRom2Bezier(data, false);\n\n  var _a = head(points),\n      x = _a[0],\n      y = _a[1];\n\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\n\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\nexport function dataToRectPath(data, width, height, barWidth) {\n  if (barWidth === void 0) {\n    barWidth = 5;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  var rectPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var param = {\n      x: point[0],\n      y: point[1],\n      y0: height,\n      size: barWidth\n    };\n    var rectPoint = getRectPoints(param);\n    rectPoints.push.apply(rectPoints, rectPoint);\n  }\n\n  return getRectPath(rectPoints);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\n\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\n\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArray([], path, true);\n\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @returns rect points 返回矩形四个顶点信息\n */\n\nexport function getRectPoints(pointInfo) {\n  var x = pointInfo.x,\n      y = pointInfo.y,\n      y0 = pointInfo.y0,\n      size = pointInfo.size; // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n\n  var yMin;\n  var yMax;\n\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  var xMin;\n  var xMax;\n\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }]; // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\n\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  } // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n\n\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n\n    path.push(['z']);\n  }\n\n  return path;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}