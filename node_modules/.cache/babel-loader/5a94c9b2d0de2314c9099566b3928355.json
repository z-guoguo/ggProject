{"ast":null,"code":"import { getNeighbors } from \"./util\";\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\n\nexport var detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = getNeighbors(node.id, edges);\n\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n\n      allComponents.push(component);\n    }\n  }\n\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\n\nexport var detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true; // 考虑每个邻接点\n\n    var neighbors = getNeighbors(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        } // tree edge\n\n\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    } // If node is a root node, generate an SCC\n\n\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n};\nexport default function getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}","map":{"version":3,"names":["getNeighbors","detectConnectedComponents","graphData","_a","nodes","_b","edges","allComponents","visited","nodeStack","getComponent","node","push","id","neighbors","_loop_1","i","neighbor","targetNode","filter","length","component","pop","detectStrongConnectComponents","inStack","indices","lowLink","index","n","map","indexOf","_loop_2","targetNodeID","Math","min","tmpNode","_i","nodes_1","getConnectedComponents","directed"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/es/connected-component.js"],"sourcesContent":["import { getNeighbors } from \"./util\";\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\n\nexport var detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = getNeighbors(node.id, edges);\n\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n\n      allComponents.push(component);\n    }\n  }\n\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\n\nexport var detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true; // 考虑每个邻接点\n\n    var neighbors = getNeighbors(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        } // tree edge\n\n\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    } // If node is a root node, generate an SCC\n\n\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n};\nexport default function getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}