{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nimport { squareDist, pointLineSquareDist, itemIntersectByLine, getPointsCenter, fractionToLine, isPointsOverlap, pointRectSquareDist, Line, isPointInPolygon } from '../../util/math';\nvar defaultOps = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 100,\n  pixelGroupSize: 2,\n  edgeR0: 10,\n  edgeR1: 10,\n  nodeR0: 5,\n  nodeR1: 10,\n  morphBuffer: 5,\n  threshold: 0.001,\n  skip: 16,\n  nodeInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  negativeNodeInfluenceFactor: -0.5\n};\n/**\n * Marching square algorithm for traching the contour of a pixel group\n * https://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/\n * @param potentialArea\n * @param threshold\n */\n\nfunction MarchingSquares(contour, potentialArea, threshold) {\n  var marched = false;\n\n  var getVal = function getVal(x, y) {\n    return potentialArea.cells[x + y * potentialArea.width];\n  };\n\n  var getState = function getState(x, y) {\n    var squareVal = 0;\n\n    if (getVal(x - 1, y - 1) >= threshold) {\n      squareVal += 1;\n    }\n\n    if (getVal(x, y - 1) > threshold) {\n      squareVal += 2;\n    }\n\n    if (getVal(x - 1, y) > threshold) {\n      squareVal += 4;\n    }\n\n    if (getVal(x, y) > threshold) {\n      squareVal += 8;\n    }\n\n    return squareVal;\n  };\n\n  var doMarch = function doMarch(xPos, yPos) {\n    var x = xPos;\n    var y = yPos;\n    var prevX;\n    var prevY;\n\n    for (var i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      prevX = x;\n      prevY = y;\n\n      if (contour.findIndex(function (item) {\n        return item.x === x && item.y === y;\n      }) > -1) {\n        if (contour[0].x !== x || contour[0].y !== y) {// encountered a loop but haven't returned to start: change direction using conditionals and continue back to start\n        } else {\n          return true;\n        }\n      } else {\n        contour.push({\n          x: x,\n          y: y\n        });\n      }\n\n      var state = getState(x, y); // assign the move direction according to state of the square\n\n      switch (state) {\n        case -1:\n          console.warn('Marched out of bounds');\n          return true;\n\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          x++; // go right\n\n          break;\n\n        case 12:\n        case 14:\n        case 4:\n          x--; // go left\n\n          break;\n\n        case 6:\n          // go left if come from up else go right\n          if (prevX === 0) {\n            if (prevY === -1) {\n              x -= 1;\n            } else {\n              x += 1;\n            }\n          }\n\n          break;\n\n        case 1:\n        case 13:\n        case 5:\n          y--; // go up\n\n          break;\n\n        case 9:\n          // go up if come from right else go down\n          if (prevX === 1) {\n            if (prevY === 0) {\n              y -= 1;\n            } else {\n              y += 1;\n            }\n          }\n\n          break;\n\n        case 10:\n        case 8:\n        case 11:\n          y++; // go down\n\n          break;\n\n        default:\n          console.warn(\"Marching squares invalid state: \".concat(state));\n          return true;\n      }\n    }\n  };\n\n  this.march = function () {\n    for (var x = 0; x < potentialArea.width && !marched; x += 1) {\n      for (var y = 0; y < potentialArea.height && !marched; y += 1) {\n        if (getVal(x, y) > threshold && getState(x, y) !== 15) {\n          marched = doMarch(x, y);\n        }\n      }\n    }\n\n    return marched;\n  };\n}\n/**\n * Space partition & assign value to each cell\n * @param points\n */\n\n\nvar initGridCells = function initGridCells(width, height, pixelGroupSize) {\n  var scaleWidth = Math.ceil(width / pixelGroupSize);\n  var scaleHeight = Math.ceil(height / pixelGroupSize);\n  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);\n  return {\n    cells: gridCells,\n    width: scaleWidth,\n    height: scaleHeight\n  };\n};\n/**\n * Find the optimal already visited member to item;\n   Optimal: minimize cost(j) = distance(i,j) ∗ countObstacles(i,j)\n * @param item\n * @param visited\n */\n\n\nvar pickBestNeighbor = function pickBestNeighbor(item, visited, nonMembers) {\n  var closestNeighbour = null;\n  var minCost = Number.POSITIVE_INFINITY;\n  visited.forEach(function (neighbourItem) {\n    var itemP = {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n    var neighbourItemP = {\n      x: neighbourItem.getModel().x,\n      y: neighbourItem.getModel().y\n    };\n    var dist = squareDist(itemP, neighbourItemP);\n    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);\n    var numberObstacles = nonMembers.reduce(function (count, _item) {\n      if (fractionToLine(_item, directLine) > 0) {\n        return count + 1;\n      }\n\n      return count;\n    }, 0);\n\n    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {\n      closestNeighbour = neighbourItem;\n      minCost = dist * Math.pow(numberObstacles + 1, 2);\n    }\n  });\n  return closestNeighbour;\n};\n/**\n * 返回和线相交的item中，离边的起点最近的item\n * @param items\n * @param line\n */\n\n\nvar getIntersectItem = function getIntersectItem(items, line) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  var closestItem = null;\n  items.forEach(function (item) {\n    var distance = fractionToLine(item, line); // find closest intersection\n\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  });\n  return closestItem;\n};\n/**\n * Modify the directLine and Route virtual edges around obstacles\n */\n\n\nvar computeRoute = function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  var checkedLines = [];\n  var linesToCheck = [];\n  linesToCheck.push(directLine);\n  var hasIntersection = true;\n  var iterations = 0;\n\n  var pointExists = function pointExists(point, lines) {\n    var flag = false;\n    lines.forEach(function (line) {\n      if (flag) return;\n\n      if (isPointsOverlap(point, {\n        x: line.x1,\n        y: line.y1\n      }) || isPointsOverlap(point, {\n        x: line.x2,\n        y: line.y2\n      })) {\n        flag = true;\n      }\n    });\n    return flag;\n  };\n\n  var isPointInNonMembers = function isPointInNonMembers(point, _nonMembers) {\n    for (var _i = 0, _nonMembers_1 = _nonMembers; _i < _nonMembers_1.length; _i++) {\n      var item = _nonMembers_1[_i];\n      var bbox = item.getBBox();\n      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];\n\n      if (isPointInPolygon(itemContour, point.x, point.y)) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // outer loop end when no more intersections or out of iterations\n\n\n  while (hasIntersection && iterations < maxRoutingIterations) {\n    hasIntersection = false;\n\n    var _loop_1 = function _loop_1() {\n      var line = linesToCheck.pop();\n      var closestItem = getIntersectItem(nonMembers, line);\n\n      if (closestItem) {\n        var _a = itemIntersectByLine(closestItem, line),\n            intersections_1 = _a[0],\n            countIntersections = _a[1]; // if line passes through item\n\n\n        if (countIntersections === 2) {\n          var testReroute = function testReroute(isFirst) {\n            var tempMorphBuffer = morphBuffer;\n            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst); // test the virtualNode already exists\n\n            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n            var pointInside = isPointInNonMembers(virtualNode, nonMembers);\n\n            while (!exist && pointInside && tempMorphBuffer >= 1) {\n              // try a smaller buffer\n              tempMorphBuffer /= 1.5;\n              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n              pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            } // 第二次route时不要求pointInside\n\n\n            if (virtualNode && !exist && (!isFirst || !pointInside)) {\n              // add 2 rerouted lines to check\n              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));\n              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));\n              hasIntersection = true;\n            }\n          };\n\n          testReroute(true);\n\n          if (!hasIntersection) {\n            // if we didn't find a valid point around the first corner, try the second\n            testReroute(false);\n          }\n        }\n      } // no intersection found, mark this line as completed\n\n\n      if (!hasIntersection) {\n        checkedLines.push(line);\n      }\n\n      iterations += 1;\n    }; // inner loop end when out of lines or found an intersection\n\n\n    while (!hasIntersection && linesToCheck.length) {\n      _loop_1();\n    }\n  } // 加入剩余的线\n\n\n  while (linesToCheck.length) {\n    checkedLines.push(linesToCheck.pop());\n  }\n\n  return checkedLines;\n};\n/**\n *  Connect item with visited members using direct line or virtual edges\n */\n\n\nfunction getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {\n  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);\n\n  if (optimalNeighbor === null) {\n    return [];\n  } //  merge the consecutive lines\n\n\n  var mergeLines = function mergeLines(checkedLines) {\n    var finalRoute = [];\n\n    while (checkedLines.length > 0) {\n      var line1 = checkedLines.pop();\n\n      if (checkedLines.length === 0) {\n        finalRoute.push(line1);\n        break;\n      }\n\n      var line2 = checkedLines.pop();\n      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n      var closestItem = getIntersectItem(nonMembers, mergeLine); // merge most recent line and previous line\n\n      if (!closestItem) {\n        checkedLines.push(mergeLine);\n      } else {\n        finalRoute.push(line1);\n        checkedLines.push(line2);\n      }\n    }\n\n    return finalRoute;\n  };\n\n  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);\n  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  var finalRoute = mergeLines(checkedLines);\n  return finalRoute;\n}\n/**\n * Calculate the countor that includes the  selected items and exclues the non-selected items\n * @param graph\n * @param members\n * @param nonMembers\n * @param options\n */\n\n\nexport var genBubbleSet = function genBubbleSet(members, nonMembers, ops) {\n  // eslint-disable-next-line no-redeclare\n  var options = Object.assign(defaultOps, ops);\n  var centroid = getPointsCenter(members.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  })); // 按照到中心距离远近排序\n\n  members = members.sort(function (a, b) {\n    return squareDist({\n      x: a.getModel().x,\n      y: a.getModel().y\n    }, centroid) - squareDist({\n      x: b.getModel().x,\n      y: b.getModel().y\n    }, centroid);\n  });\n  var visited = [];\n  var virtualEdges = [];\n  members.forEach(function (item) {\n    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);\n    lines.forEach(function (l) {\n      virtualEdges.push(l);\n    });\n    visited.push(item);\n  }); // 由于edge也可以作为member和nonMember传入，暂时不考虑把edges作为参数传入genBubbleSet\n  // edges && edges.forEach(e => {\n  //   virtualEdges.push(new Line(e.getSource().getModel().x, e.getSource().getModel().y, e.getTarget().getModel().x, e.getTarget().getModel().y));\n  // });\n\n  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);\n  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize); // Use march squares to generate contour\n\n  var contour = [];\n  var hull = [];\n\n  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {\n    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);\n    contour = [];\n    hull = [];\n    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;\n    var marchedPath = contour.map(function (point) {\n      return {\n        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),\n        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)\n      };\n    }); // const marchedPath = marchingSquares(potentialArea, options.threshold).map(point => ({ x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX), y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY) }))\n\n    if (marchedPath) {\n      var size = marchedPath.length;\n\n      if (options.skip > 1) {\n        size = Math.floor(marchedPath.length / options.skip); // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\n\n        while (size < 3 && options.skip > 1) {\n          options.skip -= 1;\n          size = Math.floor(marchedPath.length / options.skip);\n        }\n      } // copy hull values\n\n\n      for (var i = 0, j = 0; j < size; j += 1, i += options.skip) {\n        hull.push({\n          x: marchedPath[i].x,\n          y: marchedPath[i].y\n        });\n      }\n    }\n\n    var isContourValid = function isContourValid() {\n      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n        var item = members_1[_i];\n        var hullPoints = hull.map(function (point) {\n          return [point.x, point.y];\n        });\n        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;\n      } // 不强制要求所有nonMembers都没有包含在内\n      // for (const item of nonMembers) {\n      //   if (isPointInPolygon({ x: item.getBBox().centerX, y: item.getBBox().centerY }, contour)) return false\n      // }\n\n\n      return true;\n    };\n\n    if (hull && isContourValid()) {\n      return hull;\n    } // update parameters for next iteraction\n\n\n    options.threshold *= 0.9;\n\n    if (iterations <= options.maxMarchingIterations * 0.5) {\n      options.memberInfluenceFactor *= 1.2;\n      options.edgeInfluenceFactor *= 1.2;\n    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      // after half the iterations, start increasing positive energy and lowering the threshold\n      options.nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n\n  return hull;\n};\n/**\n * unionboundingbox\n * @param members\n * @param edges\n */\n\nfunction getActiveRregion(members, edges, offset) {\n  var activeRegion = {\n    minX: Number.POSITIVE_INFINITY,\n    minY: Number.POSITIVE_INFINITY,\n    maxX: Number.NEGATIVE_INFINITY,\n    maxY: Number.NEGATIVE_INFINITY,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  };\n  var bboxes = [];\n  members.forEach(function (item) {\n    bboxes.push(item.getBBox());\n  });\n  edges.forEach(function (l) {\n    bboxes.push(l.getBBox());\n  });\n\n  for (var _i = 0, bboxes_1 = bboxes; _i < bboxes_1.length; _i++) {\n    var bbox = bboxes_1[_i];\n    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;\n    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;\n    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;\n    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;\n  }\n\n  activeRegion.width = activeRegion.maxX - activeRegion.minX;\n  activeRegion.height = activeRegion.maxY - activeRegion.minY;\n  activeRegion.x = activeRegion.minX;\n  activeRegion.y = activeRegion.minY;\n  return activeRegion;\n}\n\nfunction fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {\n  function pos2GridIx(x, offset) {\n    var gridIx = Math.floor((x - offset) / options.pixelGroupSize);\n    return gridIx < 0 ? 0 : gridIx;\n  }\n\n  function gridIx2Pos(x, offset) {\n    return x * options.pixelGroupSize + offset;\n  } // using inverse a for numerical stability\n\n\n  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);\n  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);\n\n  var getAffectedRegion = function getAffectedRegion(bbox, thresholdR) {\n    var startX = Math.min(pos2GridIx(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);\n    var startY = Math.min(pos2GridIx(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);\n    var endX = Math.min(pos2GridIx(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);\n    var endY = Math.min(pos2GridIx(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);\n    return [startX, startY, endX, endY];\n  };\n\n  var addItemInfluence = function addItemInfluence(item, influenceFactor) {\n    var bbox = item.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.nodeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // calculate item influence for each cell\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var distanceSq = pointRectSquareDist({\n          x: tempX,\n          y: tempY\n        }, {\n          x: bbox.minX,\n          y: bbox.minY,\n          width: bbox.width,\n          height: bbox.height\n        });\n\n        if (distanceSq < Math.pow(options.nodeR1, 2)) {\n          var dr = Math.sqrt(distanceSq) - options.nodeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * dr * dr;\n        }\n      }\n    }\n  };\n\n  var addEdgeInfluence = function addEdgeInfluence(line, influenceFactor) {\n    var bbox = line.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.edgeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // for every point in active part of potentialArea, calculate distance to nearest point on line and add influence\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea.cells[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var minDistanceSq = pointLineSquareDist({\n          x: tempX,\n          y: tempY\n        }, line); // only influence if less than r1\n\n        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {\n          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * mdr * mdr;\n        }\n      }\n    }\n  };\n\n  if (options.nodeInfluenceFactor) {\n    members.forEach(function (item) {\n      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);\n    });\n  }\n\n  if (options.edgeInfluenceFactor) {\n    edges.forEach(function (edge) {\n      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);\n    });\n  }\n\n  if (options.negativeNodeInfluenceFactor) {\n    nonMembers.forEach(function (item) {\n      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);\n    });\n  }\n}\n\nfunction rerouteLine(item, buffer, intersections, wrapNormal) {\n  var bbox = item.getBBox();\n  var topIntersect = intersections[0],\n      leftIntersect = intersections[1],\n      bottomIntersect = intersections[2],\n      rightIntersect = intersections[3];\n  var cornerPos = {\n    topLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.minY - buffer\n    },\n    topRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.minY - buffer\n    },\n    bottomLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.maxY + buffer\n    },\n    bottomRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.maxY + buffer\n    }\n  };\n  var totalArea = bbox.height * bbox.width;\n\n  function calcHalfArea(intersect1, intersect2) {\n    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);\n  } // 根据线和boundingbox相交的情况，确定control point的位置\n\n\n  if (leftIntersect) {\n    // 相交区域有三角形\n    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight; // 相交区域分成上下两个梯形，比较面积\n\n    var topArea = calcHalfArea(leftIntersect, rightIntersect);\n\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    }\n\n    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n\n  if (rightIntersect) {\n    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  } // 相交区域分成左右两个梯形\n\n\n  var leftArea = calcHalfArea(topIntersect, bottomIntersect);\n\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n  }\n\n  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n}","map":{"version":3,"names":["squareDist","pointLineSquareDist","itemIntersectByLine","getPointsCenter","fractionToLine","isPointsOverlap","pointRectSquareDist","Line","isPointInPolygon","defaultOps","maxRoutingIterations","maxMarchingIterations","pixelGroupSize","edgeR0","edgeR1","nodeR0","nodeR1","morphBuffer","threshold","skip","nodeInfluenceFactor","edgeInfluenceFactor","negativeNodeInfluenceFactor","MarchingSquares","contour","potentialArea","marched","getVal","x","y","cells","width","getState","squareVal","doMarch","xPos","yPos","prevX","prevY","i","height","findIndex","item","push","state","console","warn","concat","march","initGridCells","scaleWidth","Math","ceil","scaleHeight","gridCells","Float32Array","max","fill","pickBestNeighbor","visited","nonMembers","closestNeighbour","minCost","Number","POSITIVE_INFINITY","forEach","neighbourItem","itemP","getModel","neighbourItemP","dist","directLine","numberObstacles","reduce","count","_item","pow","getIntersectItem","items","line","minDistance","closestItem","distance","computeRoute","checkedLines","linesToCheck","hasIntersection","iterations","pointExists","point","lines","flag","x1","y1","x2","y2","isPointInNonMembers","_nonMembers","_i","_nonMembers_1","length","bbox","getBBox","itemContour","_loop_1","pop","_a","intersections_1","countIntersections","testReroute","isFirst","tempMorphBuffer","virtualNode","rerouteLine","exist","pointInside","getRoute","optimalNeighbor","mergeLines","finalRoute","line1","line2","mergeLine","genBubbleSet","members","ops","options","Object","assign","centroid","map","sort","a","b","virtualEdges","l","activeRegion","getActiveRregion","hull","fillPotentialArea","marchedPath","round","minX","minY","size","floor","j","isContourValid","members_1","hullPoints","centerX","centerY","memberInfluenceFactor","nonMemberInfluenceFactor","edges","offset","maxX","NEGATIVE_INFINITY","maxY","bboxes","bboxes_1","pos2GridIx","gridIx","gridIx2Pos","nodeInfA","edgeInfA","getAffectedRegion","thresholdR","startX","min","startY","endX","endY","addItemInfluence","influenceFactor","tempX","tempY","distanceSq","dr","sqrt","addEdgeInfluence","minDistanceSq","mdr","edge","buffer","intersections","wrapNormal","topIntersect","leftIntersect","bottomIntersect","rightIntersect","cornerPos","topLeft","topRight","bottomLeft","bottomRight","totalArea","calcHalfArea","intersect1","intersect2","topArea","leftArea"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/g6-core/es/element/hull/bubbleset.js"],"sourcesContent":["import { squareDist, pointLineSquareDist, itemIntersectByLine, getPointsCenter, fractionToLine, isPointsOverlap, pointRectSquareDist, Line, isPointInPolygon } from '../../util/math';\nvar defaultOps = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 100,\n  pixelGroupSize: 2,\n  edgeR0: 10,\n  edgeR1: 10,\n  nodeR0: 5,\n  nodeR1: 10,\n  morphBuffer: 5,\n  threshold: 0.001,\n  skip: 16,\n  nodeInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  negativeNodeInfluenceFactor: -0.5\n};\n/**\n * Marching square algorithm for traching the contour of a pixel group\n * https://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/\n * @param potentialArea\n * @param threshold\n */\n\nfunction MarchingSquares(contour, potentialArea, threshold) {\n  var marched = false;\n\n  var getVal = function getVal(x, y) {\n    return potentialArea.cells[x + y * potentialArea.width];\n  };\n\n  var getState = function getState(x, y) {\n    var squareVal = 0;\n\n    if (getVal(x - 1, y - 1) >= threshold) {\n      squareVal += 1;\n    }\n\n    if (getVal(x, y - 1) > threshold) {\n      squareVal += 2;\n    }\n\n    if (getVal(x - 1, y) > threshold) {\n      squareVal += 4;\n    }\n\n    if (getVal(x, y) > threshold) {\n      squareVal += 8;\n    }\n\n    return squareVal;\n  };\n\n  var doMarch = function doMarch(xPos, yPos) {\n    var x = xPos;\n    var y = yPos;\n    var prevX;\n    var prevY;\n\n    for (var i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      prevX = x;\n      prevY = y;\n\n      if (contour.findIndex(function (item) {\n        return item.x === x && item.y === y;\n      }) > -1) {\n        if (contour[0].x !== x || contour[0].y !== y) {// encountered a loop but haven't returned to start: change direction using conditionals and continue back to start\n        } else {\n          return true;\n        }\n      } else {\n        contour.push({\n          x: x,\n          y: y\n        });\n      }\n\n      var state = getState(x, y); // assign the move direction according to state of the square\n\n      switch (state) {\n        case -1:\n          console.warn('Marched out of bounds');\n          return true;\n\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          x++; // go right\n\n          break;\n\n        case 12:\n        case 14:\n        case 4:\n          x--; // go left\n\n          break;\n\n        case 6:\n          // go left if come from up else go right\n          if (prevX === 0) {\n            if (prevY === -1) {\n              x -= 1;\n            } else {\n              x += 1;\n            }\n          }\n\n          break;\n\n        case 1:\n        case 13:\n        case 5:\n          y--; // go up\n\n          break;\n\n        case 9:\n          // go up if come from right else go down\n          if (prevX === 1) {\n            if (prevY === 0) {\n              y -= 1;\n            } else {\n              y += 1;\n            }\n          }\n\n          break;\n\n        case 10:\n        case 8:\n        case 11:\n          y++; // go down\n\n          break;\n\n        default:\n          console.warn(\"Marching squares invalid state: \".concat(state));\n          return true;\n      }\n    }\n  };\n\n  this.march = function () {\n    for (var x = 0; x < potentialArea.width && !marched; x += 1) {\n      for (var y = 0; y < potentialArea.height && !marched; y += 1) {\n        if (getVal(x, y) > threshold && getState(x, y) !== 15) {\n          marched = doMarch(x, y);\n        }\n      }\n    }\n\n    return marched;\n  };\n}\n/**\n * Space partition & assign value to each cell\n * @param points\n */\n\n\nvar initGridCells = function initGridCells(width, height, pixelGroupSize) {\n  var scaleWidth = Math.ceil(width / pixelGroupSize);\n  var scaleHeight = Math.ceil(height / pixelGroupSize);\n  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);\n  return {\n    cells: gridCells,\n    width: scaleWidth,\n    height: scaleHeight\n  };\n};\n/**\n * Find the optimal already visited member to item;\n   Optimal: minimize cost(j) = distance(i,j) ∗ countObstacles(i,j)\n * @param item\n * @param visited\n */\n\n\nvar pickBestNeighbor = function pickBestNeighbor(item, visited, nonMembers) {\n  var closestNeighbour = null;\n  var minCost = Number.POSITIVE_INFINITY;\n  visited.forEach(function (neighbourItem) {\n    var itemP = {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n    var neighbourItemP = {\n      x: neighbourItem.getModel().x,\n      y: neighbourItem.getModel().y\n    };\n    var dist = squareDist(itemP, neighbourItemP);\n    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);\n    var numberObstacles = nonMembers.reduce(function (count, _item) {\n      if (fractionToLine(_item, directLine) > 0) {\n        return count + 1;\n      }\n\n      return count;\n    }, 0);\n\n    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {\n      closestNeighbour = neighbourItem;\n      minCost = dist * Math.pow(numberObstacles + 1, 2);\n    }\n  });\n  return closestNeighbour;\n};\n/**\n * 返回和线相交的item中，离边的起点最近的item\n * @param items\n * @param line\n */\n\n\nvar getIntersectItem = function getIntersectItem(items, line) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  var closestItem = null;\n  items.forEach(function (item) {\n    var distance = fractionToLine(item, line); // find closest intersection\n\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  });\n  return closestItem;\n};\n/**\n * Modify the directLine and Route virtual edges around obstacles\n */\n\n\nvar computeRoute = function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  var checkedLines = [];\n  var linesToCheck = [];\n  linesToCheck.push(directLine);\n  var hasIntersection = true;\n  var iterations = 0;\n\n  var pointExists = function pointExists(point, lines) {\n    var flag = false;\n    lines.forEach(function (line) {\n      if (flag) return;\n\n      if (isPointsOverlap(point, {\n        x: line.x1,\n        y: line.y1\n      }) || isPointsOverlap(point, {\n        x: line.x2,\n        y: line.y2\n      })) {\n        flag = true;\n      }\n    });\n    return flag;\n  };\n\n  var isPointInNonMembers = function isPointInNonMembers(point, _nonMembers) {\n    for (var _i = 0, _nonMembers_1 = _nonMembers; _i < _nonMembers_1.length; _i++) {\n      var item = _nonMembers_1[_i];\n      var bbox = item.getBBox();\n      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];\n\n      if (isPointInPolygon(itemContour, point.x, point.y)) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // outer loop end when no more intersections or out of iterations\n\n\n  while (hasIntersection && iterations < maxRoutingIterations) {\n    hasIntersection = false;\n\n    var _loop_1 = function _loop_1() {\n      var line = linesToCheck.pop();\n      var closestItem = getIntersectItem(nonMembers, line);\n\n      if (closestItem) {\n        var _a = itemIntersectByLine(closestItem, line),\n            intersections_1 = _a[0],\n            countIntersections = _a[1]; // if line passes through item\n\n\n        if (countIntersections === 2) {\n          var testReroute = function testReroute(isFirst) {\n            var tempMorphBuffer = morphBuffer;\n            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst); // test the virtualNode already exists\n\n            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n            var pointInside = isPointInNonMembers(virtualNode, nonMembers);\n\n            while (!exist && pointInside && tempMorphBuffer >= 1) {\n              // try a smaller buffer\n              tempMorphBuffer /= 1.5;\n              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n              pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            } // 第二次route时不要求pointInside\n\n\n            if (virtualNode && !exist && (!isFirst || !pointInside)) {\n              // add 2 rerouted lines to check\n              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));\n              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));\n              hasIntersection = true;\n            }\n          };\n\n          testReroute(true);\n\n          if (!hasIntersection) {\n            // if we didn't find a valid point around the first corner, try the second\n            testReroute(false);\n          }\n        }\n      } // no intersection found, mark this line as completed\n\n\n      if (!hasIntersection) {\n        checkedLines.push(line);\n      }\n\n      iterations += 1;\n    }; // inner loop end when out of lines or found an intersection\n\n\n    while (!hasIntersection && linesToCheck.length) {\n      _loop_1();\n    }\n  } // 加入剩余的线\n\n\n  while (linesToCheck.length) {\n    checkedLines.push(linesToCheck.pop());\n  }\n\n  return checkedLines;\n};\n/**\n *  Connect item with visited members using direct line or virtual edges\n */\n\n\nfunction getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {\n  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);\n\n  if (optimalNeighbor === null) {\n    return [];\n  } //  merge the consecutive lines\n\n\n  var mergeLines = function mergeLines(checkedLines) {\n    var finalRoute = [];\n\n    while (checkedLines.length > 0) {\n      var line1 = checkedLines.pop();\n\n      if (checkedLines.length === 0) {\n        finalRoute.push(line1);\n        break;\n      }\n\n      var line2 = checkedLines.pop();\n      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n      var closestItem = getIntersectItem(nonMembers, mergeLine); // merge most recent line and previous line\n\n      if (!closestItem) {\n        checkedLines.push(mergeLine);\n      } else {\n        finalRoute.push(line1);\n        checkedLines.push(line2);\n      }\n    }\n\n    return finalRoute;\n  };\n\n  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);\n  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  var finalRoute = mergeLines(checkedLines);\n  return finalRoute;\n}\n/**\n * Calculate the countor that includes the  selected items and exclues the non-selected items\n * @param graph\n * @param members\n * @param nonMembers\n * @param options\n */\n\n\nexport var genBubbleSet = function genBubbleSet(members, nonMembers, ops) {\n  // eslint-disable-next-line no-redeclare\n  var options = Object.assign(defaultOps, ops);\n  var centroid = getPointsCenter(members.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  })); // 按照到中心距离远近排序\n\n  members = members.sort(function (a, b) {\n    return squareDist({\n      x: a.getModel().x,\n      y: a.getModel().y\n    }, centroid) - squareDist({\n      x: b.getModel().x,\n      y: b.getModel().y\n    }, centroid);\n  });\n  var visited = [];\n  var virtualEdges = [];\n  members.forEach(function (item) {\n    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);\n    lines.forEach(function (l) {\n      virtualEdges.push(l);\n    });\n    visited.push(item);\n  }); // 由于edge也可以作为member和nonMember传入，暂时不考虑把edges作为参数传入genBubbleSet\n  // edges && edges.forEach(e => {\n  //   virtualEdges.push(new Line(e.getSource().getModel().x, e.getSource().getModel().y, e.getTarget().getModel().x, e.getTarget().getModel().y));\n  // });\n\n  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);\n  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize); // Use march squares to generate contour\n\n  var contour = [];\n  var hull = [];\n\n  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {\n    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);\n    contour = [];\n    hull = [];\n    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;\n    var marchedPath = contour.map(function (point) {\n      return {\n        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),\n        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)\n      };\n    }); // const marchedPath = marchingSquares(potentialArea, options.threshold).map(point => ({ x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX), y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY) }))\n\n    if (marchedPath) {\n      var size = marchedPath.length;\n\n      if (options.skip > 1) {\n        size = Math.floor(marchedPath.length / options.skip); // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\n\n        while (size < 3 && options.skip > 1) {\n          options.skip -= 1;\n          size = Math.floor(marchedPath.length / options.skip);\n        }\n      } // copy hull values\n\n\n      for (var i = 0, j = 0; j < size; j += 1, i += options.skip) {\n        hull.push({\n          x: marchedPath[i].x,\n          y: marchedPath[i].y\n        });\n      }\n    }\n\n    var isContourValid = function isContourValid() {\n      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n        var item = members_1[_i];\n        var hullPoints = hull.map(function (point) {\n          return [point.x, point.y];\n        });\n        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;\n      } // 不强制要求所有nonMembers都没有包含在内\n      // for (const item of nonMembers) {\n      //   if (isPointInPolygon({ x: item.getBBox().centerX, y: item.getBBox().centerY }, contour)) return false\n      // }\n\n\n      return true;\n    };\n\n    if (hull && isContourValid()) {\n      return hull;\n    } // update parameters for next iteraction\n\n\n    options.threshold *= 0.9;\n\n    if (iterations <= options.maxMarchingIterations * 0.5) {\n      options.memberInfluenceFactor *= 1.2;\n      options.edgeInfluenceFactor *= 1.2;\n    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      // after half the iterations, start increasing positive energy and lowering the threshold\n      options.nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n\n  return hull;\n};\n/**\n * unionboundingbox\n * @param members\n * @param edges\n */\n\nfunction getActiveRregion(members, edges, offset) {\n  var activeRegion = {\n    minX: Number.POSITIVE_INFINITY,\n    minY: Number.POSITIVE_INFINITY,\n    maxX: Number.NEGATIVE_INFINITY,\n    maxY: Number.NEGATIVE_INFINITY,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  };\n  var bboxes = [];\n  members.forEach(function (item) {\n    bboxes.push(item.getBBox());\n  });\n  edges.forEach(function (l) {\n    bboxes.push(l.getBBox());\n  });\n\n  for (var _i = 0, bboxes_1 = bboxes; _i < bboxes_1.length; _i++) {\n    var bbox = bboxes_1[_i];\n    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;\n    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;\n    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;\n    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;\n  }\n\n  activeRegion.width = activeRegion.maxX - activeRegion.minX;\n  activeRegion.height = activeRegion.maxY - activeRegion.minY;\n  activeRegion.x = activeRegion.minX;\n  activeRegion.y = activeRegion.minY;\n  return activeRegion;\n}\n\nfunction fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {\n  function pos2GridIx(x, offset) {\n    var gridIx = Math.floor((x - offset) / options.pixelGroupSize);\n    return gridIx < 0 ? 0 : gridIx;\n  }\n\n  function gridIx2Pos(x, offset) {\n    return x * options.pixelGroupSize + offset;\n  } // using inverse a for numerical stability\n\n\n  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);\n  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);\n\n  var getAffectedRegion = function getAffectedRegion(bbox, thresholdR) {\n    var startX = Math.min(pos2GridIx(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);\n    var startY = Math.min(pos2GridIx(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);\n    var endX = Math.min(pos2GridIx(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);\n    var endY = Math.min(pos2GridIx(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);\n    return [startX, startY, endX, endY];\n  };\n\n  var addItemInfluence = function addItemInfluence(item, influenceFactor) {\n    var bbox = item.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.nodeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // calculate item influence for each cell\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var distanceSq = pointRectSquareDist({\n          x: tempX,\n          y: tempY\n        }, {\n          x: bbox.minX,\n          y: bbox.minY,\n          width: bbox.width,\n          height: bbox.height\n        });\n\n        if (distanceSq < Math.pow(options.nodeR1, 2)) {\n          var dr = Math.sqrt(distanceSq) - options.nodeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * dr * dr;\n        }\n      }\n    }\n  };\n\n  var addEdgeInfluence = function addEdgeInfluence(line, influenceFactor) {\n    var bbox = line.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.edgeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // for every point in active part of potentialArea, calculate distance to nearest point on line and add influence\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea.cells[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var minDistanceSq = pointLineSquareDist({\n          x: tempX,\n          y: tempY\n        }, line); // only influence if less than r1\n\n        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {\n          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * mdr * mdr;\n        }\n      }\n    }\n  };\n\n  if (options.nodeInfluenceFactor) {\n    members.forEach(function (item) {\n      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);\n    });\n  }\n\n  if (options.edgeInfluenceFactor) {\n    edges.forEach(function (edge) {\n      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);\n    });\n  }\n\n  if (options.negativeNodeInfluenceFactor) {\n    nonMembers.forEach(function (item) {\n      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);\n    });\n  }\n}\n\nfunction rerouteLine(item, buffer, intersections, wrapNormal) {\n  var bbox = item.getBBox();\n  var topIntersect = intersections[0],\n      leftIntersect = intersections[1],\n      bottomIntersect = intersections[2],\n      rightIntersect = intersections[3];\n  var cornerPos = {\n    topLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.minY - buffer\n    },\n    topRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.minY - buffer\n    },\n    bottomLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.maxY + buffer\n    },\n    bottomRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.maxY + buffer\n    }\n  };\n  var totalArea = bbox.height * bbox.width;\n\n  function calcHalfArea(intersect1, intersect2) {\n    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);\n  } // 根据线和boundingbox相交的情况，确定control point的位置\n\n\n  if (leftIntersect) {\n    // 相交区域有三角形\n    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight; // 相交区域分成上下两个梯形，比较面积\n\n    var topArea = calcHalfArea(leftIntersect, rightIntersect);\n\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    }\n\n    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n\n  if (rightIntersect) {\n    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  } // 相交区域分成左右两个梯形\n\n\n  var leftArea = calcHalfArea(topIntersect, bottomIntersect);\n\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n  }\n\n  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n}"],"mappings":";;;;AAAA,SAASA,UAAT,EAAqBC,mBAArB,EAA0CC,mBAA1C,EAA+DC,eAA/D,EAAgFC,cAAhF,EAAgGC,eAAhG,EAAiHC,mBAAjH,EAAsIC,IAAtI,EAA4IC,gBAA5I,QAAoK,iBAApK;AACA,IAAIC,UAAU,GAAG;EACfC,oBAAoB,EAAE,GADP;EAEfC,qBAAqB,EAAE,GAFR;EAGfC,cAAc,EAAE,CAHD;EAIfC,MAAM,EAAE,EAJO;EAKfC,MAAM,EAAE,EALO;EAMfC,MAAM,EAAE,CANO;EAOfC,MAAM,EAAE,EAPO;EAQfC,WAAW,EAAE,CARE;EASfC,SAAS,EAAE,KATI;EAUfC,IAAI,EAAE,EAVS;EAWfC,mBAAmB,EAAE,CAXN;EAYfC,mBAAmB,EAAE,CAZN;EAafC,2BAA2B,EAAE,CAAC;AAbf,CAAjB;AAeA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,eAAT,CAAyBC,OAAzB,EAAkCC,aAAlC,EAAiDP,SAAjD,EAA4D;EAC1D,IAAIQ,OAAO,GAAG,KAAd;;EAEA,IAAIC,MAAM,GAAG,SAASA,MAAT,CAAgBC,CAAhB,EAAmBC,CAAnB,EAAsB;IACjC,OAAOJ,aAAa,CAACK,KAAd,CAAoBF,CAAC,GAAGC,CAAC,GAAGJ,aAAa,CAACM,KAA1C,CAAP;EACD,CAFD;;EAIA,IAAIC,QAAQ,GAAG,SAASA,QAAT,CAAkBJ,CAAlB,EAAqBC,CAArB,EAAwB;IACrC,IAAII,SAAS,GAAG,CAAhB;;IAEA,IAAIN,MAAM,CAACC,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAG,CAAZ,CAAN,IAAwBX,SAA5B,EAAuC;MACrCe,SAAS,IAAI,CAAb;IACD;;IAED,IAAIN,MAAM,CAACC,CAAD,EAAIC,CAAC,GAAG,CAAR,CAAN,GAAmBX,SAAvB,EAAkC;MAChCe,SAAS,IAAI,CAAb;IACD;;IAED,IAAIN,MAAM,CAACC,CAAC,GAAG,CAAL,EAAQC,CAAR,CAAN,GAAmBX,SAAvB,EAAkC;MAChCe,SAAS,IAAI,CAAb;IACD;;IAED,IAAIN,MAAM,CAACC,CAAD,EAAIC,CAAJ,CAAN,GAAeX,SAAnB,EAA8B;MAC5Be,SAAS,IAAI,CAAb;IACD;;IAED,OAAOA,SAAP;EACD,CApBD;;EAsBA,IAAIC,OAAO,GAAG,SAASA,OAAT,CAAiBC,IAAjB,EAAuBC,IAAvB,EAA6B;IACzC,IAAIR,CAAC,GAAGO,IAAR;IACA,IAAIN,CAAC,GAAGO,IAAR;IACA,IAAIC,KAAJ;IACA,IAAIC,KAAJ;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,aAAa,CAACM,KAAd,GAAsBN,aAAa,CAACe,MAAxD,EAAgED,CAAC,EAAjE,EAAqE;MACnEF,KAAK,GAAGT,CAAR;MACAU,KAAK,GAAGT,CAAR;;MAEA,IAAIL,OAAO,CAACiB,SAAR,CAAkB,UAAUC,IAAV,EAAgB;QACpC,OAAOA,IAAI,CAACd,CAAL,KAAWA,CAAX,IAAgBc,IAAI,CAACb,CAAL,KAAWA,CAAlC;MACD,CAFG,IAEC,CAAC,CAFN,EAES;QACP,IAAIL,OAAO,CAAC,CAAD,CAAP,CAAWI,CAAX,KAAiBA,CAAjB,IAAsBJ,OAAO,CAAC,CAAD,CAAP,CAAWK,CAAX,KAAiBA,CAA3C,EAA8C,CAAC;QAC9C,CADD,MACO;UACL,OAAO,IAAP;QACD;MACF,CAPD,MAOO;QACLL,OAAO,CAACmB,IAAR,CAAa;UACXf,CAAC,EAAEA,CADQ;UAEXC,CAAC,EAAEA;QAFQ,CAAb;MAID;;MAED,IAAIe,KAAK,GAAGZ,QAAQ,CAACJ,CAAD,EAAIC,CAAJ,CAApB,CAlBmE,CAkBvC;;MAE5B,QAAQe,KAAR;QACE,KAAK,CAAC,CAAN;UACEC,OAAO,CAACC,IAAR,CAAa,uBAAb;UACA,OAAO,IAAP;;QAEF,KAAK,CAAL;QACA,KAAK,CAAL;QACA,KAAK,CAAL;QACA,KAAK,CAAL;UACElB,CAAC,GADH,CACO;;UAEL;;QAEF,KAAK,EAAL;QACA,KAAK,EAAL;QACA,KAAK,CAAL;UACEA,CAAC,GADH,CACO;;UAEL;;QAEF,KAAK,CAAL;UACE;UACA,IAAIS,KAAK,KAAK,CAAd,EAAiB;YACf,IAAIC,KAAK,KAAK,CAAC,CAAf,EAAkB;cAChBV,CAAC,IAAI,CAAL;YACD,CAFD,MAEO;cACLA,CAAC,IAAI,CAAL;YACD;UACF;;UAED;;QAEF,KAAK,CAAL;QACA,KAAK,EAAL;QACA,KAAK,CAAL;UACEC,CAAC,GADH,CACO;;UAEL;;QAEF,KAAK,CAAL;UACE;UACA,IAAIQ,KAAK,KAAK,CAAd,EAAiB;YACf,IAAIC,KAAK,KAAK,CAAd,EAAiB;cACfT,CAAC,IAAI,CAAL;YACD,CAFD,MAEO;cACLA,CAAC,IAAI,CAAL;YACD;UACF;;UAED;;QAEF,KAAK,EAAL;QACA,KAAK,CAAL;QACA,KAAK,EAAL;UACEA,CAAC,GADH,CACO;;UAEL;;QAEF;UACEgB,OAAO,CAACC,IAAR,CAAa,mCAAmCC,MAAnC,CAA0CH,KAA1C,CAAb;UACA,OAAO,IAAP;MA5DJ;IA8DD;EACF,CAzFD;;EA2FA,KAAKI,KAAL,GAAa,YAAY;IACvB,KAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,aAAa,CAACM,KAAlB,IAA2B,CAACL,OAA5C,EAAqDE,CAAC,IAAI,CAA1D,EAA6D;MAC3D,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,aAAa,CAACe,MAAlB,IAA4B,CAACd,OAA7C,EAAsDG,CAAC,IAAI,CAA3D,EAA8D;QAC5D,IAAIF,MAAM,CAACC,CAAD,EAAIC,CAAJ,CAAN,GAAeX,SAAf,IAA4Bc,QAAQ,CAACJ,CAAD,EAAIC,CAAJ,CAAR,KAAmB,EAAnD,EAAuD;UACrDH,OAAO,GAAGQ,OAAO,CAACN,CAAD,EAAIC,CAAJ,CAAjB;QACD;MACF;IACF;;IAED,OAAOH,OAAP;EACD,CAVD;AAWD;AACD;AACA;AACA;AACA;;;AAGA,IAAIuB,aAAa,GAAG,SAASA,aAAT,CAAuBlB,KAAvB,EAA8BS,MAA9B,EAAsC5B,cAAtC,EAAsD;EACxE,IAAIsC,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAUrB,KAAK,GAAGnB,cAAlB,CAAjB;EACA,IAAIyC,WAAW,GAAGF,IAAI,CAACC,IAAL,CAAUZ,MAAM,GAAG5B,cAAnB,CAAlB;EACA,IAAI0C,SAAS,GAAG,IAAIC,YAAJ,CAAiBJ,IAAI,CAACK,GAAL,CAAS,CAAT,EAAYN,UAAU,GAAGG,WAAzB,CAAjB,EAAwDI,IAAxD,CAA6D,CAA7D,CAAhB;EACA,OAAO;IACL3B,KAAK,EAAEwB,SADF;IAELvB,KAAK,EAAEmB,UAFF;IAGLV,MAAM,EAAEa;EAHH,CAAP;AAKD,CATD;AAUA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAIK,gBAAgB,GAAG,SAASA,gBAAT,CAA0BhB,IAA1B,EAAgCiB,OAAhC,EAAyCC,UAAzC,EAAqD;EAC1E,IAAIC,gBAAgB,GAAG,IAAvB;EACA,IAAIC,OAAO,GAAGC,MAAM,CAACC,iBAArB;EACAL,OAAO,CAACM,OAAR,CAAgB,UAAUC,aAAV,EAAyB;IACvC,IAAIC,KAAK,GAAG;MACVvC,CAAC,EAAEc,IAAI,CAAC0B,QAAL,GAAgBxC,CADT;MAEVC,CAAC,EAAEa,IAAI,CAAC0B,QAAL,GAAgBvC;IAFT,CAAZ;IAIA,IAAIwC,cAAc,GAAG;MACnBzC,CAAC,EAAEsC,aAAa,CAACE,QAAd,GAAyBxC,CADT;MAEnBC,CAAC,EAAEqC,aAAa,CAACE,QAAd,GAAyBvC;IAFT,CAArB;IAIA,IAAIyC,IAAI,GAAGtE,UAAU,CAACmE,KAAD,EAAQE,cAAR,CAArB;IACA,IAAIE,UAAU,GAAG,IAAIhE,IAAJ,CAAS4D,KAAK,CAACvC,CAAf,EAAkBuC,KAAK,CAACtC,CAAxB,EAA2BwC,cAAc,CAACzC,CAA1C,EAA6CyC,cAAc,CAACxC,CAA5D,CAAjB;IACA,IAAI2C,eAAe,GAAGZ,UAAU,CAACa,MAAX,CAAkB,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;MAC9D,IAAIvE,cAAc,CAACuE,KAAD,EAAQJ,UAAR,CAAd,GAAoC,CAAxC,EAA2C;QACzC,OAAOG,KAAK,GAAG,CAAf;MACD;;MAED,OAAOA,KAAP;IACD,CANqB,EAMnB,CANmB,CAAtB;;IAQA,IAAIJ,IAAI,GAAGnB,IAAI,CAACyB,GAAL,CAASJ,eAAe,GAAG,CAA3B,EAA8B,CAA9B,CAAP,GAA0CV,OAA9C,EAAuD;MACrDD,gBAAgB,GAAGK,aAAnB;MACAJ,OAAO,GAAGQ,IAAI,GAAGnB,IAAI,CAACyB,GAAL,CAASJ,eAAe,GAAG,CAA3B,EAA8B,CAA9B,CAAjB;IACD;EACF,CAvBD;EAwBA,OAAOX,gBAAP;AACD,CA5BD;AA6BA;AACA;AACA;AACA;AACA;;;AAGA,IAAIgB,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,IAAjC,EAAuC;EAC5D,IAAIC,WAAW,GAAGjB,MAAM,CAACC,iBAAzB;EACA,IAAIiB,WAAW,GAAG,IAAlB;EACAH,KAAK,CAACb,OAAN,CAAc,UAAUvB,IAAV,EAAgB;IAC5B,IAAIwC,QAAQ,GAAG9E,cAAc,CAACsC,IAAD,EAAOqC,IAAP,CAA7B,CAD4B,CACe;;IAE3C,IAAIG,QAAQ,IAAI,CAAZ,IAAiBA,QAAQ,GAAGF,WAAhC,EAA6C;MAC3CC,WAAW,GAAGvC,IAAd;MACAsC,WAAW,GAAGE,QAAd;IACD;EACF,CAPD;EAQA,OAAOD,WAAP;AACD,CAZD;AAaA;AACA;AACA;;;AAGA,IAAIE,YAAY,GAAG,SAASA,YAAT,CAAsBZ,UAAtB,EAAkCX,UAAlC,EAA8ClD,oBAA9C,EAAoEO,WAApE,EAAiF;EAClG,IAAImE,YAAY,GAAG,EAAnB;EACA,IAAIC,YAAY,GAAG,EAAnB;EACAA,YAAY,CAAC1C,IAAb,CAAkB4B,UAAlB;EACA,IAAIe,eAAe,GAAG,IAAtB;EACA,IAAIC,UAAU,GAAG,CAAjB;;EAEA,IAAIC,WAAW,GAAG,SAASA,WAAT,CAAqBC,KAArB,EAA4BC,KAA5B,EAAmC;IACnD,IAAIC,IAAI,GAAG,KAAX;IACAD,KAAK,CAACzB,OAAN,CAAc,UAAUc,IAAV,EAAgB;MAC5B,IAAIY,IAAJ,EAAU;;MAEV,IAAItF,eAAe,CAACoF,KAAD,EAAQ;QACzB7D,CAAC,EAAEmD,IAAI,CAACa,EADiB;QAEzB/D,CAAC,EAAEkD,IAAI,CAACc;MAFiB,CAAR,CAAf,IAGExF,eAAe,CAACoF,KAAD,EAAQ;QAC3B7D,CAAC,EAAEmD,IAAI,CAACe,EADmB;QAE3BjE,CAAC,EAAEkD,IAAI,CAACgB;MAFmB,CAAR,CAHrB,EAMI;QACFJ,IAAI,GAAG,IAAP;MACD;IACF,CAZD;IAaA,OAAOA,IAAP;EACD,CAhBD;;EAkBA,IAAIK,mBAAmB,GAAG,SAASA,mBAAT,CAA6BP,KAA7B,EAAoCQ,WAApC,EAAiD;IACzE,KAAK,IAAIC,EAAE,GAAG,CAAT,EAAYC,aAAa,GAAGF,WAAjC,EAA8CC,EAAE,GAAGC,aAAa,CAACC,MAAjE,EAAyEF,EAAE,EAA3E,EAA+E;MAC7E,IAAIxD,IAAI,GAAGyD,aAAa,CAACD,EAAD,CAAxB;MACA,IAAIG,IAAI,GAAG3D,IAAI,CAAC4D,OAAL,EAAX;MACA,IAAIC,WAAW,GAAG,CAAC,CAACF,IAAI,CAACzE,CAAN,EAASyE,IAAI,CAACxE,CAAd,CAAD,EAAmB,CAACwE,IAAI,CAACzE,CAAL,GAASyE,IAAI,CAACtE,KAAf,EAAsBsE,IAAI,CAACxE,CAA3B,CAAnB,EAAkD,CAACwE,IAAI,CAACzE,CAAN,EAASyE,IAAI,CAACxE,CAAL,GAASwE,IAAI,CAAC7D,MAAvB,CAAlD,EAAkF,CAAC6D,IAAI,CAACzE,CAAL,GAASyE,IAAI,CAACtE,KAAf,EAAsBsE,IAAI,CAACxE,CAAL,GAASwE,IAAI,CAAC7D,MAApC,CAAlF,CAAlB;;MAEA,IAAIhC,gBAAgB,CAAC+F,WAAD,EAAcd,KAAK,CAAC7D,CAApB,EAAuB6D,KAAK,CAAC5D,CAA7B,CAApB,EAAqD;QACnD,OAAO,IAAP;MACD;IACF;;IAED,OAAO,KAAP;EACD,CAZD,CAzBkG,CAqC/F;;;EAGH,OAAOyD,eAAe,IAAIC,UAAU,GAAG7E,oBAAvC,EAA6D;IAC3D4E,eAAe,GAAG,KAAlB;;IAEA,IAAIkB,OAAO,GAAG,SAASA,OAAT,GAAmB;MAC/B,IAAIzB,IAAI,GAAGM,YAAY,CAACoB,GAAb,EAAX;MACA,IAAIxB,WAAW,GAAGJ,gBAAgB,CAACjB,UAAD,EAAamB,IAAb,CAAlC;;MAEA,IAAIE,WAAJ,EAAiB;QACf,IAAIyB,EAAE,GAAGxG,mBAAmB,CAAC+E,WAAD,EAAcF,IAAd,CAA5B;QAAA,IACI4B,eAAe,GAAGD,EAAE,CAAC,CAAD,CADxB;QAAA,IAEIE,kBAAkB,GAAGF,EAAE,CAAC,CAAD,CAF3B,CADe,CAGiB;;;QAGhC,IAAIE,kBAAkB,KAAK,CAA3B,EAA8B;UAC5B,IAAIC,WAAW,GAAG,SAASA,WAAT,CAAqBC,OAArB,EAA8B;YAC9C,IAAIC,eAAe,GAAG9F,WAAtB;YACA,IAAI+F,WAAW,GAAGC,WAAW,CAAChC,WAAD,EAAc8B,eAAd,EAA+BJ,eAA/B,EAAgDG,OAAhD,CAA7B,CAF8C,CAEyC;;YAEvF,IAAII,KAAK,GAAG1B,WAAW,CAACwB,WAAD,EAAc3B,YAAd,CAAX,IAA0CG,WAAW,CAACwB,WAAD,EAAc5B,YAAd,CAAjE;YACA,IAAI+B,WAAW,GAAGnB,mBAAmB,CAACgB,WAAD,EAAcpD,UAAd,CAArC;;YAEA,OAAO,CAACsD,KAAD,IAAUC,WAAV,IAAyBJ,eAAe,IAAI,CAAnD,EAAsD;cACpD;cACAA,eAAe,IAAI,GAAnB;cACAC,WAAW,GAAGC,WAAW,CAAChC,WAAD,EAAc8B,eAAd,EAA+BJ,eAA/B,EAAgDG,OAAhD,CAAzB;cACAI,KAAK,GAAG1B,WAAW,CAACwB,WAAD,EAAc3B,YAAd,CAAX,IAA0CG,WAAW,CAACwB,WAAD,EAAc5B,YAAd,CAA7D;cACA+B,WAAW,GAAGnB,mBAAmB,CAACgB,WAAD,EAAcpD,UAAd,CAAjC;YACD,CAb6C,CAa5C;;;YAGF,IAAIoD,WAAW,IAAI,CAACE,KAAhB,KAA0B,CAACJ,OAAD,IAAY,CAACK,WAAvC,CAAJ,EAAyD;cACvD;cACA9B,YAAY,CAAC1C,IAAb,CAAkB,IAAIpC,IAAJ,CAASwE,IAAI,CAACa,EAAd,EAAkBb,IAAI,CAACc,EAAvB,EAA2BmB,WAAW,CAACpF,CAAvC,EAA0CoF,WAAW,CAACnF,CAAtD,CAAlB;cACAwD,YAAY,CAAC1C,IAAb,CAAkB,IAAIpC,IAAJ,CAASyG,WAAW,CAACpF,CAArB,EAAwBoF,WAAW,CAACnF,CAApC,EAAuCkD,IAAI,CAACe,EAA5C,EAAgDf,IAAI,CAACgB,EAArD,CAAlB;cACAT,eAAe,GAAG,IAAlB;YACD;UACF,CAtBD;;UAwBAuB,WAAW,CAAC,IAAD,CAAX;;UAEA,IAAI,CAACvB,eAAL,EAAsB;YACpB;YACAuB,WAAW,CAAC,KAAD,CAAX;UACD;QACF;MACF,CA1C8B,CA0C7B;;;MAGF,IAAI,CAACvB,eAAL,EAAsB;QACpBF,YAAY,CAACzC,IAAb,CAAkBoC,IAAlB;MACD;;MAEDQ,UAAU,IAAI,CAAd;IACD,CAlDD,CAH2D,CAqDxD;;;IAGH,OAAO,CAACD,eAAD,IAAoBD,YAAY,CAACe,MAAxC,EAAgD;MAC9CI,OAAO;IACR;EACF,CAnGiG,CAmGhG;;;EAGF,OAAOnB,YAAY,CAACe,MAApB,EAA4B;IAC1BhB,YAAY,CAACzC,IAAb,CAAkB0C,YAAY,CAACoB,GAAb,EAAlB;EACD;;EAED,OAAOrB,YAAP;AACD,CA3GD;AA4GA;AACA;AACA;;;AAGA,SAASgC,QAAT,CAAkB1E,IAAlB,EAAwBkB,UAAxB,EAAoCD,OAApC,EAA6CjD,oBAA7C,EAAmEO,WAAnE,EAAgF;EAC9E,IAAIoG,eAAe,GAAG3D,gBAAgB,CAAChB,IAAD,EAAOiB,OAAP,EAAgBC,UAAhB,CAAtC;;EAEA,IAAIyD,eAAe,KAAK,IAAxB,EAA8B;IAC5B,OAAO,EAAP;EACD,CAL6E,CAK5E;;;EAGF,IAAIC,UAAU,GAAG,SAASA,UAAT,CAAoBlC,YAApB,EAAkC;IACjD,IAAImC,UAAU,GAAG,EAAjB;;IAEA,OAAOnC,YAAY,CAACgB,MAAb,GAAsB,CAA7B,EAAgC;MAC9B,IAAIoB,KAAK,GAAGpC,YAAY,CAACqB,GAAb,EAAZ;;MAEA,IAAIrB,YAAY,CAACgB,MAAb,KAAwB,CAA5B,EAA+B;QAC7BmB,UAAU,CAAC5E,IAAX,CAAgB6E,KAAhB;QACA;MACD;;MAED,IAAIC,KAAK,GAAGrC,YAAY,CAACqB,GAAb,EAAZ;MACA,IAAIiB,SAAS,GAAG,IAAInH,IAAJ,CAASiH,KAAK,CAAC5B,EAAf,EAAmB4B,KAAK,CAAC3B,EAAzB,EAA6B4B,KAAK,CAAC3B,EAAnC,EAAuC2B,KAAK,CAAC1B,EAA7C,CAAhB;MACA,IAAId,WAAW,GAAGJ,gBAAgB,CAACjB,UAAD,EAAa8D,SAAb,CAAlC,CAV8B,CAU6B;;MAE3D,IAAI,CAACzC,WAAL,EAAkB;QAChBG,YAAY,CAACzC,IAAb,CAAkB+E,SAAlB;MACD,CAFD,MAEO;QACLH,UAAU,CAAC5E,IAAX,CAAgB6E,KAAhB;QACApC,YAAY,CAACzC,IAAb,CAAkB8E,KAAlB;MACD;IACF;;IAED,OAAOF,UAAP;EACD,CAxBD;;EA0BA,IAAIhD,UAAU,GAAG,IAAIhE,IAAJ,CAASmC,IAAI,CAAC0B,QAAL,GAAgBxC,CAAzB,EAA4Bc,IAAI,CAAC0B,QAAL,GAAgBvC,CAA5C,EAA+CwF,eAAe,CAACjD,QAAhB,GAA2BxC,CAA1E,EAA6EyF,eAAe,CAACjD,QAAhB,GAA2BvC,CAAxG,CAAjB;EACA,IAAIuD,YAAY,GAAGD,YAAY,CAACZ,UAAD,EAAaX,UAAb,EAAyBlD,oBAAzB,EAA+CO,WAA/C,CAA/B;EACA,IAAIsG,UAAU,GAAGD,UAAU,CAAClC,YAAD,CAA3B;EACA,OAAOmC,UAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,IAAII,YAAY,GAAG,SAASA,YAAT,CAAsBC,OAAtB,EAA+BhE,UAA/B,EAA2CiE,GAA3C,EAAgD;EACxE;EACA,IAAIC,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAcvH,UAAd,EAA0BoH,GAA1B,CAAd;EACA,IAAII,QAAQ,GAAG9H,eAAe,CAACyH,OAAO,CAACM,GAAR,CAAY,UAAUxF,IAAV,EAAgB;IACzD,OAAO;MACLd,CAAC,EAAEc,IAAI,CAAC0B,QAAL,GAAgBxC,CADd;MAELC,CAAC,EAAEa,IAAI,CAAC0B,QAAL,GAAgBvC;IAFd,CAAP;EAID,CAL8B,CAAD,CAA9B,CAHwE,CAQnE;;EAEL+F,OAAO,GAAGA,OAAO,CAACO,IAAR,CAAa,UAAUC,CAAV,EAAaC,CAAb,EAAgB;IACrC,OAAOrI,UAAU,CAAC;MAChB4B,CAAC,EAAEwG,CAAC,CAAChE,QAAF,GAAaxC,CADA;MAEhBC,CAAC,EAAEuG,CAAC,CAAChE,QAAF,GAAavC;IAFA,CAAD,EAGdoG,QAHc,CAAV,GAGQjI,UAAU,CAAC;MACxB4B,CAAC,EAAEyG,CAAC,CAACjE,QAAF,GAAaxC,CADQ;MAExBC,CAAC,EAAEwG,CAAC,CAACjE,QAAF,GAAavC;IAFQ,CAAD,EAGtBoG,QAHsB,CAHzB;EAOD,CARS,CAAV;EASA,IAAItE,OAAO,GAAG,EAAd;EACA,IAAI2E,YAAY,GAAG,EAAnB;EACAV,OAAO,CAAC3D,OAAR,CAAgB,UAAUvB,IAAV,EAAgB;IAC9B,IAAIgD,KAAK,GAAG0B,QAAQ,CAAC1E,IAAD,EAAOkB,UAAP,EAAmBD,OAAnB,EAA4BmE,OAAO,CAACpH,oBAApC,EAA0DoH,OAAO,CAAC7G,WAAlE,CAApB;IACAyE,KAAK,CAACzB,OAAN,CAAc,UAAUsE,CAAV,EAAa;MACzBD,YAAY,CAAC3F,IAAb,CAAkB4F,CAAlB;IACD,CAFD;IAGA5E,OAAO,CAAChB,IAAR,CAAaD,IAAb;EACD,CAND,EArBwE,CA2BpE;EACJ;EACA;EACA;;EAEA,IAAI8F,YAAY,GAAGC,gBAAgB,CAACb,OAAD,EAAUU,YAAV,EAAwBR,OAAO,CAAC/G,MAAhC,CAAnC;EACA,IAAIU,aAAa,GAAGwB,aAAa,CAACuF,YAAY,CAACzG,KAAd,EAAqByG,YAAY,CAAChG,MAAlC,EAA0CsF,OAAO,CAAClH,cAAlD,CAAjC,CAjCwE,CAiC4B;;EAEpG,IAAIY,OAAO,GAAG,EAAd;EACA,IAAIkH,IAAI,GAAG,EAAX;;EAEA,KAAK,IAAInD,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGuC,OAAO,CAACnH,qBAA9C,EAAqE4E,UAAU,EAA/E,EAAmF;IACjFoD,iBAAiB,CAACf,OAAD,EAAUhE,UAAV,EAAsB0E,YAAtB,EAAoCE,YAApC,EAAkD/G,aAAlD,EAAiEqG,OAAjE,CAAjB;IACAtG,OAAO,GAAG,EAAV;IACAkH,IAAI,GAAG,EAAP;IACA,IAAI,CAAC,IAAInH,eAAJ,CAAoBC,OAApB,EAA6BC,aAA7B,EAA4CqG,OAAO,CAAC5G,SAApD,EAA+D8B,KAA/D,EAAL,EAA6E;IAC7E,IAAI4F,WAAW,GAAGpH,OAAO,CAAC0G,GAAR,CAAY,UAAUzC,KAAV,EAAiB;MAC7C,OAAO;QACL7D,CAAC,EAAEuB,IAAI,CAAC0F,KAAL,CAAWpD,KAAK,CAAC7D,CAAN,GAAUkG,OAAO,CAAClH,cAAlB,GAAmC4H,YAAY,CAACM,IAA3D,CADE;QAELjH,CAAC,EAAEsB,IAAI,CAAC0F,KAAL,CAAWpD,KAAK,CAAC5D,CAAN,GAAUiG,OAAO,CAAClH,cAAlB,GAAmC4H,YAAY,CAACO,IAA3D;MAFE,CAAP;IAID,CALiB,CAAlB,CALiF,CAU7E;;IAEJ,IAAIH,WAAJ,EAAiB;MACf,IAAII,IAAI,GAAGJ,WAAW,CAACxC,MAAvB;;MAEA,IAAI0B,OAAO,CAAC3G,IAAR,GAAe,CAAnB,EAAsB;QACpB6H,IAAI,GAAG7F,IAAI,CAAC8F,KAAL,CAAWL,WAAW,CAACxC,MAAZ,GAAqB0B,OAAO,CAAC3G,IAAxC,CAAP,CADoB,CACkC;;QAEtD,OAAO6H,IAAI,GAAG,CAAP,IAAYlB,OAAO,CAAC3G,IAAR,GAAe,CAAlC,EAAqC;UACnC2G,OAAO,CAAC3G,IAAR,IAAgB,CAAhB;UACA6H,IAAI,GAAG7F,IAAI,CAAC8F,KAAL,CAAWL,WAAW,CAACxC,MAAZ,GAAqB0B,OAAO,CAAC3G,IAAxC,CAAP;QACD;MACF,CAVc,CAUb;;;MAGF,KAAK,IAAIoB,CAAC,GAAG,CAAR,EAAW2G,CAAC,GAAG,CAApB,EAAuBA,CAAC,GAAGF,IAA3B,EAAiCE,CAAC,IAAI,CAAL,EAAQ3G,CAAC,IAAIuF,OAAO,CAAC3G,IAAtD,EAA4D;QAC1DuH,IAAI,CAAC/F,IAAL,CAAU;UACRf,CAAC,EAAEgH,WAAW,CAACrG,CAAD,CAAX,CAAeX,CADV;UAERC,CAAC,EAAE+G,WAAW,CAACrG,CAAD,CAAX,CAAeV;QAFV,CAAV;MAID;IACF;;IAED,IAAIsH,cAAc,GAAG,SAASA,cAAT,GAA0B;MAC7C,KAAK,IAAIjD,EAAE,GAAG,CAAT,EAAYkD,SAAS,GAAGxB,OAA7B,EAAsC1B,EAAE,GAAGkD,SAAS,CAAChD,MAArD,EAA6DF,EAAE,EAA/D,EAAmE;QACjE,IAAIxD,IAAI,GAAG0G,SAAS,CAAClD,EAAD,CAApB;QACA,IAAImD,UAAU,GAAGX,IAAI,CAACR,GAAL,CAAS,UAAUzC,KAAV,EAAiB;UACzC,OAAO,CAACA,KAAK,CAAC7D,CAAP,EAAU6D,KAAK,CAAC5D,CAAhB,CAAP;QACD,CAFgB,CAAjB;QAGA,IAAI,CAACrB,gBAAgB,CAAC6I,UAAD,EAAa3G,IAAI,CAAC4D,OAAL,GAAegD,OAA5B,EAAqC5G,IAAI,CAAC4D,OAAL,GAAeiD,OAApD,CAArB,EAAmF,OAAO,KAAP;MACpF,CAP4C,CAO3C;MACF;MACA;MACA;;;MAGA,OAAO,IAAP;IACD,CAdD;;IAgBA,IAAIb,IAAI,IAAIS,cAAc,EAA1B,EAA8B;MAC5B,OAAOT,IAAP;IACD,CAnDgF,CAmD/E;;;IAGFZ,OAAO,CAAC5G,SAAR,IAAqB,GAArB;;IAEA,IAAIqE,UAAU,IAAIuC,OAAO,CAACnH,qBAAR,GAAgC,GAAlD,EAAuD;MACrDmH,OAAO,CAAC0B,qBAAR,IAAiC,GAAjC;MACA1B,OAAO,CAACzG,mBAAR,IAA+B,GAA/B;IACD,CAHD,MAGO,IAAIyG,OAAO,CAAC2B,wBAAR,KAAqC,CAArC,IAA0C7F,UAAU,CAACwC,MAAX,GAAoB,CAAlE,EAAqE;MAC1E;MACA0B,OAAO,CAAC2B,wBAAR,IAAoC,GAApC;IACD,CAHM,MAGA;MACL;IACD;EACF;;EAED,OAAOf,IAAP;AACD,CA1GM;AA2GP;AACA;AACA;AACA;AACA;;AAEA,SAASD,gBAAT,CAA0Bb,OAA1B,EAAmC8B,KAAnC,EAA0CC,MAA1C,EAAkD;EAChD,IAAInB,YAAY,GAAG;IACjBM,IAAI,EAAE/E,MAAM,CAACC,iBADI;IAEjB+E,IAAI,EAAEhF,MAAM,CAACC,iBAFI;IAGjB4F,IAAI,EAAE7F,MAAM,CAAC8F,iBAHI;IAIjBC,IAAI,EAAE/F,MAAM,CAAC8F,iBAJI;IAKjB9H,KAAK,EAAE,CALU;IAMjBS,MAAM,EAAE,CANS;IAOjBZ,CAAC,EAAE,CAPc;IAQjBC,CAAC,EAAE;EARc,CAAnB;EAUA,IAAIkI,MAAM,GAAG,EAAb;EACAnC,OAAO,CAAC3D,OAAR,CAAgB,UAAUvB,IAAV,EAAgB;IAC9BqH,MAAM,CAACpH,IAAP,CAAYD,IAAI,CAAC4D,OAAL,EAAZ;EACD,CAFD;EAGAoD,KAAK,CAACzF,OAAN,CAAc,UAAUsE,CAAV,EAAa;IACzBwB,MAAM,CAACpH,IAAP,CAAY4F,CAAC,CAACjC,OAAF,EAAZ;EACD,CAFD;;EAIA,KAAK,IAAIJ,EAAE,GAAG,CAAT,EAAY8D,QAAQ,GAAGD,MAA5B,EAAoC7D,EAAE,GAAG8D,QAAQ,CAAC5D,MAAlD,EAA0DF,EAAE,EAA5D,EAAgE;IAC9D,IAAIG,IAAI,GAAG2D,QAAQ,CAAC9D,EAAD,CAAnB;IACAsC,YAAY,CAACM,IAAb,GAAoB,CAACzC,IAAI,CAACyC,IAAL,GAAYN,YAAY,CAACM,IAAzB,GAAgCzC,IAAI,CAACyC,IAArC,GAA4CN,YAAY,CAACM,IAA1D,IAAkEa,MAAtF;IACAnB,YAAY,CAACO,IAAb,GAAoB,CAAC1C,IAAI,CAAC0C,IAAL,GAAYP,YAAY,CAACO,IAAzB,GAAgC1C,IAAI,CAAC0C,IAArC,GAA4CP,YAAY,CAACO,IAA1D,IAAkEY,MAAtF;IACAnB,YAAY,CAACoB,IAAb,GAAoB,CAACvD,IAAI,CAACuD,IAAL,GAAYpB,YAAY,CAACoB,IAAzB,GAAgCvD,IAAI,CAACuD,IAArC,GAA4CpB,YAAY,CAACoB,IAA1D,IAAkED,MAAtF;IACAnB,YAAY,CAACsB,IAAb,GAAoB,CAACzD,IAAI,CAACyD,IAAL,GAAYtB,YAAY,CAACsB,IAAzB,GAAgCzD,IAAI,CAACyD,IAArC,GAA4CtB,YAAY,CAACsB,IAA1D,IAAkEH,MAAtF;EACD;;EAEDnB,YAAY,CAACzG,KAAb,GAAqByG,YAAY,CAACoB,IAAb,GAAoBpB,YAAY,CAACM,IAAtD;EACAN,YAAY,CAAChG,MAAb,GAAsBgG,YAAY,CAACsB,IAAb,GAAoBtB,YAAY,CAACO,IAAvD;EACAP,YAAY,CAAC5G,CAAb,GAAiB4G,YAAY,CAACM,IAA9B;EACAN,YAAY,CAAC3G,CAAb,GAAiB2G,YAAY,CAACO,IAA9B;EACA,OAAOP,YAAP;AACD;;AAED,SAASG,iBAAT,CAA2Bf,OAA3B,EAAoChE,UAApC,EAAgD8F,KAAhD,EAAuDlB,YAAvD,EAAqE/G,aAArE,EAAoFqG,OAApF,EAA6F;EAC3F,SAASmC,UAAT,CAAoBrI,CAApB,EAAuB+H,MAAvB,EAA+B;IAC7B,IAAIO,MAAM,GAAG/G,IAAI,CAAC8F,KAAL,CAAW,CAACrH,CAAC,GAAG+H,MAAL,IAAe7B,OAAO,CAAClH,cAAlC,CAAb;IACA,OAAOsJ,MAAM,GAAG,CAAT,GAAa,CAAb,GAAiBA,MAAxB;EACD;;EAED,SAASC,UAAT,CAAoBvI,CAApB,EAAuB+H,MAAvB,EAA+B;IAC7B,OAAO/H,CAAC,GAAGkG,OAAO,CAAClH,cAAZ,GAA6B+I,MAApC;EACD,CAR0F,CAQzF;;;EAGF,IAAIS,QAAQ,GAAG,CAACtC,OAAO,CAAC/G,MAAR,GAAiB+G,OAAO,CAAC9G,MAA1B,KAAqC8G,OAAO,CAAC/G,MAAR,GAAiB+G,OAAO,CAAC9G,MAA9D,CAAf;EACA,IAAIqJ,QAAQ,GAAG,CAACvC,OAAO,CAACjH,MAAR,GAAiBiH,OAAO,CAAChH,MAA1B,KAAqCgH,OAAO,CAACjH,MAAR,GAAiBiH,OAAO,CAAChH,MAA9D,CAAf;;EAEA,IAAIwJ,iBAAiB,GAAG,SAASA,iBAAT,CAA2BjE,IAA3B,EAAiCkE,UAAjC,EAA6C;IACnE,IAAIC,MAAM,GAAGrH,IAAI,CAACsH,GAAL,CAASR,UAAU,CAAC5D,IAAI,CAACyC,IAAN,EAAYyB,UAAU,GAAG/B,YAAY,CAACM,IAAtC,CAAnB,EAAgErH,aAAa,CAACM,KAA9E,CAAb;IACA,IAAI2I,MAAM,GAAGvH,IAAI,CAACsH,GAAL,CAASR,UAAU,CAAC5D,IAAI,CAAC0C,IAAN,EAAYwB,UAAU,GAAG/B,YAAY,CAACO,IAAtC,CAAnB,EAAgEtH,aAAa,CAACe,MAA9E,CAAb;IACA,IAAImI,IAAI,GAAGxH,IAAI,CAACsH,GAAL,CAASR,UAAU,CAAC5D,IAAI,CAACuD,IAAN,EAAY,CAACW,UAAD,GAAc/B,YAAY,CAACM,IAAvC,CAAnB,EAAiErH,aAAa,CAACM,KAA/E,CAAX;IACA,IAAI6I,IAAI,GAAGzH,IAAI,CAACsH,GAAL,CAASR,UAAU,CAAC5D,IAAI,CAACyD,IAAN,EAAY,CAACS,UAAD,GAAc/B,YAAY,CAACO,IAAvC,CAAnB,EAAiEtH,aAAa,CAACe,MAA/E,CAAX;IACA,OAAO,CAACgI,MAAD,EAASE,MAAT,EAAiBC,IAAjB,EAAuBC,IAAvB,CAAP;EACD,CAND;;EAQA,IAAIC,gBAAgB,GAAG,SAASA,gBAAT,CAA0BnI,IAA1B,EAAgCoI,eAAhC,EAAiD;IACtE,IAAIzE,IAAI,GAAG3D,IAAI,CAAC4D,OAAL,EAAX;;IAEA,IAAII,EAAE,GAAG4D,iBAAiB,CAACjE,IAAD,EAAOyB,OAAO,CAAC9G,MAAf,CAA1B;IAAA,IACIwJ,MAAM,GAAG9D,EAAE,CAAC,CAAD,CADf;IAAA,IAEIgE,MAAM,GAAGhE,EAAE,CAAC,CAAD,CAFf;IAAA,IAGIiE,IAAI,GAAGjE,EAAE,CAAC,CAAD,CAHb;IAAA,IAIIkE,IAAI,GAAGlE,EAAE,CAAC,CAAD,CAJb,CAHsE,CAOpD;;;IAGlB,KAAK,IAAI7E,CAAC,GAAG6I,MAAb,EAAqB7I,CAAC,GAAG+I,IAAzB,EAA+B/I,CAAC,IAAI,CAApC,EAAuC;MACrC,KAAK,IAAID,CAAC,GAAG4I,MAAb,EAAqB5I,CAAC,GAAG+I,IAAzB,EAA+B/I,CAAC,IAAI,CAApC,EAAuC;QACrC,IAAIkJ,eAAe,GAAG,CAAlB,IAAuBrJ,aAAa,CAACG,CAAC,GAAGC,CAAC,GAAGJ,aAAa,CAACM,KAAvB,CAAb,IAA8C,CAAzE,EAA4E;UAC1E;QACD;;QAED,IAAIgJ,KAAK,GAAGZ,UAAU,CAACvI,CAAD,EAAI4G,YAAY,CAACM,IAAjB,CAAtB;QACA,IAAIkC,KAAK,GAAGb,UAAU,CAACtI,CAAD,EAAI2G,YAAY,CAACO,IAAjB,CAAtB;QACA,IAAIkC,UAAU,GAAG3K,mBAAmB,CAAC;UACnCsB,CAAC,EAAEmJ,KADgC;UAEnClJ,CAAC,EAAEmJ;QAFgC,CAAD,EAGjC;UACDpJ,CAAC,EAAEyE,IAAI,CAACyC,IADP;UAEDjH,CAAC,EAAEwE,IAAI,CAAC0C,IAFP;UAGDhH,KAAK,EAAEsE,IAAI,CAACtE,KAHX;UAIDS,MAAM,EAAE6D,IAAI,CAAC7D;QAJZ,CAHiC,CAApC;;QAUA,IAAIyI,UAAU,GAAG9H,IAAI,CAACyB,GAAL,CAASkD,OAAO,CAAC9G,MAAjB,EAAyB,CAAzB,CAAjB,EAA8C;UAC5C,IAAIkK,EAAE,GAAG/H,IAAI,CAACgI,IAAL,CAAUF,UAAV,IAAwBnD,OAAO,CAAC9G,MAAzC;UACAS,aAAa,CAACK,KAAd,CAAoBF,CAAC,GAAGC,CAAC,GAAGJ,aAAa,CAACM,KAA1C,KAAoD+I,eAAe,GAAGI,EAAlB,GAAuBA,EAA3E;QACD;MACF;IACF;EACF,CAlCD;;EAoCA,IAAIE,gBAAgB,GAAG,SAASA,gBAAT,CAA0BrG,IAA1B,EAAgC+F,eAAhC,EAAiD;IACtE,IAAIzE,IAAI,GAAGtB,IAAI,CAACuB,OAAL,EAAX;;IAEA,IAAII,EAAE,GAAG4D,iBAAiB,CAACjE,IAAD,EAAOyB,OAAO,CAAChH,MAAf,CAA1B;IAAA,IACI0J,MAAM,GAAG9D,EAAE,CAAC,CAAD,CADf;IAAA,IAEIgE,MAAM,GAAGhE,EAAE,CAAC,CAAD,CAFf;IAAA,IAGIiE,IAAI,GAAGjE,EAAE,CAAC,CAAD,CAHb;IAAA,IAIIkE,IAAI,GAAGlE,EAAE,CAAC,CAAD,CAJb,CAHsE,CAOpD;;;IAGlB,KAAK,IAAI7E,CAAC,GAAG6I,MAAb,EAAqB7I,CAAC,GAAG+I,IAAzB,EAA+B/I,CAAC,IAAI,CAApC,EAAuC;MACrC,KAAK,IAAID,CAAC,GAAG4I,MAAb,EAAqB5I,CAAC,GAAG+I,IAAzB,EAA+B/I,CAAC,IAAI,CAApC,EAAuC;QACrC,IAAIkJ,eAAe,GAAG,CAAlB,IAAuBrJ,aAAa,CAACK,KAAd,CAAoBF,CAAC,GAAGC,CAAC,GAAGJ,aAAa,CAACM,KAA1C,KAAoD,CAA/E,EAAkF;UAChF;QACD;;QAED,IAAIgJ,KAAK,GAAGZ,UAAU,CAACvI,CAAD,EAAI4G,YAAY,CAACM,IAAjB,CAAtB;QACA,IAAIkC,KAAK,GAAGb,UAAU,CAACtI,CAAD,EAAI2G,YAAY,CAACO,IAAjB,CAAtB;QACA,IAAIsC,aAAa,GAAGpL,mBAAmB,CAAC;UACtC2B,CAAC,EAAEmJ,KADmC;UAEtClJ,CAAC,EAAEmJ;QAFmC,CAAD,EAGpCjG,IAHoC,CAAvC,CAPqC,CAU3B;;QAEV,IAAIsG,aAAa,GAAGlI,IAAI,CAACyB,GAAL,CAASkD,OAAO,CAAChH,MAAjB,EAAyB,CAAzB,CAApB,EAAiD;UAC/C,IAAIwK,GAAG,GAAGnI,IAAI,CAACgI,IAAL,CAAUE,aAAV,IAA2BvD,OAAO,CAAChH,MAA7C;UACAW,aAAa,CAACK,KAAd,CAAoBF,CAAC,GAAGC,CAAC,GAAGJ,aAAa,CAACM,KAA1C,KAAoD+I,eAAe,GAAGQ,GAAlB,GAAwBA,GAA5E;QACD;MACF;IACF;EACF,CA7BD;;EA+BA,IAAIxD,OAAO,CAAC1G,mBAAZ,EAAiC;IAC/BwG,OAAO,CAAC3D,OAAR,CAAgB,UAAUvB,IAAV,EAAgB;MAC9BmI,gBAAgB,CAACnI,IAAD,EAAOoF,OAAO,CAAC1G,mBAAR,GAA8BgJ,QAArC,CAAhB;IACD,CAFD;EAGD;;EAED,IAAItC,OAAO,CAACzG,mBAAZ,EAAiC;IAC/BqI,KAAK,CAACzF,OAAN,CAAc,UAAUsH,IAAV,EAAgB;MAC5BH,gBAAgB,CAACG,IAAD,EAAOzD,OAAO,CAACzG,mBAAR,GAA8BgJ,QAArC,CAAhB;IACD,CAFD;EAGD;;EAED,IAAIvC,OAAO,CAACxG,2BAAZ,EAAyC;IACvCsC,UAAU,CAACK,OAAX,CAAmB,UAAUvB,IAAV,EAAgB;MACjCmI,gBAAgB,CAACnI,IAAD,EAAOoF,OAAO,CAACxG,2BAAR,GAAsC8I,QAA7C,CAAhB;IACD,CAFD;EAGD;AACF;;AAED,SAASnD,WAAT,CAAqBvE,IAArB,EAA2B8I,MAA3B,EAAmCC,aAAnC,EAAkDC,UAAlD,EAA8D;EAC5D,IAAIrF,IAAI,GAAG3D,IAAI,CAAC4D,OAAL,EAAX;EACA,IAAIqF,YAAY,GAAGF,aAAa,CAAC,CAAD,CAAhC;EAAA,IACIG,aAAa,GAAGH,aAAa,CAAC,CAAD,CADjC;EAAA,IAEII,eAAe,GAAGJ,aAAa,CAAC,CAAD,CAFnC;EAAA,IAGIK,cAAc,GAAGL,aAAa,CAAC,CAAD,CAHlC;EAIA,IAAIM,SAAS,GAAG;IACdC,OAAO,EAAE;MACPpK,CAAC,EAAEyE,IAAI,CAACyC,IAAL,GAAY0C,MADR;MAEP3J,CAAC,EAAEwE,IAAI,CAAC0C,IAAL,GAAYyC;IAFR,CADK;IAKdS,QAAQ,EAAE;MACRrK,CAAC,EAAEyE,IAAI,CAACuD,IAAL,GAAY4B,MADP;MAER3J,CAAC,EAAEwE,IAAI,CAAC0C,IAAL,GAAYyC;IAFP,CALI;IASdU,UAAU,EAAE;MACVtK,CAAC,EAAEyE,IAAI,CAACyC,IAAL,GAAY0C,MADL;MAEV3J,CAAC,EAAEwE,IAAI,CAACyD,IAAL,GAAY0B;IAFL,CATE;IAadW,WAAW,EAAE;MACXvK,CAAC,EAAEyE,IAAI,CAACuD,IAAL,GAAY4B,MADJ;MAEX3J,CAAC,EAAEwE,IAAI,CAACyD,IAAL,GAAY0B;IAFJ;EAbC,CAAhB;EAkBA,IAAIY,SAAS,GAAG/F,IAAI,CAAC7D,MAAL,GAAc6D,IAAI,CAACtE,KAAnC;;EAEA,SAASsK,YAAT,CAAsBC,UAAtB,EAAkCC,UAAlC,EAA8C;IAC5C,OAAOlG,IAAI,CAACtE,KAAL,IAAc,CAACuK,UAAU,CAACzK,CAAX,GAAewE,IAAI,CAAC0C,IAApB,IAA4BwD,UAAU,CAAC1K,CAAX,GAAewE,IAAI,CAAC0C,IAAhD,CAAD,IAA0D,GAAxE,CAAP;EACD,CA5B2D,CA4B1D;;;EAGF,IAAI6C,aAAJ,EAAmB;IACjB;IACA,IAAID,YAAJ,EAAkB,OAAOD,UAAU,GAAGK,SAAS,CAACC,OAAb,GAAuBD,SAAS,CAACI,WAAlD;IAClB,IAAIN,eAAJ,EAAqB,OAAOH,UAAU,GAAGK,SAAS,CAACG,UAAb,GAA0BH,SAAS,CAACE,QAArD,CAHJ,CAGmE;;IAEpF,IAAIO,OAAO,GAAGH,YAAY,CAACT,aAAD,EAAgBE,cAAhB,CAA1B;;IAEA,IAAIU,OAAO,GAAGJ,SAAS,GAAG,GAA1B,EAA+B;MAC7B,IAAIR,aAAa,CAAC/J,CAAd,GAAkBiK,cAAc,CAACjK,CAArC,EAAwC,OAAO6J,UAAU,GAAGK,SAAS,CAACC,OAAb,GAAuBD,SAAS,CAACI,WAAlD;MACxC,OAAOT,UAAU,GAAGK,SAAS,CAACE,QAAb,GAAwBF,SAAS,CAACG,UAAnD;IACD;;IAED,IAAIN,aAAa,CAAC/J,CAAd,GAAkBiK,cAAc,CAACjK,CAArC,EAAwC,OAAO6J,UAAU,GAAGK,SAAS,CAACG,UAAb,GAA0BH,SAAS,CAACE,QAArD;IACxC,OAAOP,UAAU,GAAGK,SAAS,CAACI,WAAb,GAA2BJ,SAAS,CAACC,OAAtD;EACD;;EAED,IAAIF,cAAJ,EAAoB;IAClB,IAAIH,YAAJ,EAAkB,OAAOD,UAAU,GAAGK,SAAS,CAACE,QAAb,GAAwBF,SAAS,CAACG,UAAnD;IAClB,IAAIL,eAAJ,EAAqB,OAAOH,UAAU,GAAGK,SAAS,CAACI,WAAb,GAA2BJ,SAAS,CAACC,OAAtD;EACtB,CAlD2D,CAkD1D;;;EAGF,IAAIS,QAAQ,GAAGJ,YAAY,CAACV,YAAD,EAAeE,eAAf,CAA3B;;EAEA,IAAIY,QAAQ,GAAGL,SAAS,GAAG,GAA3B,EAAgC;IAC9B,IAAIT,YAAY,CAAC/J,CAAb,GAAiBiK,eAAe,CAACjK,CAArC,EAAwC,OAAO8J,UAAU,GAAGK,SAAS,CAACC,OAAb,GAAuBD,SAAS,CAACI,WAAlD;IACxC,OAAOT,UAAU,GAAGK,SAAS,CAACG,UAAb,GAA0BH,SAAS,CAACE,QAArD;EACD;;EAED,IAAIN,YAAY,CAAC/J,CAAb,GAAiBiK,eAAe,CAACjK,CAArC,EAAwC,OAAO8J,UAAU,GAAGK,SAAS,CAACE,QAAb,GAAwBF,SAAS,CAACG,UAAnD;EACxC,OAAOR,UAAU,GAAGK,SAAS,CAACI,WAAb,GAA2BJ,SAAS,CAACC,OAAtD;AACD"},"metadata":{},"sourceType":"module"}