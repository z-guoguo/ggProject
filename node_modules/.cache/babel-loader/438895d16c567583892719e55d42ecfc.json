{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _class2, _descriptor, _class3, _temp;\n\nimport { Frustum, IDENTIFIER } from '@antv/g-webgpu-core';\nimport { mat3, mat4, quat, vec3, vec4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { createVec3, getAngle } from '../utils/math';\nimport Landmark from './Landmark';\nexport var CAMERA_TYPE;\n\n(function (CAMERA_TYPE) {\n  CAMERA_TYPE[\"ORBITING\"] = \"ORBITING\";\n  CAMERA_TYPE[\"EXPLORING\"] = \"EXPLORING\";\n  CAMERA_TYPE[\"TRACKING\"] = \"TRACKING\";\n})(CAMERA_TYPE || (CAMERA_TYPE = {}));\n\nexport var CAMERA_TRACKING_MODE;\n\n(function (CAMERA_TRACKING_MODE) {\n  CAMERA_TRACKING_MODE[\"DEFAULT\"] = \"DEFAULT\";\n  CAMERA_TRACKING_MODE[\"ROTATIONAL\"] = \"ROTATIONAL\";\n  CAMERA_TRACKING_MODE[\"TRANSLATIONAL\"] = \"TRANSLATIONAL\";\n  CAMERA_TRACKING_MODE[\"CINEMATIC\"] = \"CINEMATIC\";\n})(CAMERA_TRACKING_MODE || (CAMERA_TRACKING_MODE = {}));\n\nexport var CAMERA_PROJECTION_MODE;\n\n(function (CAMERA_PROJECTION_MODE) {\n  CAMERA_PROJECTION_MODE[\"ORTHOGRAPHIC\"] = \"ORTHOGRAPHIC\";\n  CAMERA_PROJECTION_MODE[\"PERSPECTIVE\"] = \"PERSPECTIVE\";\n})(CAMERA_PROJECTION_MODE || (CAMERA_PROJECTION_MODE = {}));\n\nvar DEG_2_RAD = Math.PI / 180;\nvar RAD_2_DEG = 180 / Math.PI;\n/**\n * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计\n * 保存相机参数，定义相机动作：\n * 1. dolly 沿 n 轴移动\n * 2. pan 沿 u v 轴移动\n * 3. rotate 以方位角旋转\n * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互\n */\n\nexport var Camera = (_dec = injectable(), _dec2 = inject(IDENTIFIER.InteractorService), _dec(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function () {\n  function Camera() {\n    _classCallCheck(this, Camera);\n\n    this.matrix = mat4.create();\n    this.right = vec3.fromValues(1, 0, 0);\n    this.up = vec3.fromValues(0, 1, 0);\n    this.forward = vec3.fromValues(0, 0, 1);\n    this.position = vec3.fromValues(0, 0, 1);\n    this.focalPoint = vec3.fromValues(0, 0, 0);\n    this.distanceVector = vec3.fromValues(0, 0, 0);\n    this.distance = 1;\n    this.azimuth = 0;\n    this.elevation = 0;\n    this.roll = 0;\n    this.relAzimuth = 0;\n    this.relElevation = 0;\n    this.relRoll = 0;\n    this.dollyingStep = 0;\n    this.maxDistance = Infinity;\n    this.minDistance = -Infinity;\n    this.rotateWorld = false;\n\n    _initializerDefineProperty(this, \"interactor\", _descriptor, this);\n\n    this.fov = 30;\n    this.near = 0.1;\n    this.far = 10000;\n    this.aspect = 1;\n    this.left = void 0;\n    this.rright = void 0;\n    this.top = void 0;\n    this.bottom = void 0;\n    this.zoom = 1;\n    this.perspective = mat4.create();\n    this.view = void 0;\n    this.following = undefined;\n    this.type = CAMERA_TYPE.EXPLORING;\n    this.trackingMode = CAMERA_TRACKING_MODE.DEFAULT;\n    this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n    this.frustum = new Frustum();\n    this.landmarks = [];\n    this.landmarkAnimationID = void 0;\n  }\n\n  _createClass(Camera, [{\n    key: \"clone\",\n    value: function clone() {\n      var camera = new Camera();\n      camera.setType(this.type, undefined);\n      camera.interactor = this.interactor;\n      return camera;\n    }\n  }, {\n    key: \"getProjectionMode\",\n    value: function getProjectionMode() {\n      return this.projectionMode;\n    }\n  }, {\n    key: \"getPerspective\",\n    value: function getPerspective() {\n      return this.perspective;\n    }\n  }, {\n    key: \"getFrustum\",\n    value: function getFrustum() {\n      return this.frustum;\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      return this.position;\n    }\n  }, {\n    key: \"setType\",\n    value: function setType(type, trackingMode) {\n      this.type = type;\n\n      if (this.type === CAMERA_TYPE.EXPLORING) {\n        this.setWorldRotation(true);\n      } else {\n        this.setWorldRotation(false);\n      }\n\n      this._getAngles();\n\n      if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {\n        this.setTrackingMode(trackingMode);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setProjectionMode\",\n    value: function setProjectionMode(projectionMode) {\n      this.projectionMode = projectionMode;\n      return this;\n    }\n  }, {\n    key: \"setTrackingMode\",\n    value: function setTrackingMode(trackingMode) {\n      if (this.type !== CAMERA_TYPE.TRACKING) {\n        throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');\n      }\n\n      this.trackingMode = trackingMode;\n      return this;\n    }\n    /**\n     * If flag is true, it reverses the azimuth and elevation angles.\n     * Subsequent calls to rotate, setAzimuth, setElevation,\n     * changeAzimuth or changeElevation will cause the inverted effect.\n     * setRoll or changeRoll is not affected by this method.\n     *\n     * This inversion is useful when one wants to simulate that the world\n     * is moving, instead of the camera.\n     *\n     * By default the camera angles are not reversed.\n     * @param {Boolean} flag the boolean flag to reverse the angles.\n     */\n\n  }, {\n    key: \"setWorldRotation\",\n    value: function setWorldRotation(flag) {\n      this.rotateWorld = flag;\n\n      this._getAngles();\n    }\n    /**\n     * 计算 MV 矩阵，为相机矩阵的逆矩阵\n     */\n\n  }, {\n    key: \"getViewTransform\",\n    value: function getViewTransform() {\n      return mat4.invert(mat4.create(), this.matrix);\n    }\n  }, {\n    key: \"getWorldTransform\",\n    value: function getWorldTransform() {\n      return this.matrix;\n    }\n    /**\n     * 设置相机矩阵\n     */\n\n  }, {\n    key: \"setMatrix\",\n    value: function setMatrix(matrix) {\n      this.matrix = matrix;\n\n      this._update();\n\n      return this;\n    }\n  }, {\n    key: \"setAspect\",\n    value: function setAspect(aspect) {\n      this.setPerspective(this.near, this.far, this.fov, aspect);\n      return this;\n    }\n    /**\n     * Sets an offset in a larger frustum, used in PixelPicking\n     */\n\n  }, {\n    key: \"setViewOffset\",\n    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n      this.aspect = fullWidth / fullHeight;\n\n      if (this.view === undefined) {\n        this.view = {\n          enabled: true,\n          fullWidth: 1,\n          fullHeight: 1,\n          offsetX: 0,\n          offsetY: 0,\n          width: 1,\n          height: 1\n        };\n      }\n\n      this.view.enabled = true;\n      this.view.fullWidth = fullWidth;\n      this.view.fullHeight = fullHeight;\n      this.view.offsetX = x;\n      this.view.offsetY = y;\n      this.view.width = width;\n      this.view.height = height;\n\n      if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n        this.setPerspective(this.near, this.far, this.fov, this.aspect);\n      } else {\n        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clearViewOffset\",\n    value: function clearViewOffset() {\n      if (this.view !== undefined) {\n        this.view.enabled = false;\n      }\n\n      if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n        this.setPerspective(this.near, this.far, this.fov, this.aspect);\n      } else {\n        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setPerspective\",\n    value: function setPerspective(near, far, fov, aspect) {\n      this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n      this.fov = fov;\n      this.near = near;\n      this.far = far;\n      this.aspect = aspect;\n      mat4.perspective(this.perspective, this.fov * DEG_2_RAD, this.aspect, this.near, this.far);\n      return this;\n    }\n  }, {\n    key: \"setOrthographic\",\n    value: function setOrthographic(l, r, t, b, near, far) {\n      this.projectionMode = CAMERA_PROJECTION_MODE.ORTHOGRAPHIC;\n      this.rright = r;\n      this.left = l;\n      this.top = t;\n      this.bottom = b;\n      this.near = near;\n      this.far = far;\n      var dx = (this.rright - this.left) / (2 * this.zoom);\n      var dy = (this.top - this.bottom) / (2 * this.zoom);\n      var cx = (this.rright + this.left) / 2;\n      var cy = (this.top + this.bottom) / 2;\n      var left = cx - dx;\n      var right = cx + dx;\n      var top = cy + dy;\n      var bottom = cy - dy;\n\n      if (this.view !== undefined && this.view.enabled) {\n        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;\n        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n        left += scaleW * this.view.offsetX;\n        right = left + scaleW * this.view.width;\n        top -= scaleH * this.view.offsetY;\n        bottom = top - scaleH * this.view.height;\n      }\n\n      mat4.ortho(this.perspective, left, right, top, bottom, near, far);\n      return this;\n    }\n    /**\n     * 设置相机位置\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(x, y, z) {\n      this._setPosition(x, y, z);\n\n      this.setFocalPoint(this.focalPoint);\n      return this;\n    }\n    /**\n     * 设置视点位置\n     */\n\n  }, {\n    key: \"setFocalPoint\",\n    value: function setFocalPoint(x, y, z) {\n      var up = vec3.fromValues(0, 1, 0);\n      this.focalPoint = createVec3(x, y, z);\n\n      if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {\n        var d = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n        x = d[0];\n        y = d[1];\n        z = d[2];\n        var r = vec3.length(d);\n        var el = Math.asin(y / r) * RAD_2_DEG;\n        var az = 90 + Math.atan2(z, x) * RAD_2_DEG;\n        var m = mat4.create();\n        mat4.rotateY(m, m, az * DEG_2_RAD);\n        mat4.rotateX(m, m, el * DEG_2_RAD);\n        up = vec3.transformMat4(vec3.create(), [0, 1, 0], m);\n      }\n\n      mat4.invert(this.matrix, mat4.lookAt(mat4.create(), this.position, this.focalPoint, up));\n\n      this._getAxes();\n\n      this._getDistance();\n\n      this._getAngles();\n\n      return this;\n    }\n    /**\n     * 固定当前视点，按指定距离放置相机\n     */\n\n  }, {\n    key: \"setDistance\",\n    value: function setDistance(d) {\n      if (this.distance === d || d < 0) {\n        return;\n      }\n\n      this.distance = d;\n\n      if (this.distance < 0.0002) {\n        this.distance = 0.0002;\n      }\n\n      this.dollyingStep = this.distance / 100;\n      var pos = vec3.create();\n      d = this.distance;\n      var n = this.forward;\n      var f = this.focalPoint;\n      pos[0] = d * n[0] + f[0];\n      pos[1] = d * n[1] + f[1];\n      pos[2] = d * n[2] + f[2];\n\n      this._setPosition(pos);\n\n      return this;\n    }\n  }, {\n    key: \"setMaxDistance\",\n    value: function setMaxDistance(d) {\n      this.maxDistance = d;\n      return this;\n    }\n  }, {\n    key: \"setMinDistance\",\n    value: function setMinDistance(d) {\n      this.minDistance = d;\n      return this;\n    }\n    /**\n     * Changes the initial azimuth of the camera\n     */\n\n  }, {\n    key: \"changeAzimuth\",\n    value: function changeAzimuth(az) {\n      this.setAzimuth(this.azimuth + az);\n      return this;\n    }\n    /**\n     * Changes the initial elevation of the camera\n     */\n\n  }, {\n    key: \"changeElevation\",\n    value: function changeElevation(el) {\n      this.setElevation(this.elevation + el);\n      return this;\n    }\n    /**\n     * Changes the initial roll of the camera\n     */\n\n  }, {\n    key: \"changeRoll\",\n    value: function changeRoll(rl) {\n      this.setRoll(this.roll + rl);\n      return this;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} el the azimuth in degrees\n     */\n\n  }, {\n    key: \"setAzimuth\",\n    value: function setAzimuth(az) {\n      this.azimuth = getAngle(az);\n      this.computeMatrix();\n\n      this._getAxes();\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getAzimuth\",\n    value: function getAzimuth() {\n      return this.azimuth;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} el the elevation in degrees\n     */\n\n  }, {\n    key: \"setElevation\",\n    value: function setElevation(el) {\n      this.elevation = getAngle(el);\n      this.computeMatrix();\n\n      this._getAxes();\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n\n      return this;\n    }\n    /**\n     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n     * @param {Number} angle the roll angle\n     */\n\n  }, {\n    key: \"setRoll\",\n    value: function setRoll(angle) {\n      this.roll = getAngle(angle);\n      this.computeMatrix();\n\n      this._getAxes();\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n\n      return this;\n    }\n    /**\n     * Changes the azimuth and elevation with respect to the current camera axes\n     * @param {Number} azimuth the relative azimuth\n     * @param {Number} elevation the relative elevation\n     * @param {Number} roll the relative roll\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(azimuth, elevation, roll) {\n      if (this.type === CAMERA_TYPE.EXPLORING) {\n        azimuth = getAngle(azimuth);\n        elevation = getAngle(elevation);\n        roll = getAngle(roll);\n        var rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD);\n        var rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD);\n        var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], roll * DEG_2_RAD);\n        var rotQ = quat.multiply(quat.create(), rotY, rotX);\n        rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n        var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n        mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n      } else {\n        if (Math.abs(this.elevation + elevation) > 90) {\n          return;\n        }\n\n        this.relElevation = getAngle(elevation);\n        this.relAzimuth = getAngle(azimuth);\n        this.relRoll = getAngle(roll);\n        this.elevation += this.relElevation;\n        this.azimuth += this.relAzimuth;\n        this.roll += this.relRoll;\n        this.computeMatrix();\n      }\n\n      this._getAxes();\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        this._getPosition();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        this._getFocalPoint();\n      }\n\n      this._update();\n\n      return this;\n    }\n    /**\n     * 沿水平(right) & 垂直(up)平移相机\n     */\n\n  }, {\n    key: \"pan\",\n    value: function pan(tx, ty) {\n      var coords = createVec3(tx, ty, 0);\n      var pos = vec3.clone(this.position);\n      vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));\n      vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));\n\n      this._setPosition(pos);\n\n      return this;\n    }\n    /**\n     * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢\n     */\n\n  }, {\n    key: \"dolly\",\n    value: function dolly(value) {\n      var n = this.forward;\n      var pos = vec3.clone(this.position);\n      var step = value * this.dollyingStep;\n      var updatedDistance = this.distance + value * this.dollyingStep; // 限制视点距离范围\n\n      step = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;\n      pos[0] += step * n[0];\n      pos[1] += step * n[1];\n      pos[2] += step * n[2];\n\n      this._setPosition(pos);\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        // 重新计算视点距离\n        this._getDistance();\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        // 保持视距，移动视点位置\n        vec3.add(this.focalPoint, pos, this.distanceVector);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"createLandmark\",\n    value: function createLandmark(name, params) {\n      var camera = this.clone();\n      camera.setPosition(params.position);\n      camera.setFocalPoint(params.focalPoint);\n\n      if (params.roll !== undefined) {\n        camera.setRoll(params.roll);\n      }\n\n      var landmark = new Landmark(name, camera);\n      this.landmarks.push(landmark);\n      return landmark;\n    }\n  }, {\n    key: \"setLandmark\",\n    value: function setLandmark(name) {\n      var landmark = new Landmark(name, this);\n      this.landmarks.push(landmark);\n      return this;\n    }\n  }, {\n    key: \"gotoLandmark\",\n    value: function gotoLandmark(name) {\n      var _this = this;\n\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n      var landmark = this.landmarks.find(function (l) {\n        return l.name === name;\n      });\n\n      if (landmark) {\n        if (duration === 0) {\n          landmark.retrieve(this);\n          return;\n        }\n\n        if (this.landmarkAnimationID !== undefined) {\n          window.cancelAnimationFrame(this.landmarkAnimationID);\n        } // TODO: do not process events during animation\n\n\n        this.interactor.disconnect();\n        var destPosition = landmark.getPosition();\n        var destFocalPoint = landmark.getFocalPoint();\n        var destRoll = landmark.getRoll();\n        var timeStart;\n\n        var animate = function animate(timestamp) {\n          if (timeStart === undefined) {\n            timeStart = timestamp;\n          }\n\n          var elapsed = timestamp - timeStart; // TODO: use better ease function\n\n          var t = (1 - Math.cos(elapsed / duration * Math.PI)) / 2;\n          var interFocalPoint = vec3.create();\n          var interPosition = vec3.create();\n          var interRoll = 0;\n          vec3.lerp(interFocalPoint, _this.focalPoint, destFocalPoint, t);\n          vec3.lerp(interPosition, _this.position, destPosition, t);\n          interRoll = _this.roll * (1 - t) + destRoll * t;\n\n          _this.setFocalPoint(interFocalPoint);\n\n          _this.setPosition(interPosition);\n\n          _this.setRoll(interRoll);\n\n          _this.computeMatrix();\n\n          var dist = vec3.dist(interFocalPoint, destFocalPoint) + vec3.dist(interPosition, destPosition);\n\n          if (dist > 0.01) {//\n          } else {\n            _this.setFocalPoint(interFocalPoint);\n\n            _this.setPosition(interPosition);\n\n            _this.setRoll(interRoll);\n\n            _this.computeMatrix();\n\n            _this.interactor.connect();\n\n            return;\n          }\n\n          if (elapsed < duration) {\n            _this.landmarkAnimationID = window.requestAnimationFrame(animate);\n          }\n        };\n\n        window.requestAnimationFrame(animate);\n      }\n    }\n    /**\n     * 根据相机矩阵重新计算各种相机参数\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._getAxes();\n\n      this._getPosition();\n\n      this._getDistance();\n\n      this._getAngles();\n    }\n    /**\n     * 计算相机矩阵\n     */\n\n  }, {\n    key: \"computeMatrix\",\n    value: function computeMatrix() {\n      var rotX;\n      var rotY; // 使用四元数描述 3D 旋转\n      // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n\n      var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], this.roll * DEG_2_RAD);\n      mat4.identity(this.matrix); // only consider HCS for EXPLORING and ORBITING cameras\n\n      rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.elevation * DEG_2_RAD);\n      rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.azimuth * DEG_2_RAD);\n      var rotQ = quat.multiply(quat.create(), rotY, rotX);\n      rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n      var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n\n      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {\n        mat4.translate(this.matrix, this.matrix, this.focalPoint);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n      } else if (this.type === CAMERA_TYPE.TRACKING) {\n        mat4.translate(this.matrix, this.matrix, this.position);\n        mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      }\n    }\n    /**\n     * Sets the camera position in the camera matrix\n     */\n\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition(x, y, z) {\n      this.position = createVec3(x, y, z);\n      var m = this.matrix;\n      m[12] = this.position[0];\n      m[13] = this.position[1];\n      m[14] = this.position[2];\n      m[15] = 1;\n    }\n    /**\n     * Recalculates axes based on the current matrix\n     */\n\n  }, {\n    key: \"_getAxes\",\n    value: function _getAxes() {\n      vec3.copy(this.right, createVec3(vec4.transformMat4(vec4.create(), [1, 0, 0, 0], this.matrix)));\n      vec3.copy(this.up, createVec3(vec4.transformMat4(vec4.create(), [0, 1, 0, 0], this.matrix)));\n      vec3.copy(this.forward, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 1, 0], this.matrix)));\n      vec3.normalize(this.right, this.right);\n      vec3.normalize(this.up, this.up);\n      vec3.normalize(this.forward, this.forward);\n    }\n    /**\n     * Recalculates euler angles based on the current state\n     */\n\n  }, {\n    key: \"_getAngles\",\n    value: function _getAngles() {\n      // Recalculates angles\n      var x = this.distanceVector[0];\n      var y = this.distanceVector[1];\n      var z = this.distanceVector[2];\n      var r = vec3.length(this.distanceVector); // FAST FAIL: If there is no distance we cannot compute angles\n\n      if (r === 0) {\n        this.elevation = 0;\n        this.azimuth = 0;\n        return;\n      }\n\n      if (this.type === CAMERA_TYPE.TRACKING) {\n        this.elevation = Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n      } else {\n        if (this.rotateWorld) {\n          this.elevation = Math.asin(y / r) * RAD_2_DEG;\n          this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n        } else {\n          this.elevation = -Math.asin(y / r) * RAD_2_DEG;\n          this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;\n        }\n      }\n    }\n    /**\n     * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化\n     */\n\n  }, {\n    key: \"_getPosition\",\n    value: function _getPosition() {\n      vec3.copy(this.position, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 0, 1], this.matrix))); // 相机位置变化，需要重新计算视距\n\n      this._getDistance();\n    }\n    /**\n     * 重新计算视点，只有 TRACKING 模式视点才会发生变化\n     */\n\n  }, {\n    key: \"_getFocalPoint\",\n    value: function _getFocalPoint() {\n      vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3.fromMat4(mat3.create(), this.matrix));\n      vec3.add(this.focalPoint, this.position, this.distanceVector); // 视点变化，需要重新计算视距\n\n      this._getDistance();\n    }\n    /**\n     * 重新计算视距\n     */\n\n  }, {\n    key: \"_getDistance\",\n    value: function _getDistance() {\n      this.distanceVector = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n      this.distance = vec3.length(this.distanceVector);\n      this.dollyingStep = this.distance / 100;\n    }\n  }]);\n\n  return Camera;\n}(), _class3.ProjectionMode = {\n  ORTHOGRAPHIC: 'ORTHOGRAPHIC',\n  PERSPECTIVE: 'PERSPECTIVE'\n}, _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"interactor\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);","map":{"version":3,"mappings":"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","names":["Frustum","IDENTIFIER","mat3","mat4","quat","vec3","vec4","inject","injectable","createVec3","getAngle","Landmark","CAMERA_TYPE","CAMERA_TRACKING_MODE","CAMERA_PROJECTION_MODE","DEG_2_RAD","Math","PI","RAD_2_DEG","Camera","InteractorService","_classCallCheck","matrix","create","right","fromValues","up","forward","position","focalPoint","distanceVector","distance","azimuth","elevation","roll","relAzimuth","relElevation","relRoll","dollyingStep","maxDistance","Infinity","minDistance","rotateWorld","_initializerDefineProperty","fov","near","far","aspect","left","rright","top","bottom","zoom","perspective","view","following","undefined","type","EXPLORING","trackingMode","DEFAULT","projectionMode","PERSPECTIVE","frustum","landmarks","landmarkAnimationID","_createClass","key","value","camera","setType","interactor","setWorldRotation","_getAngles","TRACKING","setTrackingMode","Error","flag","invert","_update","setPerspective","fullWidth","fullHeight","x","y","width","height","enabled","offsetX","offsetY","setOrthographic","l","r","t","b","ORTHOGRAPHIC","dx","dy","cx","cy","scaleW","scaleH","ortho","z","_setPosition","setFocalPoint","CINEMATIC","d","subtract","length","el","asin","az","atan2","m","rotateY","rotateX","transformMat4","lookAt","_getAxes","_getDistance","pos","n","f","setAzimuth","setElevation","rl","setRoll","computeMatrix","ORBITING","_getPosition","_getFocalPoint","angle","rotX","setAxisAngle","rotY","rotZ","rotQ","multiply","rotMatrix","fromQuat","translate","abs","tx","ty","coords","clone","add","scale","step","updatedDistance","max","min","name","params","setPosition","landmark","push","duration","find","retrieve","window","cancelAnimationFrame","disconnect","destPosition","getPosition","destFocalPoint","getFocalPoint","destRoll","getRoll","timeStart","animate","timestamp","elapsed","cos","interFocalPoint","interPosition","interRoll","lerp","_this","dist","connect","requestAnimationFrame","identity","copy","normalize","transformMat3","fromMat4","ProjectionMode","configurable","enumerable","writable","initializer"],"sources":["../../src/camera/Camera.ts"],"sourcesContent":["import {\n  Frustum,\n  ICamera,\n  IDENTIFIER,\n  IInteractorService,\n} from '@antv/g-webgpu-core';\nimport { mat3, mat4, quat, vec3, vec4 } from 'gl-matrix';\nimport { inject, injectable, postConstruct } from 'inversify';\nimport { createVec3, getAngle } from '../utils/math';\nimport Landmark from './Landmark';\n\nexport enum CAMERA_TYPE {\n  ORBITING = 'ORBITING',\n  EXPLORING = 'EXPLORING',\n  TRACKING = 'TRACKING',\n}\n\nexport enum CAMERA_TRACKING_MODE {\n  DEFAULT = 'DEFAULT',\n  ROTATIONAL = 'ROTATIONAL',\n  TRANSLATIONAL = 'TRANSLATIONAL',\n  CINEMATIC = 'CINEMATIC',\n}\n\nexport enum CAMERA_PROJECTION_MODE {\n  ORTHOGRAPHIC = 'ORTHOGRAPHIC',\n  PERSPECTIVE = 'PERSPECTIVE',\n}\n\nconst DEG_2_RAD = Math.PI / 180;\nconst RAD_2_DEG = 180 / Math.PI;\n\n/**\n * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计\n * 保存相机参数，定义相机动作：\n * 1. dolly 沿 n 轴移动\n * 2. pan 沿 u v 轴移动\n * 3. rotate 以方位角旋转\n * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互\n */\n@injectable()\nexport class Camera implements ICamera {\n  public static ProjectionMode = {\n    ORTHOGRAPHIC: 'ORTHOGRAPHIC',\n    PERSPECTIVE: 'PERSPECTIVE',\n  };\n  /**\n   * 相机矩阵\n   */\n  public matrix = mat4.create();\n\n  /**\n   * u 轴\n   * @see http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#a-camera-definition\n   */\n  public right = vec3.fromValues(1, 0, 0);\n\n  /**\n   * v 轴\n   */\n  public up = vec3.fromValues(0, 1, 0);\n\n  /**\n   * n 轴\n   */\n  public forward = vec3.fromValues(0, 0, 1);\n\n  /**\n   * 相机位置\n   */\n  public position = vec3.fromValues(0, 0, 1);\n\n  /**\n   * 视点位置\n   */\n  public focalPoint = vec3.fromValues(0, 0, 0);\n\n  /**\n   * 相机位置到视点向量\n   * focalPoint - position\n   */\n  public distanceVector = vec3.fromValues(0, 0, 0);\n\n  /**\n   * 相机位置到视点距离\n   * length(focalPoint - position)\n   */\n  public distance = 1;\n\n  /**\n   * @see https://en.wikipedia.org/wiki/Azimuth\n   */\n  public azimuth = 0;\n  public elevation = 0;\n  public roll = 0;\n  public relAzimuth = 0;\n  public relElevation = 0;\n  public relRoll = 0;\n\n  /**\n   * 沿 n 轴移动时，保证移动速度从快到慢\n   */\n  public dollyingStep = 0;\n  public maxDistance = Infinity;\n  public minDistance = -Infinity;\n\n  /**\n   * invert the horizontal coordinate system HCS\n   */\n  public rotateWorld = false;\n\n  @inject(IDENTIFIER.InteractorService)\n  public interactor: IInteractorService;\n\n  /**\n   * 投影矩阵参数\n   */\n\n  /**\n   * field of view [0-360]\n   * @see http://en.wikipedia.org/wiki/Angle_of_view\n   */\n  private fov = 30;\n  private near = 0.1;\n  private far = 10000;\n  private aspect = 1;\n  private left: number;\n  private rright: number;\n  private top: number;\n  private bottom: number;\n  private zoom = 1;\n  private perspective = mat4.create();\n\n  private view:\n    | {\n        enabled: boolean;\n        fullWidth: number;\n        fullHeight: number;\n        offsetX: number;\n        offsetY: number;\n        width: number;\n        height: number;\n      }\n    | undefined;\n\n  private following = undefined;\n\n  private type = CAMERA_TYPE.EXPLORING;\n  private trackingMode = CAMERA_TRACKING_MODE.DEFAULT;\n  private projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n\n  /**\n   * for culling use\n   */\n  private frustum: Frustum = new Frustum();\n\n  /**\n   * switch between multiple landmarks\n   */\n  private landmarks: Landmark[] = [];\n  private landmarkAnimationID: number | undefined;\n\n  public clone(): Camera {\n    const camera = new Camera();\n    camera.setType(this.type, undefined);\n    camera.interactor = this.interactor;\n    return camera;\n  }\n\n  public getProjectionMode() {\n    return this.projectionMode;\n  }\n\n  public getPerspective() {\n    return this.perspective;\n  }\n\n  public getFrustum() {\n    return this.frustum;\n  }\n\n  public getPosition() {\n    return this.position;\n  }\n\n  public setType(\n    type: CAMERA_TYPE,\n    trackingMode: CAMERA_TRACKING_MODE | undefined,\n  ) {\n    this.type = type;\n    if (this.type === CAMERA_TYPE.EXPLORING) {\n      this.setWorldRotation(true);\n    } else {\n      this.setWorldRotation(false);\n    }\n    this._getAngles();\n\n    if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {\n      this.setTrackingMode(trackingMode);\n    }\n    return this;\n  }\n\n  public setProjectionMode(projectionMode: CAMERA_PROJECTION_MODE) {\n    this.projectionMode = projectionMode;\n    return this;\n  }\n\n  public setTrackingMode(trackingMode: CAMERA_TRACKING_MODE) {\n    if (this.type !== CAMERA_TYPE.TRACKING) {\n      throw new Error(\n        'Impossible to set a tracking mode if the camera is not of tracking type',\n      );\n    }\n    this.trackingMode = trackingMode;\n    return this;\n  }\n\n  /**\n   * If flag is true, it reverses the azimuth and elevation angles.\n   * Subsequent calls to rotate, setAzimuth, setElevation,\n   * changeAzimuth or changeElevation will cause the inverted effect.\n   * setRoll or changeRoll is not affected by this method.\n   *\n   * This inversion is useful when one wants to simulate that the world\n   * is moving, instead of the camera.\n   *\n   * By default the camera angles are not reversed.\n   * @param {Boolean} flag the boolean flag to reverse the angles.\n   */\n  public setWorldRotation(flag: boolean) {\n    this.rotateWorld = flag;\n    this._getAngles();\n  }\n\n  /**\n   * 计算 MV 矩阵，为相机矩阵的逆矩阵\n   */\n  public getViewTransform(): mat4 {\n    return mat4.invert(mat4.create(), this.matrix)!;\n  }\n\n  public getWorldTransform(): mat4 {\n    return this.matrix;\n  }\n\n  /**\n   * 设置相机矩阵\n   */\n  public setMatrix(matrix: mat4) {\n    this.matrix = matrix;\n    this._update();\n    return this;\n  }\n\n  public setAspect(aspect: number) {\n    this.setPerspective(this.near, this.far, this.fov, aspect);\n    return this;\n  }\n\n  /**\n   * Sets an offset in a larger frustum, used in PixelPicking\n   */\n  public setViewOffset(\n    fullWidth: number,\n    fullHeight: number,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n  ) {\n    this.aspect = fullWidth / fullHeight;\n    if (this.view === undefined) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1,\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n\n    if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n      this.setPerspective(this.near, this.far, this.fov, this.aspect);\n    } else {\n      this.setOrthographic(\n        this.left,\n        this.rright,\n        this.top,\n        this.bottom,\n        this.near,\n        this.far,\n      );\n    }\n    return this;\n  }\n\n  public clearViewOffset() {\n    if (this.view !== undefined) {\n      this.view.enabled = false;\n    }\n\n    if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {\n      this.setPerspective(this.near, this.far, this.fov, this.aspect);\n    } else {\n      this.setOrthographic(\n        this.left,\n        this.rright,\n        this.top,\n        this.bottom,\n        this.near,\n        this.far,\n      );\n    }\n    return this;\n  }\n\n  public setPerspective(\n    near: number,\n    far: number,\n    fov: number,\n    aspect: number,\n  ) {\n    this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;\n    this.fov = fov;\n    this.near = near;\n    this.far = far;\n    this.aspect = aspect;\n    mat4.perspective(\n      this.perspective,\n      this.fov * DEG_2_RAD,\n      this.aspect,\n      this.near,\n      this.far,\n    );\n    return this;\n  }\n\n  public setOrthographic(\n    l: number,\n    r: number,\n    t: number,\n    b: number,\n    near: number,\n    far: number,\n  ) {\n    this.projectionMode = CAMERA_PROJECTION_MODE.ORTHOGRAPHIC;\n    this.rright = r;\n    this.left = l;\n    this.top = t;\n    this.bottom = b;\n    this.near = near;\n    this.far = far;\n\n    const dx = (this.rright - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.rright + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n\n    if (this.view !== undefined && this.view.enabled) {\n      const scaleW =\n        (this.rright - this.left) / this.view.fullWidth / this.zoom;\n      const scaleH =\n        (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n\n      left += scaleW * this.view.offsetX;\n      right = left + scaleW * this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = top - scaleH * this.view.height;\n    }\n\n    mat4.ortho(this.perspective, left, right, top, bottom, near, far);\n    return this;\n  }\n\n  /**\n   * 设置相机位置\n   */\n  public setPosition(x: number | vec3, y?: number, z?: number) {\n    this._setPosition(x, y, z);\n    this.setFocalPoint(this.focalPoint);\n    return this;\n  }\n\n  /**\n   * 设置视点位置\n   */\n  public setFocalPoint(x: number | vec3, y?: number, z?: number) {\n    let up = vec3.fromValues(0, 1, 0);\n    this.focalPoint = createVec3(x, y, z);\n\n    if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {\n      const d = vec3.subtract(vec3.create(), this.focalPoint, this.position);\n      x = d[0];\n      y = d[1] as number;\n      z = d[2] as number;\n      const r = vec3.length(d);\n      const el = Math.asin(y / r) * RAD_2_DEG;\n      const az = 90 + Math.atan2(z, x) * RAD_2_DEG;\n      const m = mat4.create();\n      mat4.rotateY(m, m, az * DEG_2_RAD);\n      mat4.rotateX(m, m, el * DEG_2_RAD);\n      up = vec3.transformMat4(vec3.create(), [0, 1, 0], m);\n    }\n\n    mat4.invert(\n      this.matrix,\n      mat4.lookAt(mat4.create(), this.position, this.focalPoint, up),\n    );\n\n    this._getAxes();\n    this._getDistance();\n    this._getAngles();\n    return this;\n  }\n\n  /**\n   * 固定当前视点，按指定距离放置相机\n   */\n  public setDistance(d: number) {\n    if (this.distance === d || d < 0) {\n      return;\n    }\n\n    this.distance = d;\n\n    if (this.distance < 0.0002) {\n      this.distance = 0.0002;\n    }\n    this.dollyingStep = this.distance / 100;\n\n    const pos = vec3.create();\n    d = this.distance;\n    const n = this.forward;\n    const f = this.focalPoint;\n\n    pos[0] = d * n[0] + f[0];\n    pos[1] = d * n[1] + f[1];\n    pos[2] = d * n[2] + f[2];\n\n    this._setPosition(pos);\n    return this;\n  }\n\n  public setMaxDistance(d: number) {\n    this.maxDistance = d;\n    return this;\n  }\n\n  public setMinDistance(d: number) {\n    this.minDistance = d;\n    return this;\n  }\n\n  /**\n   * Changes the initial azimuth of the camera\n   */\n  public changeAzimuth(az: number) {\n    this.setAzimuth(this.azimuth + az);\n    return this;\n  }\n\n  /**\n   * Changes the initial elevation of the camera\n   */\n  public changeElevation(el: number) {\n    this.setElevation(this.elevation + el);\n    return this;\n  }\n\n  /**\n   * Changes the initial roll of the camera\n   */\n  public changeRoll(rl: number) {\n    this.setRoll(this.roll + rl);\n    return this;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} el the azimuth in degrees\n   */\n  public setAzimuth(az: number) {\n    this.azimuth = getAngle(az);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  public getAzimuth() {\n    return this.azimuth;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} el the elevation in degrees\n   */\n  public setElevation(el: number) {\n    this.elevation = getAngle(el);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  /**\n   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置\n   * @param {Number} angle the roll angle\n   */\n  public setRoll(angle: number) {\n    this.roll = getAngle(angle);\n    this.computeMatrix();\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n    return this;\n  }\n\n  /**\n   * Changes the azimuth and elevation with respect to the current camera axes\n   * @param {Number} azimuth the relative azimuth\n   * @param {Number} elevation the relative elevation\n   * @param {Number} roll the relative roll\n   */\n  public rotate(azimuth: number, elevation: number, roll: number) {\n    if (this.type === CAMERA_TYPE.EXPLORING) {\n      azimuth = getAngle(azimuth);\n      elevation = getAngle(elevation);\n      roll = getAngle(roll);\n\n      const rotX = quat.setAxisAngle(\n        quat.create(),\n        [1, 0, 0],\n        (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD,\n      );\n      const rotY = quat.setAxisAngle(\n        quat.create(),\n        [0, 1, 0],\n        (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD,\n      );\n\n      const rotZ = quat.setAxisAngle(\n        quat.create(),\n        [0, 0, 1],\n        roll * DEG_2_RAD,\n      );\n      let rotQ = quat.multiply(quat.create(), rotY, rotX);\n      rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n      const rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n      mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n    } else {\n      if (Math.abs(this.elevation + elevation) > 90) {\n        return;\n      }\n      this.relElevation = getAngle(elevation);\n      this.relAzimuth = getAngle(azimuth);\n      this.relRoll = getAngle(roll);\n      this.elevation += this.relElevation;\n      this.azimuth += this.relAzimuth;\n      this.roll += this.relRoll;\n\n      this.computeMatrix();\n    }\n\n    this._getAxes();\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      this._getPosition();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      this._getFocalPoint();\n    }\n\n    this._update();\n    return this;\n  }\n\n  /**\n   * 沿水平(right) & 垂直(up)平移相机\n   */\n  public pan(tx: number, ty: number) {\n    const coords = createVec3(tx, ty, 0);\n    const pos = vec3.clone(this.position);\n\n    vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));\n    vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));\n\n    this._setPosition(pos);\n\n    return this;\n  }\n\n  /**\n   * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢\n   */\n  public dolly(value: number) {\n    const n = this.forward;\n    const pos = vec3.clone(this.position);\n    let step = value * this.dollyingStep;\n    const updatedDistance = this.distance + value * this.dollyingStep;\n\n    // 限制视点距离范围\n    step =\n      Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) -\n      this.distance;\n    pos[0] += step * n[0];\n    pos[1] += step * n[1];\n    pos[2] += step * n[2];\n\n    this._setPosition(pos);\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      // 重新计算视点距离\n      this._getDistance();\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      // 保持视距，移动视点位置\n      vec3.add(this.focalPoint, pos, this.distanceVector);\n    }\n    return this;\n  }\n\n  public createLandmark(\n    name: string,\n    params: {\n      position: vec3;\n      focalPoint: vec3;\n      roll?: number;\n    },\n  ): Landmark {\n    const camera = this.clone();\n    camera.setPosition(params.position);\n    camera.setFocalPoint(params.focalPoint);\n    if (params.roll !== undefined) {\n      camera.setRoll(params.roll);\n    }\n    const landmark = new Landmark(name, camera);\n    this.landmarks.push(landmark);\n    return landmark;\n  }\n\n  public setLandmark(name: string) {\n    const landmark = new Landmark(name, this);\n    this.landmarks.push(landmark);\n    return this;\n  }\n\n  public gotoLandmark(name: string, duration: number = 1000) {\n    const landmark = this.landmarks.find((l) => l.name === name);\n    if (landmark) {\n      if (duration === 0) {\n        landmark.retrieve(this);\n        return;\n      }\n\n      if (this.landmarkAnimationID !== undefined) {\n        window.cancelAnimationFrame(this.landmarkAnimationID);\n      }\n\n      // TODO: do not process events during animation\n      this.interactor.disconnect();\n\n      const destPosition = landmark.getPosition();\n      const destFocalPoint = landmark.getFocalPoint();\n      const destRoll = landmark.getRoll();\n\n      let timeStart: number | undefined;\n      const animate = (timestamp: number) => {\n        if (timeStart === undefined) {\n          timeStart = timestamp;\n        }\n        const elapsed = timestamp - timeStart;\n        // TODO: use better ease function\n        const t = (1 - Math.cos((elapsed / duration) * Math.PI)) / 2;\n\n        const interFocalPoint = vec3.create();\n        const interPosition = vec3.create();\n        let interRoll = 0;\n\n        vec3.lerp(interFocalPoint, this.focalPoint, destFocalPoint, t);\n        vec3.lerp(interPosition, this.position, destPosition, t);\n        interRoll = this.roll * (1 - t) + destRoll * t;\n\n        this.setFocalPoint(interFocalPoint);\n        this.setPosition(interPosition);\n        this.setRoll(interRoll);\n        this.computeMatrix();\n\n        const dist =\n          vec3.dist(interFocalPoint, destFocalPoint) +\n          vec3.dist(interPosition, destPosition);\n        if (dist > 0.01) {\n          //\n        } else {\n          this.setFocalPoint(interFocalPoint);\n          this.setPosition(interPosition);\n          this.setRoll(interRoll);\n          this.computeMatrix();\n          this.interactor.connect();\n          return;\n        }\n\n        if (elapsed < duration) {\n          this.landmarkAnimationID = window.requestAnimationFrame(animate);\n        }\n      };\n\n      window.requestAnimationFrame(animate);\n    }\n  }\n\n  /**\n   * 根据相机矩阵重新计算各种相机参数\n   */\n  private _update() {\n    this._getAxes();\n    this._getPosition();\n    this._getDistance();\n    this._getAngles();\n  }\n\n  /**\n   * 计算相机矩阵\n   */\n  private computeMatrix() {\n    let rotX;\n    let rotY;\n    // 使用四元数描述 3D 旋转\n    // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html\n    const rotZ = quat.setAxisAngle(\n      quat.create(),\n      [0, 0, 1],\n      this.roll * DEG_2_RAD,\n    );\n\n    mat4.identity(this.matrix);\n\n    // only consider HCS for EXPLORING and ORBITING cameras\n    rotX = quat.setAxisAngle(\n      quat.create(),\n      [1, 0, 0],\n      ((this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING) ||\n      this.type === CAMERA_TYPE.TRACKING\n        ? 1\n        : -1) *\n        this.elevation *\n        DEG_2_RAD,\n    );\n    rotY = quat.setAxisAngle(\n      quat.create(),\n      [0, 1, 0],\n      ((this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING) ||\n      this.type === CAMERA_TYPE.TRACKING\n        ? 1\n        : -1) *\n        this.azimuth *\n        DEG_2_RAD,\n    );\n\n    let rotQ = quat.multiply(quat.create(), rotY, rotX);\n    rotQ = quat.multiply(quat.create(), rotQ, rotZ);\n    const rotMatrix = mat4.fromQuat(mat4.create(), rotQ);\n\n    if (\n      this.type === CAMERA_TYPE.ORBITING ||\n      this.type === CAMERA_TYPE.EXPLORING\n    ) {\n      mat4.translate(this.matrix, this.matrix, this.focalPoint);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n      mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);\n    } else if (this.type === CAMERA_TYPE.TRACKING) {\n      mat4.translate(this.matrix, this.matrix, this.position);\n      mat4.multiply(this.matrix, this.matrix, rotMatrix);\n    }\n  }\n\n  /**\n   * Sets the camera position in the camera matrix\n   */\n  private _setPosition(x: number | vec3, y?: number, z?: number) {\n    this.position = createVec3(x, y, z);\n    const m = this.matrix;\n    m[12] = this.position[0];\n    m[13] = this.position[1];\n    m[14] = this.position[2];\n    m[15] = 1;\n  }\n\n  /**\n   * Recalculates axes based on the current matrix\n   */\n  private _getAxes() {\n    vec3.copy(\n      this.right,\n      createVec3(vec4.transformMat4(vec4.create(), [1, 0, 0, 0], this.matrix)),\n    );\n    vec3.copy(\n      this.up,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 1, 0, 0], this.matrix)),\n    );\n    vec3.copy(\n      this.forward,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 0, 1, 0], this.matrix)),\n    );\n    vec3.normalize(this.right, this.right);\n    vec3.normalize(this.up, this.up);\n    vec3.normalize(this.forward, this.forward);\n  }\n\n  /**\n   * Recalculates euler angles based on the current state\n   */\n  private _getAngles() {\n    // Recalculates angles\n    const x = this.distanceVector[0];\n    const y = this.distanceVector[1];\n    const z = this.distanceVector[2];\n    const r = vec3.length(this.distanceVector);\n\n    // FAST FAIL: If there is no distance we cannot compute angles\n    if (r === 0) {\n      this.elevation = 0;\n      this.azimuth = 0;\n      return;\n    }\n\n    if (this.type === CAMERA_TYPE.TRACKING) {\n      this.elevation = Math.asin(y / r) * RAD_2_DEG;\n      this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n    } else {\n      if (this.rotateWorld) {\n        this.elevation = Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;\n      } else {\n        this.elevation = -Math.asin(y / r) * RAD_2_DEG;\n        this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;\n      }\n    }\n  }\n\n  /**\n   * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化\n   */\n  private _getPosition() {\n    vec3.copy(\n      this.position,\n      createVec3(vec4.transformMat4(vec4.create(), [0, 0, 0, 1], this.matrix)),\n    );\n\n    // 相机位置变化，需要重新计算视距\n    this._getDistance();\n  }\n\n  /**\n   * 重新计算视点，只有 TRACKING 模式视点才会发生变化\n   */\n  private _getFocalPoint() {\n    vec3.transformMat3(\n      this.distanceVector,\n      [0, 0, -this.distance],\n      mat3.fromMat4(mat3.create(), this.matrix),\n    );\n    vec3.add(this.focalPoint, this.position, this.distanceVector);\n\n    // 视点变化，需要重新计算视距\n    this._getDistance();\n  }\n\n  /**\n   * 重新计算视距\n   */\n  private _getDistance() {\n    this.distanceVector = vec3.subtract(\n      vec3.create(),\n      this.focalPoint,\n      this.position,\n    );\n    this.distance = vec3.length(this.distanceVector);\n    this.dollyingStep = this.distance / 100;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}