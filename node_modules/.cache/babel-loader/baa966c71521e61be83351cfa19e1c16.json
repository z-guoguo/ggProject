{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { isEqual, uniq } from '@antv/util';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot, getDistance } from './utils/data-preprocessing';\nimport Vector from './utils/vector';\nimport { DistanceType } from './types'; // 获取质心\n\nvar getCentroid = function getCentroid(distanceType, allPropertiesWeight, index) {\n  var centroid = [];\n\n  switch (distanceType) {\n    case DistanceType.EuclideanDistance:\n      centroid = allPropertiesWeight[index];\n      break;\n\n    default:\n      centroid = [];\n      break;\n  }\n\n  return centroid;\n};\n/**\n *  k-means算法 根据节点之间的距离将节点聚类为K个簇\n * @param data 图数据\n * @param k 质心（聚类中心）个数\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param distanceType 距离类型 默认节点属性的欧式距离\n */\n\n\nvar kMeans = function kMeans(data, k, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {\n  if (k === void 0) {\n    k = 3;\n  }\n\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n\n  if (distanceType === void 0) {\n    distanceType = DistanceType.EuclideanDistance;\n  }\n\n  var _a = data.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = data.edges,\n      edges = _b === void 0 ? [] : _b;\n  var defaultClusterInfo = {\n    clusters: [{\n      id: \"0\",\n      nodes: nodes\n    }],\n    clusterEdges: []\n  }; // 距离类型为欧式距离且没有属性时，直接return\n\n  if (distanceType === DistanceType.EuclideanDistance && !nodes.every(function (node) {\n    return node.hasOwnProperty(propertyKey);\n  })) {\n    return defaultClusterInfo;\n  } // 所有节点属性集合\n\n\n  var properties = []; // 所有节点属性one-hot特征向量集合\n\n  var allPropertiesWeight = [];\n\n  if (distanceType === DistanceType.EuclideanDistance) {\n    properties = getAllProperties(nodes, propertyKey);\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  }\n\n  if (!allPropertiesWeight.length) {\n    return defaultClusterInfo;\n  }\n\n  var allPropertiesWeightUniq = uniq(allPropertiesWeight.map(function (item) {\n    return item.join('');\n  })); // 当输入节点数量或者属性集合的长度小于k时，k调整为其中最小的值\n\n  var finalK = Math.min(k, nodes.length, allPropertiesWeightUniq.length); // 记录节点的原始index，与allPropertiesWeight对应\n\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i].originIndex = i;\n  } // 初始化质心（聚类中心）\n\n\n  var centroids = [];\n  var centroidIndexList = [];\n  var clusters = [];\n\n  for (var i = 0; i < finalK; i++) {\n    if (i === 0) {\n      // 随机选取质心（聚类中心）\n      var randomIndex = Math.floor(Math.random() * nodes.length);\n\n      switch (distanceType) {\n        case DistanceType.EuclideanDistance:\n          centroids[i] = allPropertiesWeight[randomIndex];\n          break;\n\n        default:\n          centroids[i] = [];\n          break;\n      }\n\n      centroidIndexList.push(randomIndex);\n      clusters[i] = [nodes[randomIndex]];\n      nodes[randomIndex].clusterId = String(i);\n    } else {\n      var maxDistance = -Infinity;\n      var maxDistanceNodeIndex = 0;\n\n      var _loop_1 = function _loop_1(m) {\n        if (!centroidIndexList.includes(m)) {\n          var totalDistance = 0;\n\n          for (var j = 0; j < centroids.length; j++) {\n            // 求节点到质心的距离（默认节点属性的欧式距离）\n            var distance = 0;\n\n            switch (distanceType) {\n              case DistanceType.EuclideanDistance:\n                distance = getDistance(allPropertiesWeight[nodes[m].originIndex], centroids[j], distanceType);\n                break;\n\n              default:\n                break;\n            }\n\n            totalDistance += distance;\n          } // 节点到各质心的平均距离（默认欧式距离）\n\n\n          var avgDistance = totalDistance / centroids.length; // 记录到已有质心最远的的距离和节点索引\n\n          if (avgDistance > maxDistance && !centroids.find(function (centroid) {\n            return isEqual(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m].originIndex));\n          })) {\n            maxDistance = avgDistance;\n            maxDistanceNodeIndex = m;\n          }\n        }\n      }; // 选取与已有质心平均距离最远的点做为新的质心\n\n\n      for (var m = 0; m < nodes.length; m++) {\n        _loop_1(m);\n      }\n\n      centroids[i] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);\n      centroidIndexList.push(maxDistanceNodeIndex);\n      clusters[i] = [nodes[maxDistanceNodeIndex]];\n      nodes[maxDistanceNodeIndex].clusterId = String(i);\n    }\n  }\n\n  var iterations = 0;\n\n  while (true) {\n    for (var i = 0; i < nodes.length; i++) {\n      var minDistanceIndex = 0;\n      var minDistance = Infinity;\n\n      if (!(iterations === 0 && centroidIndexList.includes(i))) {\n        for (var j = 0; j < centroids.length; j++) {\n          // 求节点到质心的距离（默认节点属性的欧式距离）\n          var distance = 0;\n\n          switch (distanceType) {\n            case DistanceType.EuclideanDistance:\n              distance = getDistance(allPropertiesWeight[i], centroids[j], distanceType);\n              break;\n\n            default:\n              break;\n          } // 记录节点最近的质心的索引\n\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            minDistanceIndex = j;\n          }\n        } // 从原来的类别删除节点\n\n\n        if (nodes[i].clusterId !== undefined) {\n          for (var n = clusters[Number(nodes[i].clusterId)].length - 1; n >= 0; n--) {\n            if (clusters[Number(nodes[i].clusterId)][n].id === nodes[i].id) {\n              clusters[Number(nodes[i].clusterId)].splice(n, 1);\n            }\n          }\n        } // 将节点划分到距离最小的质心（聚类中心）所对应的类中\n\n\n        nodes[i].clusterId = String(minDistanceIndex);\n        clusters[minDistanceIndex].push(nodes[i]);\n      }\n    } // 是否存在质心（聚类中心）移动\n\n\n    var centroidsEqualAvg = false;\n\n    for (var i = 0; i < clusters.length; i++) {\n      var clusterNodes = clusters[i];\n      var totalVector = new Vector([]);\n\n      for (var j = 0; j < clusterNodes.length; j++) {\n        totalVector = totalVector.add(new Vector(allPropertiesWeight[clusterNodes[j].originIndex]));\n      } // 计算每个类别的均值向量\n\n\n      var avgVector = totalVector.avg(clusterNodes.length); // 如果均值向量不等于质心向量\n\n      if (!avgVector.equal(new Vector(centroids[i]))) {\n        centroidsEqualAvg = true; // 移动/更新每个类别的质心（聚类中心）到该均值向量\n\n        centroids[i] = avgVector.getArr();\n      }\n    }\n\n    iterations++; // 如果每个节点都归属了类别，且不存在质心（聚类中心）移动或者迭代次数超过1000，则停止\n\n    if (nodes.every(function (node) {\n      return node.clusterId !== undefined;\n    }) && centroidsEqualAvg || iterations >= 1000) {\n      break;\n    }\n  } // get the cluster edges\n\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var _a, _b;\n\n    var source = edge.source,\n        target = edge.target;\n    var sourceClusterId = (_a = nodes.find(function (node) {\n      return node.id === source;\n    })) === null || _a === void 0 ? void 0 : _a.clusterId;\n    var targetClusterId = (_b = nodes.find(function (node) {\n      return node.id === target;\n    })) === null || _b === void 0 ? void 0 : _b.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  return {\n    clusters: clusters,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default kMeans;","map":{"version":3,"names":["isEqual","uniq","getAllProperties","oneHot","getDistance","Vector","DistanceType","getCentroid","distanceType","allPropertiesWeight","index","centroid","EuclideanDistance","kMeans","data","k","propertyKey","involvedKeys","uninvolvedKeys","undefined","_a","nodes","_b","edges","defaultClusterInfo","clusters","id","clusterEdges","every","node","hasOwnProperty","properties","length","allPropertiesWeightUniq","map","item","join","finalK","Math","min","i","originIndex","centroids","centroidIndexList","randomIndex","floor","random","push","clusterId","String","maxDistance","Infinity","maxDistanceNodeIndex","_loop_1","m","includes","totalDistance","j","distance","avgDistance","find","iterations","minDistanceIndex","minDistance","n","Number","splice","centroidsEqualAvg","clusterNodes","totalVector","add","avgVector","avg","equal","getArr","clusterEdgeMap","forEach","edge","source","target","sourceClusterId","targetClusterId","newEdgeId","concat","count","newEdge"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/es/k-means.js"],"sourcesContent":["import { isEqual, uniq } from '@antv/util';\nimport { getAllProperties } from './utils/node-properties';\nimport { oneHot, getDistance } from './utils/data-preprocessing';\nimport Vector from './utils/vector';\nimport { DistanceType } from './types'; // 获取质心\n\nvar getCentroid = function getCentroid(distanceType, allPropertiesWeight, index) {\n  var centroid = [];\n\n  switch (distanceType) {\n    case DistanceType.EuclideanDistance:\n      centroid = allPropertiesWeight[index];\n      break;\n\n    default:\n      centroid = [];\n      break;\n  }\n\n  return centroid;\n};\n/**\n *  k-means算法 根据节点之间的距离将节点聚类为K个簇\n * @param data 图数据\n * @param k 质心（聚类中心）个数\n * @param propertyKey 属性的字段名\n * @param involvedKeys 参与计算的key集合\n * @param uninvolvedKeys 不参与计算的key集合\n * @param distanceType 距离类型 默认节点属性的欧式距离\n */\n\n\nvar kMeans = function kMeans(data, k, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {\n  if (k === void 0) {\n    k = 3;\n  }\n\n  if (propertyKey === void 0) {\n    propertyKey = undefined;\n  }\n\n  if (involvedKeys === void 0) {\n    involvedKeys = [];\n  }\n\n  if (uninvolvedKeys === void 0) {\n    uninvolvedKeys = ['id'];\n  }\n\n  if (distanceType === void 0) {\n    distanceType = DistanceType.EuclideanDistance;\n  }\n\n  var _a = data.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = data.edges,\n      edges = _b === void 0 ? [] : _b;\n  var defaultClusterInfo = {\n    clusters: [{\n      id: \"0\",\n      nodes: nodes\n    }],\n    clusterEdges: []\n  }; // 距离类型为欧式距离且没有属性时，直接return\n\n  if (distanceType === DistanceType.EuclideanDistance && !nodes.every(function (node) {\n    return node.hasOwnProperty(propertyKey);\n  })) {\n    return defaultClusterInfo;\n  } // 所有节点属性集合\n\n\n  var properties = []; // 所有节点属性one-hot特征向量集合\n\n  var allPropertiesWeight = [];\n\n  if (distanceType === DistanceType.EuclideanDistance) {\n    properties = getAllProperties(nodes, propertyKey);\n    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);\n  }\n\n  if (!allPropertiesWeight.length) {\n    return defaultClusterInfo;\n  }\n\n  var allPropertiesWeightUniq = uniq(allPropertiesWeight.map(function (item) {\n    return item.join('');\n  })); // 当输入节点数量或者属性集合的长度小于k时，k调整为其中最小的值\n\n  var finalK = Math.min(k, nodes.length, allPropertiesWeightUniq.length); // 记录节点的原始index，与allPropertiesWeight对应\n\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i].originIndex = i;\n  } // 初始化质心（聚类中心）\n\n\n  var centroids = [];\n  var centroidIndexList = [];\n  var clusters = [];\n\n  for (var i = 0; i < finalK; i++) {\n    if (i === 0) {\n      // 随机选取质心（聚类中心）\n      var randomIndex = Math.floor(Math.random() * nodes.length);\n\n      switch (distanceType) {\n        case DistanceType.EuclideanDistance:\n          centroids[i] = allPropertiesWeight[randomIndex];\n          break;\n\n        default:\n          centroids[i] = [];\n          break;\n      }\n\n      centroidIndexList.push(randomIndex);\n      clusters[i] = [nodes[randomIndex]];\n      nodes[randomIndex].clusterId = String(i);\n    } else {\n      var maxDistance = -Infinity;\n      var maxDistanceNodeIndex = 0;\n\n      var _loop_1 = function _loop_1(m) {\n        if (!centroidIndexList.includes(m)) {\n          var totalDistance = 0;\n\n          for (var j = 0; j < centroids.length; j++) {\n            // 求节点到质心的距离（默认节点属性的欧式距离）\n            var distance = 0;\n\n            switch (distanceType) {\n              case DistanceType.EuclideanDistance:\n                distance = getDistance(allPropertiesWeight[nodes[m].originIndex], centroids[j], distanceType);\n                break;\n\n              default:\n                break;\n            }\n\n            totalDistance += distance;\n          } // 节点到各质心的平均距离（默认欧式距离）\n\n\n          var avgDistance = totalDistance / centroids.length; // 记录到已有质心最远的的距离和节点索引\n\n          if (avgDistance > maxDistance && !centroids.find(function (centroid) {\n            return isEqual(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m].originIndex));\n          })) {\n            maxDistance = avgDistance;\n            maxDistanceNodeIndex = m;\n          }\n        }\n      }; // 选取与已有质心平均距离最远的点做为新的质心\n\n\n      for (var m = 0; m < nodes.length; m++) {\n        _loop_1(m);\n      }\n\n      centroids[i] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);\n      centroidIndexList.push(maxDistanceNodeIndex);\n      clusters[i] = [nodes[maxDistanceNodeIndex]];\n      nodes[maxDistanceNodeIndex].clusterId = String(i);\n    }\n  }\n\n  var iterations = 0;\n\n  while (true) {\n    for (var i = 0; i < nodes.length; i++) {\n      var minDistanceIndex = 0;\n      var minDistance = Infinity;\n\n      if (!(iterations === 0 && centroidIndexList.includes(i))) {\n        for (var j = 0; j < centroids.length; j++) {\n          // 求节点到质心的距离（默认节点属性的欧式距离）\n          var distance = 0;\n\n          switch (distanceType) {\n            case DistanceType.EuclideanDistance:\n              distance = getDistance(allPropertiesWeight[i], centroids[j], distanceType);\n              break;\n\n            default:\n              break;\n          } // 记录节点最近的质心的索引\n\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            minDistanceIndex = j;\n          }\n        } // 从原来的类别删除节点\n\n\n        if (nodes[i].clusterId !== undefined) {\n          for (var n = clusters[Number(nodes[i].clusterId)].length - 1; n >= 0; n--) {\n            if (clusters[Number(nodes[i].clusterId)][n].id === nodes[i].id) {\n              clusters[Number(nodes[i].clusterId)].splice(n, 1);\n            }\n          }\n        } // 将节点划分到距离最小的质心（聚类中心）所对应的类中\n\n\n        nodes[i].clusterId = String(minDistanceIndex);\n        clusters[minDistanceIndex].push(nodes[i]);\n      }\n    } // 是否存在质心（聚类中心）移动\n\n\n    var centroidsEqualAvg = false;\n\n    for (var i = 0; i < clusters.length; i++) {\n      var clusterNodes = clusters[i];\n      var totalVector = new Vector([]);\n\n      for (var j = 0; j < clusterNodes.length; j++) {\n        totalVector = totalVector.add(new Vector(allPropertiesWeight[clusterNodes[j].originIndex]));\n      } // 计算每个类别的均值向量\n\n\n      var avgVector = totalVector.avg(clusterNodes.length); // 如果均值向量不等于质心向量\n\n      if (!avgVector.equal(new Vector(centroids[i]))) {\n        centroidsEqualAvg = true; // 移动/更新每个类别的质心（聚类中心）到该均值向量\n\n        centroids[i] = avgVector.getArr();\n      }\n    }\n\n    iterations++; // 如果每个节点都归属了类别，且不存在质心（聚类中心）移动或者迭代次数超过1000，则停止\n\n    if (nodes.every(function (node) {\n      return node.clusterId !== undefined;\n    }) && centroidsEqualAvg || iterations >= 1000) {\n      break;\n    }\n  } // get the cluster edges\n\n\n  var clusterEdges = [];\n  var clusterEdgeMap = {};\n  edges.forEach(function (edge) {\n    var _a, _b;\n\n    var source = edge.source,\n        target = edge.target;\n    var sourceClusterId = (_a = nodes.find(function (node) {\n      return node.id === source;\n    })) === null || _a === void 0 ? void 0 : _a.clusterId;\n    var targetClusterId = (_b = nodes.find(function (node) {\n      return node.id === target;\n    })) === null || _b === void 0 ? void 0 : _b.clusterId;\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\n\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      var newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n  return {\n    clusters: clusters,\n    clusterEdges: clusterEdges\n  };\n};\n\nexport default kMeans;"],"mappings":"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"},"metadata":{},"sourceType":"module"}