{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { clamp, squaredLength } from '../util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nimport * as Util from './util';\nexport class Path extends Geometry {\n  constructor(args) {\n    super();\n    this.PRECISION = 3;\n    this.segments = [];\n\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        let previousObj = null;\n        const arr = args;\n        arr.forEach((o, i) => {\n          if (i === 0) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (Line.isLine(o)) {\n            this.appendSegment(Path.createSegment('L', o.end));\n          } else if (Curve.isCurve(o)) {\n            this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n          }\n\n          previousObj = o;\n        });\n      } else {\n        const arr = args;\n        arr.forEach(s => {\n          if (s.isSegment) {\n            this.appendSegment(s);\n          }\n        });\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('L', args.end));\n      } else if (Curve.isCurve(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach((point, index) => {\n            const segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);\n            this.appendSegment(segment);\n          });\n        }\n      } else if (args.isSegment) {\n        this.appendSegment(args);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return Path.toStringTag;\n  }\n\n  get start() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        return segment.start;\n      }\n    } // if no visible segment, return last segment end point\n\n\n    return segments[count - 1].end;\n  }\n\n  get end() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    for (let i = count - 1; i >= 0; i -= 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        return segment.end;\n      }\n    } // if no visible segment, return last segment end point\n\n\n    return segments[count - 1].end;\n  }\n\n  moveTo(...args) {\n    return this.appendSegment(MoveTo.create.call(null, ...args));\n  }\n\n  lineTo(...args) {\n    return this.appendSegment(LineTo.create.call(null, ...args));\n  }\n\n  curveTo(...args) {\n    return this.appendSegment(CurveTo.create.call(null, ...args));\n  }\n\n  arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n    const start = this.end || new Point();\n    const points = typeof endX === 'number' ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n\n    if (points != null) {\n      for (let i = 0, ii = points.length; i < ii; i += 6) {\n        this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n      }\n    }\n\n    return this;\n  }\n\n  quadTo(x1, y1, x, y) {\n    const start = this.end || new Point();\n    const data = ['M', start.x, start.y];\n\n    if (typeof x1 === 'number') {\n      data.push('Q', x1, y1, x, y);\n    } else {\n      const p = y1;\n      data.push(`Q`, x1.x, x1.y, p.x, p.y);\n    }\n\n    const path = Path.parse(data.join(' '));\n    this.appendSegment(path.segments.slice(1));\n    return this;\n  }\n\n  close() {\n    return this.appendSegment(Close.create());\n  }\n\n  drawPoints(points, options = {}) {\n    const raw = Util.drawPoints(points, options);\n    const sub = Path.parse(raw);\n\n    if (sub && sub.segments) {\n      this.appendSegment(sub.segments);\n    }\n  }\n\n  bbox() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    let bbox;\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        const segmentBBox = segment.bbox();\n\n        if (segmentBBox != null) {\n          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n        }\n      }\n    }\n\n    if (bbox != null) {\n      return bbox;\n    } // if the path has only invisible elements, return end point of last segment\n\n\n    const lastSegment = segments[count - 1];\n    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n  }\n\n  appendSegment(seg) {\n    const count = this.segments.length;\n    let previousSegment = count !== 0 ? this.segments[count - 1] : null;\n    let currentSegment;\n    const nextSegment = null;\n\n    if (Array.isArray(seg)) {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.push(currentSegment);\n        previousSegment = currentSegment;\n      }\n    } else if (seg != null && seg.isSegment) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.push(currentSegment);\n    }\n\n    return this;\n  }\n\n  insertSegment(index, seg) {\n    const count = this.segments.length;\n\n    if (index < 0) {\n      index = count + index + 1; // eslint-disable-line\n    }\n\n    if (index > count || index < 0) {\n      throw new Error('Index out of range.');\n    }\n\n    let currentSegment;\n    let previousSegment = null;\n    let nextSegment = null;\n\n    if (count !== 0) {\n      if (index >= 1) {\n        previousSegment = this.segments[index - 1];\n        nextSegment = previousSegment.nextSegment;\n      } else {\n        previousSegment = null;\n        nextSegment = this.segments[0];\n      }\n    }\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(index, 0, currentSegment);\n    } else {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n      }\n    }\n\n    return this;\n  }\n\n  removeSegment(index) {\n    const idx = this.fixIndex(index);\n    const removedSegment = this.segments.splice(idx, 1)[0];\n    const previousSegment = removedSegment.previousSegment;\n    const nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)\n\n    if (previousSegment) {\n      previousSegment.nextSegment = nextSegment;\n    }\n\n    if (nextSegment) {\n      nextSegment.previousSegment = previousSegment;\n    }\n\n    if (removedSegment.isSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n\n    return removedSegment;\n  }\n\n  replaceSegment(index, seg) {\n    const idx = this.fixIndex(index);\n    let currentSegment;\n    const replacedSegment = this.segments[idx];\n    let previousSegment = replacedSegment.previousSegment;\n    const nextSegment = replacedSegment.nextSegment;\n    let updateSubpathStart = replacedSegment.isSubpathStart;\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(idx, 1, currentSegment);\n\n      if (updateSubpathStart && currentSegment.isSubpathStart) {\n        // already updated by `prepareSegment`\n        updateSubpathStart = false;\n      }\n    } else {\n      this.segments.splice(index, 1);\n\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          updateSubpathStart = false;\n        }\n      }\n    }\n\n    if (updateSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n  }\n\n  getSegment(index) {\n    const idx = this.fixIndex(index);\n    return this.segments[idx];\n  }\n\n  fixIndex(index) {\n    const length = this.segments.length;\n\n    if (length === 0) {\n      throw new Error('Path has no segments.');\n    }\n\n    let i = index;\n\n    while (i < 0) {\n      i = length + i;\n    }\n\n    if (i >= length || i < 0) {\n      throw new Error('Index out of range.');\n    }\n\n    return i;\n  }\n\n  segmentAt(ratio, options = {}) {\n    const index = this.segmentIndexAt(ratio, options);\n\n    if (!index) {\n      return null;\n    }\n\n    return this.getSegment(index);\n  }\n\n  segmentAtLength(length, options = {}) {\n    const index = this.segmentIndexAtLength(length, options);\n    if (!index) return null;\n    return this.getSegment(index);\n  }\n\n  segmentIndexAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opt = this.getOptions(options);\n    const len = this.length(opt);\n    const length = len * rate;\n    return this.segmentIndexAtLength(length, opt);\n  }\n\n  segmentIndexAtLength(length, options = {}) {\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let lastVisibleIndex = null;\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= memo + len) {\n          return index;\n        }\n\n        lastVisibleIndex = index;\n      }\n\n      memo += len;\n    } // If length requested is higher than the length of the path, return\n    // last visible segment index. If no visible segment, return null.\n\n\n    return lastVisibleIndex;\n  }\n\n  getSegmentSubdivisions(options = {}) {\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = [];\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segment.getSubdivisions({\n        precision\n      });\n      segmentSubdivisions.push(subdivisions);\n    }\n\n    return segmentSubdivisions;\n  }\n\n  updateSubpathStartSegment(segment) {\n    let previous = segment.previousSegment;\n    let current = segment;\n\n    while (current && !current.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previous != null) {\n        current.subpathStartSegment = previous.subpathStartSegment;\n      } else {\n        current.subpathStartSegment = null;\n      }\n\n      previous = current;\n      current = current.nextSegment;\n    }\n  }\n\n  prepareSegment(segment, previousSegment, nextSegment) {\n    segment.previousSegment = previousSegment;\n    segment.nextSegment = nextSegment;\n\n    if (previousSegment != null) {\n      previousSegment.nextSegment = segment;\n    }\n\n    if (nextSegment != null) {\n      nextSegment.previousSegment = segment;\n    }\n\n    let updateSubpathStart = segment;\n\n    if (segment.isSubpathStart) {\n      // move to\n      segment.subpathStartSegment = segment;\n      updateSubpathStart = nextSegment;\n    } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\n\n    if (updateSubpathStart != null) {\n      this.updateSubpathStartSegment(updateSubpathStart);\n    }\n\n    return segment;\n  }\n\n  closestPoint(p, options = {}) {\n    const t = this.closestPointT(p, options);\n\n    if (!t) {\n      return null;\n    }\n\n    return this.pointAtT(t);\n  }\n\n  closestPointLength(p, options = {}) {\n    const opts = this.getOptions(options);\n    const t = this.closestPointT(p, opts);\n\n    if (!t) {\n      return 0;\n    }\n\n    return this.lengthAtT(t, opts);\n  }\n\n  closestPointNormalizedLength(p, options = {}) {\n    const opts = this.getOptions(options);\n    const cpLength = this.closestPointLength(p, opts);\n\n    if (cpLength === 0) {\n      return 0;\n    }\n\n    const length = this.length(opts);\n\n    if (length === 0) {\n      return 0;\n    }\n\n    return cpLength / length;\n  }\n\n  closestPointT(p, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointT;\n    let minSquaredDistance = Infinity;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n\n      if (segment.isVisible) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = squaredLength(segmentClosestPoint, p);\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = {\n            segmentIndex: i,\n            value: segmentClosestPointT\n          };\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointT) {\n      return closestPointT;\n    }\n\n    return {\n      segmentIndex: this.segments.length - 1,\n      value: 1\n    };\n  }\n\n  closestPointTangent(p, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointTangent;\n    let minSquaredDistance = Infinity;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n\n      if (segment.isDifferentiable()) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = squaredLength(segmentClosestPoint, p);\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointTangent) {\n      return closestPointTangent;\n    }\n\n    return null;\n  }\n\n  containsPoint(p, options = {}) {\n    const polylines = this.toPolylines(options);\n\n    if (!polylines) {\n      return false;\n    }\n\n    let numIntersections = 0;\n\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n\n      if (polyline.containsPoint(p)) {\n        numIntersections += 1;\n      }\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return numIntersections % 2 === 1;\n  }\n\n  pointAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    if (ratio <= 0) {\n      return this.start.clone();\n    }\n\n    if (ratio >= 1) {\n      return this.end.clone();\n    }\n\n    const opts = this.getOptions(options);\n    const pathLength = this.length(opts);\n    const length = pathLength * ratio;\n    return this.pointAtLength(length, opts);\n  }\n\n  pointAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    if (length === 0) {\n      return this.start.clone();\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastVisibleSegment;\n    let memo = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const d = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= memo + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n\n        lastVisibleSegment = segment;\n      }\n\n      memo += d;\n    } // if length requested is higher than the length of the path,\n    // return last visible segment endpoint\n\n\n    if (lastVisibleSegment) {\n      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n    } // if no visible segment, return last segment end point\n\n\n    const lastSegment = this.segments[this.segments.length - 1];\n    return lastSegment.end.clone();\n  }\n\n  pointAtT(t) {\n    const segments = this.segments;\n    const numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    const segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].pointAtT(0);\n\n    if (segmentIndex >= numSegments) {\n      return segments[numSegments - 1].pointAtT(1);\n    }\n\n    const tValue = clamp(t.value, 0, 1);\n    return segments[segmentIndex].pointAtT(tValue);\n  }\n\n  divideAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.divideAtLength(length, opts);\n  }\n\n  divideAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let divided;\n    let dividedSegmentIndex;\n    let lastValidSegment;\n    let lastValidSegmentIndex;\n    let t;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.getSegment(index);\n      const subdivisions = segmentSubdivisions[index];\n      const opts = {\n        precision,\n        subdivisions\n      };\n      const len = segment.length(opts);\n\n      if (segment.isDifferentiable()) {\n        lastValidSegment = segment;\n        lastValidSegmentIndex = index;\n\n        if (length <= memo + len) {\n          dividedSegmentIndex = index;\n          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n          break;\n        }\n      }\n\n      memo += len;\n    }\n\n    if (!lastValidSegment) {\n      return null;\n    }\n\n    if (!divided) {\n      dividedSegmentIndex = lastValidSegmentIndex;\n      t = fromStart ? 1 : 0;\n      divided = lastValidSegment.divideAtT(t);\n    } // create a copy of this path and replace the identified segment with its two divided parts:\n\n\n    const pathCopy = this.clone();\n    const index = dividedSegmentIndex;\n    pathCopy.replaceSegment(index, divided);\n    const divisionStartIndex = index;\n    let divisionMidIndex = index + 1;\n    let divisionEndIndex = index + 2; // do not insert the part if it looks like a point\n\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex);\n      divisionMidIndex -= 1;\n      divisionEndIndex -= 1;\n    } // insert a Moveto segment to ensure secondPath will be valid:\n\n\n    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n    divisionEndIndex += 1; // do not insert the part if it looks like a point\n\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1);\n      divisionEndIndex -= 1;\n    } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\n    const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\n    for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {\n      const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n      const segment = pathCopy.getSegment(i);\n\n      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        const convertedSegment = Path.createSegment('L', originalSegment.end);\n        pathCopy.replaceSegment(i, convertedSegment);\n      }\n    } // distribute pathCopy segments into two paths and return those:\n\n\n    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n    return [firstPath, secondPath];\n  }\n\n  intersectsWithLine(line, options = {}) {\n    const polylines = this.toPolylines(options);\n\n    if (polylines == null) {\n      return null;\n    }\n\n    let intersections = null;\n\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n      const intersection = line.intersect(polyline);\n\n      if (intersection) {\n        if (intersections == null) {\n          intersections = [];\n        }\n\n        if (Array.isArray(intersection)) {\n          intersections.push(...intersection);\n        } else {\n          intersections.push(intersection);\n        }\n      }\n    }\n\n    return intersections;\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n\n      if (segment.isDifferentiable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isValid() {\n    const segments = this.segments;\n    const isValid = segments.length === 0 || segments[0].type === 'M';\n    return isValid;\n  }\n\n  length(options = {}) {\n    if (this.segments.length === 0) {\n      return 0;\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        subdivisions\n      });\n    }\n\n    return length;\n  }\n\n  lengthAtT(t, options = {}) {\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return 0;\n    }\n\n    let segmentIndex = t.segmentIndex;\n\n    if (segmentIndex < 0) {\n      return 0;\n    }\n\n    let tValue = clamp(t.value, 0, 1);\n\n    if (segmentIndex >= count) {\n      segmentIndex = count - 1;\n      tValue = 1;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n\n    for (let i = 0; i < segmentIndex; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        precision,\n        subdivisions\n      });\n    }\n\n    const segment = this.segments[segmentIndex];\n    const subdivisions = segmentSubdivisions[segmentIndex];\n    length += segment.lengthAtT(tValue, {\n      precision,\n      subdivisions\n    });\n    return length;\n  }\n\n  tangentAt(ratio, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.tangentAtLength(length, opts);\n  }\n\n  tangentAtLength(length, options = {}) {\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastValidSegment;\n    let memo = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isDifferentiable()) {\n        if (length <= memo + len) {\n          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n\n        lastValidSegment = segment;\n      }\n\n      memo += len;\n    } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\n\n    if (lastValidSegment) {\n      const t = fromStart ? 1 : 0;\n      return lastValidSegment.tangentAtT(t);\n    } // if no valid segment, return null\n\n\n    return null;\n  }\n\n  tangentAtT(t) {\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    const segmentIndex = t.segmentIndex;\n\n    if (segmentIndex < 0) {\n      return this.segments[0].tangentAtT(0);\n    }\n\n    if (segmentIndex >= count) {\n      return this.segments[count - 1].tangentAtT(1);\n    }\n\n    const tValue = clamp(t.value, 0, 1);\n    return this.segments[segmentIndex].tangentAtT(tValue);\n  }\n\n  getPrecision(options = {}) {\n    return options.precision == null ? this.PRECISION : options.precision;\n  }\n\n  getSubdivisions(options = {}) {\n    if (options.segmentSubdivisions == null) {\n      const precision = this.getPrecision(options);\n      return this.getSegmentSubdivisions({\n        precision\n      });\n    }\n\n    return options.segmentSubdivisions;\n  }\n\n  getOptions(options = {}) {\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    return {\n      precision,\n      segmentSubdivisions\n    };\n  }\n\n  toPoints(options = {}) {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options);\n    const points = [];\n    let partialPoints = [];\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        const divisions = segmentSubdivisions[i];\n\n        if (divisions.length > 0) {\n          // eslint-disable-next-line no-loop-func\n          divisions.forEach(c => partialPoints.push(c.start));\n        } else {\n          partialPoints.push(segment.start);\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end);\n        points.push(partialPoints);\n        partialPoints = [];\n      }\n    }\n\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end);\n      points.push(partialPoints);\n    }\n\n    return points;\n  }\n\n  toPolylines(options = {}) {\n    const points = this.toPoints(options);\n\n    if (!points) {\n      return null;\n    }\n\n    return points.map(arr => new Polyline(arr));\n  }\n\n  scale(sx, sy, origin) {\n    this.segments.forEach(s => s.scale(sx, sy, origin));\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.segments.forEach(segment => segment.rotate(angle, origin));\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.segments.forEach(s => s.translate(tx, ty));\n    } else {\n      this.segments.forEach(s => s.translate(tx));\n    }\n\n    return this;\n  }\n\n  clone() {\n    const path = new Path();\n    this.segments.forEach(s => path.appendSegment(s.clone()));\n    return path;\n  }\n\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n\n    const segments = this.segments;\n    const otherSegments = p.segments;\n    const count = segments.length;\n\n    if (otherSegments.length !== count) {\n      return false;\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const a = segments[i];\n      const b = otherSegments[i];\n\n      if (a.type !== b.type || !a.equals(b)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  toJSON() {\n    return this.segments.map(s => s.toJSON());\n  }\n\n  serialize() {\n    if (!this.isValid()) {\n      throw new Error('Invalid path segments.');\n    }\n\n    return this.segments.map(s => s.serialize()).join(' ');\n  }\n\n  toString() {\n    return this.serialize();\n  }\n\n}\n\n(function (Path) {\n  Path.toStringTag = `X6.Geometry.${Path.name}`;\n\n  function isPath(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Path) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const path = instance;\n\n    if ((tag == null || tag === Path.toStringTag) && Array.isArray(path.segments) && typeof path.moveTo === 'function' && typeof path.lineTo === 'function' && typeof path.curveTo === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Path.isPath = isPath;\n})(Path || (Path = {}));\n\n(function (Path) {\n  function parse(pathData) {\n    if (!pathData) {\n      return new Path();\n    }\n\n    const path = new Path();\n    const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    const commands = Path.normalize(pathData).match(commandRe);\n\n    if (commands != null) {\n      for (let i = 0, ii = commands.length; i < ii; i += 1) {\n        const command = commands[i];\n        const argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g; // args = [type, coordinate1, coordinate2...]\n\n        const args = command.match(argRe);\n\n        if (args != null) {\n          const type = args[0];\n          const coords = args.slice(1).map(a => +a);\n          const segment = createSegment.call(null, type, ...coords);\n          path.appendSegment(segment);\n        }\n      }\n    }\n\n    return path;\n  }\n\n  Path.parse = parse;\n\n  function createSegment(type, ...args) {\n    if (type === 'M') {\n      return MoveTo.create.call(null, ...args);\n    }\n\n    if (type === 'L') {\n      return LineTo.create.call(null, ...args);\n    }\n\n    if (type === 'C') {\n      return CurveTo.create.call(null, ...args);\n    }\n\n    if (type === 'z' || type === 'Z') {\n      return Close.create();\n    }\n\n    throw new Error(`Invalid path segment type \"${type}\"`);\n  }\n\n  Path.createSegment = createSegment;\n})(Path || (Path = {}));\n\n(function (Path) {\n  Path.normalize = normalizePathData;\n  Path.isValid = Util.isValid;\n  Path.drawArc = Util.drawArc;\n  Path.drawPoints = Util.drawPoints;\n  Path.arcToCurves = Util.arcToCurves;\n})(Path || (Path = {}));","map":{"version":3,"mappings":"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","names":["clamp","squaredLength","Line","Point","Curve","Polyline","Rectangle","Geometry","Close","LineTo","MoveTo","CurveTo","normalizePathData","Util","Path","constructor","args","segments","Array","isArray","isLine","isCurve","previousObj","arr","forEach","o","i","appendSegment","createSegment","start","end","equals","controlPoint1","controlPoint2","s","isSegment","isPolyline","points","length","point","index","segment","Symbol","toStringTag","count","isVisible","moveTo","create","call","lineTo","curveTo","arcTo","rx","ry","xAxisRotation","largeArcFlag","sweepFlag","endX","endY","arcToCurves","x","y","ii","quadTo","x1","y1","data","push","p","path","parse","join","slice","close","drawPoints","options","raw","sub","bbox","segmentBBox","union","lastSegment","seg","previousSegment","currentSegment","nextSegment","prepareSegment","insertSegment","Error","splice","removeSegment","idx","fixIndex","removedSegment","isSubpathStart","updateSubpathStartSegment","replaceSegment","replacedSegment","updateSubpathStart","getSegment","segmentAt","ratio","segmentIndexAt","segmentAtLength","segmentIndexAtLength","rate","opt","getOptions","len","fromStart","precision","getPrecision","segmentSubdivisions","getSubdivisions","memo","lastVisibleIndex","subdivisions","getSegmentSubdivisions","previous","current","subpathStartSegment","closestPoint","t","closestPointT","pointAtT","closestPointLength","opts","lengthAtT","closestPointNormalizedLength","cpLength","minSquaredDistance","Infinity","segmentClosestPointT","segmentClosestPoint","squaredDistance","segmentIndex","value","closestPointTangent","isDifferentiable","tangentAtT","containsPoint","polylines","toPolylines","numIntersections","polyline","pointAt","clone","pathLength","pointAtLength","lastVisibleSegment","d","numSegments","tValue","divideAt","divideAtLength","divided","dividedSegmentIndex","lastValidSegment","lastValidSegmentIndex","divideAtT","pathCopy","divisionStartIndex","divisionMidIndex","divisionEndIndex","movetoEnd","secondPathSegmentIndexConversion","originalSegment","type","convertedSegment","firstPath","secondPath","intersectsWithLine","line","intersections","intersection","intersect","isValid","tangentAt","tangentAtLength","PRECISION","toPoints","partialPoints","divisions","c","map","scale","sx","sy","origin","rotate","angle","translate","tx","ty","otherSegments","a","b","toJSON","serialize","toString","name","isPath","instance","tag","pathData","commandRe","commands","match","command","argRe","coords","drawArc"],"sourceRoot":"","sources":["../../../src/geometry/path/path.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}