{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { gl, IDENTIFIER } from '@antv/g-webgpu-core';\nimport { inject, injectable, named } from 'inversify';\nimport { encodePickingColor } from '../../utils/picking';\nimport { Renderable } from '../Renderable';\n/* babel-plugin-inline-import './shaders/webgl.point.frag.glsl' */\n\nvar pointFrag = \"uniform float u_blur : 0.05;\\nuniform float u_opacity : 0.7;\\nuniform float u_stroke_width : 0.01;\\nuniform vec4 u_stroke_color : [0, 0, 0, 0];\\nuniform float u_stroke_opacity : 1;\\n\\nvarying vec4 v_color;\\nvarying vec4 v_data;\\nvarying float v_radius;\\n\\n#pragma include \\\"sdf2d\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  int shape = int(floor(v_data.w + 0.5));\\n\\n  float antialiasblur = v_data.z;\\n  float antialiased_blur = -max(u_blur, antialiasblur);\\n  float r = v_radius / (v_radius + u_stroke_width);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\\n  // if (shape == 0) {\\n    outer_df = sdCircle(v_data.xy, 1.0);\\n    inner_df = sdCircle(v_data.xy, r);\\n  // } else if (shape == 1) {\\n  //   outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\\n  //   inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\\n  // } else if (shape == 2) {\\n  //   outer_df = sdBox(v_data.xy, vec2(1.));\\n  //   inner_df = sdBox(v_data.xy, vec2(r));\\n  // } else if (shape == 3) {\\n  //   outer_df = sdPentagon(v_data.xy, 0.8);\\n  //   inner_df = sdPentagon(v_data.xy, r * 0.8);\\n  // } else if (shape == 4) {\\n  //   outer_df = sdHexagon(v_data.xy, 0.8);\\n  //   inner_df = sdHexagon(v_data.xy, r * 0.8);\\n  // } else if (shape == 5) {\\n  //   outer_df = sdOctogon(v_data.xy, 1.0);\\n  //   inner_df = sdOctogon(v_data.xy, r);\\n  // } else if (shape == 6) {\\n  //   outer_df = sdHexagram(v_data.xy, 0.52);\\n  //   inner_df = sdHexagram(v_data.xy, r * 0.52);\\n  // } else if (shape == 7) {\\n  //   outer_df = sdRhombus(v_data.xy, vec2(1.0));\\n  //   inner_df = sdRhombus(v_data.xy, vec2(r));\\n  // } else if (shape == 8) {\\n  //   outer_df = sdVesica(v_data.xy, 1.1, 0.8);\\n  //   inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\\n  // }\\n\\n  float opacity_t = smoothstep(0.0, antialiased_blur, outer_df);\\n\\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\\n    antialiased_blur,\\n    0.0,\\n    inner_df\\n  );\\n  vec4 strokeColor = u_stroke_color == vec4(0) ? v_color : u_stroke_color;\\n\\n  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);\\n  gl_FragColor.a = gl_FragColor.a * opacity_t;\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\";\n/* babel-plugin-inline-import './shaders/webgl.point.vert.glsl' */\n\nvar pointVert = \"attribute vec2 position;\\nattribute vec4 color;\\nattribute float shape;\\nattribute vec2 offset;\\nattribute float size;\\n\\nuniform mat4 projectionMatrix;\\nuniform mat4 modelViewMatrix;\\n\\nuniform float u_stroke_width : 0.01;\\nuniform float u_device_pixel_ratio;\\nuniform vec2 u_viewport;\\n\\nvarying vec4 v_color;\\nvarying vec4 v_data;\\nvarying float v_radius;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  v_color = color;\\n  v_radius = size;\\n\\n  lowp float antialiasblur = 1.0 / u_device_pixel_ratio * (size + u_stroke_width);\\n\\n  // construct point coords\\n  v_data = vec4(position, antialiasblur, shape);\\n\\n  gl_Position = projectionMatrix * modelViewMatrix\\n    * vec4(position * size + offset, 0.0, 1.0);\\n\\n  setPickingColor(a_PickingColor);\\n}\";\nvar pointShapes = ['circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'];\nexport\n/**\n * Use SDF to draw 2D point with stroke.\n */\nvar Point = (_dec = injectable(), _dec2 = inject(IDENTIFIER.Systems), _dec3 = named(IDENTIFIER.MaterialSystem), _dec4 = inject(IDENTIFIER.Systems), _dec5 = named(IDENTIFIER.GeometrySystem), _dec6 = inject(IDENTIFIER.ShaderModuleService), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_Renderable) {\n  _inherits(Point, _Renderable);\n\n  var _super = _createSuper(Point);\n\n  function Point() {\n    var _this;\n\n    _classCallCheck(this, Point);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _initializerDefineProperty(_this, \"materialSystem\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"geometrySystem\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"shaderModuleService\", _descriptor3, _assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  _createClass(Point, [{\n    key: \"onAttributeChanged\",\n    value: function onAttributeChanged(_ref) {\n      var name = _ref.name,\n          data = _ref.data;\n      var mesh = this.getMeshComponent();\n\n      if (mesh && mesh.material) {\n        if (name === 'strokeWidth') {\n          mesh.material.setUniform('u_stroke_width', data);\n        } else if (name === 'strokeColor') {\n          mesh.material.setUniform('u_stroke_color', data);\n        } else if (name === 'strokeOpacity') {\n          mesh.material.setUniform('u_stroke_opacity', data);\n        } else if (name === 'opacity') {\n          mesh.material.setUniform('u_opacity', data);\n        } else if (name === 'blur') {\n          mesh.material.setUniform('u_blur', data);\n        }\n      }\n    }\n  }, {\n    key: \"onEntityCreated\",\n    value: function onEntityCreated() {\n      this.shaderModuleService.registerModule('grid', {\n        vs: pointVert,\n        fs: pointFrag\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule('grid'),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          extractedUniforms = _this$shaderModuleSer.uniforms;\n\n      var material = this.materialSystem.createShaderMaterial({\n        vertexShader: vs,\n        fragmentShader: fs,\n        cull: {\n          enable: false\n        },\n        depth: {\n          enable: false\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.SRC_ALPHA,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            srcAlpha: 1,\n            dstAlpha: 1\n          }\n        }\n      }); // TODO: support define stroke-relative props per point\n\n      material.setUniform(_objectSpread({\n        u_device_pixel_ratio: window.devicePixelRatio\n      }, extractedUniforms));\n      var attributes = this.buildAttributes();\n      var geometry = this.geometrySystem.createInstancedBufferGeometry({\n        maxInstancedCount: attributes.instancedOffsets.length / 2,\n        vertexCount: 6\n      });\n      geometry.setIndex([0, 2, 1, 0, 3, 2]);\n      geometry.setAttribute('position', Float32Array.from(attributes.positions), {\n        arrayStride: 4 * 2,\n        stepMode: 'vertex',\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float2'\n        }]\n      });\n      geometry.setAttribute('offset', Float32Array.from(attributes.instancedOffsets), {\n        arrayStride: 4 * 2,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 1,\n          offset: 0,\n          format: 'float2'\n        }]\n      });\n      geometry.setAttribute('color', Float32Array.from(attributes.instancedColors), {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 2,\n          offset: 0,\n          format: 'float4'\n        }]\n      });\n      geometry.setAttribute('size', Float32Array.from(attributes.instancedSizes), {\n        arrayStride: 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 3,\n          offset: 0,\n          format: 'float'\n        }]\n      });\n      geometry.setAttribute('shape', Float32Array.from(attributes.instancedShapes), {\n        arrayStride: 4,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 4,\n          offset: 0,\n          format: 'float'\n        }]\n      });\n      geometry.setAttribute('a_PickingColor', Float32Array.from(attributes.instancedPickingColors), {\n        arrayStride: 4 * 3,\n        stepMode: 'instance',\n        attributes: [{\n          shaderLocation: 6,\n          offset: 0,\n          format: 'float3'\n        }]\n      });\n      this.setMaterial(material);\n      this.setGeometry(geometry);\n    }\n  }, {\n    key: \"buildAttribute\",\n    value: function buildAttribute(config, attributes, index) {\n      var _attributes$instanced, _attributes$instanced2, _attributes$instanced3, _attributes$instanced4;\n\n      (_attributes$instanced = attributes.instancedPickingColors).push.apply(_attributes$instanced, _toConsumableArray(encodePickingColor(config.id || index)));\n\n      attributes.instancedShapes.push(pointShapes.indexOf(config.shape || 'circle'));\n\n      (_attributes$instanced2 = attributes.instancedColors).push.apply(_attributes$instanced2, _toConsumableArray(config.color || [1, 0, 0, 1]));\n\n      (_attributes$instanced3 = attributes.instancedOffsets).push.apply(_attributes$instanced3, _toConsumableArray(config.position || [0, 0]));\n\n      (_attributes$instanced4 = attributes.instancedSizes).push.apply(_attributes$instanced4, _toConsumableArray(config.size || [0.2, 0.2]));\n    }\n  }, {\n    key: \"buildAttributes\",\n    value: function buildAttributes() {\n      var _this2 = this;\n\n      var attributes = {\n        positions: [1, 1, 1, -1, -1, -1, -1, 1],\n        instancedOffsets: [],\n        instancedColors: [],\n        instancedSizes: [],\n        instancedShapes: [],\n        instancedPickingColors: []\n      };\n\n      if (Array.isArray(this.config)) {\n        this.config.forEach(function (config, i) {\n          _this2.buildAttribute(config, attributes, i);\n        });\n      } else {\n        this.buildAttribute(this.config, attributes, 0);\n      }\n\n      return attributes;\n    }\n  }]);\n\n  return Point;\n}(Renderable), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"materialSystem\", [_dec2, _dec3], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, \"geometrySystem\", [_dec4, _dec5], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, \"shaderModuleService\", [_dec6], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAGEA,EAHF,EAIEC,UAJF,QAOO,qBAPP;AAQA,SAASC,MAAT,EAAiBC,UAAjB,EAA6BC,KAA7B,QAA0C,WAA1C;AACA,SAASC,kBAAT,QAAmC,qBAAnC;AACA,SAASC,UAAT,QAA2B,eAA3B;;;;;;;AAIA,IAAMC,WAAW,GAAG,CAClB,QADkB,EAElB,UAFkB,EAGlB,QAHkB,EAIlB,UAJkB,EAKlB,SALkB,EAMlB,SANkB,EAOlB,UAPkB,EAQlB,SARkB,EASlB,QATkB,CAApB;AA8CA;AAJA;AACA;AACA;AAEA,IAAaC,KAAb,WADCL,UAAU,EACX,UAGGD,MAAM,CAACD,UAAU,CAACQ,OAAZ,CAHT,UAIGL,KAAK,CAACH,UAAU,CAACS,cAAZ,CAJR,UAOGR,MAAM,CAACD,UAAU,CAACQ,OAAZ,CAPT,UAQGL,KAAK,CAACH,UAAU,CAACU,cAAZ,CARR,UAWGT,MAAM,CAACD,UAAU,CAACW,mBAAZ,CAXT;EAAAC;;EAAA;;EAAA;IAAA;;IAAAC;;IAAA;MAAAC;IAAA;;IAAAC;;IAAAC;;IAAAA;;IAAAA;;IAAA;EAAA;;EAAAC;IAAAC;IAAAC,yCAoBK;MAAA,IALDC,IAKC,QALDA,IAKC;MAAA,IAJDC,IAIC,QAJDA,IAIC;MACD,IAAMC,IAAI,GAAG,KAAKC,gBAAL,EAAb;;MACA,IAAID,IAAI,IAAIA,IAAI,CAACE,QAAjB,EAA2B;QACzB,IAAIJ,IAAI,KAAK,aAAb,EAA4B;UAC1BE,IAAI,CAACE,QAALF,CAAcG,UAAdH,CAAyB,gBAAzBA,EAA2CD,IAA3CC;QADF,OAEO,IAAIF,IAAI,KAAK,aAAb,EAA4B;UACjCE,IAAI,CAACE,QAALF,CAAcG,UAAdH,CAAyB,gBAAzBA,EAA2CD,IAA3CC;QADK,OAEA,IAAIF,IAAI,KAAK,eAAb,EAA8B;UACnCE,IAAI,CAACE,QAALF,CAAcG,UAAdH,CAAyB,kBAAzBA,EAA6CD,IAA7CC;QADK,OAEA,IAAIF,IAAI,KAAK,SAAb,EAAwB;UAC7BE,IAAI,CAACE,QAALF,CAAcG,UAAdH,CAAyB,WAAzBA,EAAsCD,IAAtCC;QADK,OAEA,IAAIF,IAAI,KAAK,MAAb,EAAqB;UAC1BE,IAAI,CAACE,QAALF,CAAcG,UAAdH,CAAyB,QAAzBA,EAAmCD,IAAnCC;QACD;MACF;IACF;EAnCH;IAAAJ;IAAAC,kCAqC8B;MAC1B,KAAKO,mBAAL,CAAyBC,cAAzB,CAAwC,MAAxC,EAAgD;QAC9CC,EAAE,EAAEC,SAD0C;QAE9CC,EAAE,EAAEC;MAF0C,CAAhD;;MAD0B,4BAStB,KAAKL,mBAAL,CAAyBM,SAAzB,CAAmC,MAAnC,CATsB;MAAA,IAMxBJ,EANwB,yBAMxBA,EANwB;MAAA,IAOxBE,EAPwB,yBAOxBA,EAPwB;MAAA,IAQdG,iBARc,yBAQxBC,QARwB;;MAW1B,IAAMV,QAAQ,GAAG,KAAKW,cAAL,CAAoBC,oBAApB,CAAyC;QACxDC,YAAY,EAAET,EAD0C;QAExDU,cAAc,EAAER,EAFwC;QAGxDS,IAAI,EAAE;UACJC,MAAM,EAAE;QADJ,CAHkD;QAMxDC,KAAK,EAAE;UACLD,MAAM,EAAE;QADH,CANiD;QASxDE,KAAK,EAAE;UACLF,MAAM,EAAE,IADH;UAELG,IAAI,EAAE;YACJC,MAAM,EAAE7C,EAAE,CAAC8C,SADP;YAEJC,MAAM,EAAE/C,EAAE,CAACgD,mBAFP;YAGJC,QAAQ,EAAE,CAHN;YAIJC,QAAQ,EAAE;UAJN;QAFD;MATiD,CAAzC,CAAjB,CAX0B,CA+B1B;;MACAzB,QAAQ,CAACC,UAATD;QACE0B,oBAAoB,EAAEC,MAAM,CAACC;MAD/B,GAEKnB,iBAFL;MAKA,IAAMoB,UAAU,GAAG,KAAKC,eAAL,EAAnB;MAEA,IAAMC,QAAQ,GAAG,KAAKC,cAAL,CAAoBC,6BAApB,CAAkD;QACjEC,iBAAiB,EAAEL,UAAU,CAACM,gBAAXN,CAA4BO,MAA5BP,GAAqC,CADS;QAEjEQ,WAAW,EAAE;MAFoD,CAAlD,CAAjB;MAKAN,QAAQ,CAACO,QAATP,CAAkB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAAlBA;MAEAA,QAAQ,CAACQ,YAATR,CAAsB,UAAtBA,EAAkCS,YAAY,CAACC,IAAbD,CAAkBX,UAAU,CAACa,SAA7BF,CAAlCT,EAA2E;QACzEY,WAAW,EAAE,IAAI,CADwD;QAEzEC,QAAQ,EAAE,QAF+D;QAGzEf,UAAU,EAAE,CACV;UACEgB,cAAc,EAAE,CADlB;UAEEC,MAAM,EAAE,CAFV;UAGEC,MAAM,EAAE;QAHV,CADU;MAH6D,CAA3EhB;MAYAA,QAAQ,CAACQ,YAATR,CACE,QADFA,EAEES,YAAY,CAACC,IAAbD,CAAkBX,UAAU,CAACM,gBAA7BK,CAFFT,EAGE;QACEY,WAAW,EAAE,IAAI,CADnB;QAEEC,QAAQ,EAAE,UAFZ;QAGEf,UAAU,EAAE,CACV;UACEgB,cAAc,EAAE,CADlB;UAEEC,MAAM,EAAE,CAFV;UAGEC,MAAM,EAAE;QAHV,CADU;MAHd,CAHFhB;MAgBAA,QAAQ,CAACQ,YAATR,CACE,OADFA,EAEES,YAAY,CAACC,IAAbD,CAAkBX,UAAU,CAACmB,eAA7BR,CAFFT,EAGE;QACEY,WAAW,EAAE,IAAI,CADnB;QAEEC,QAAQ,EAAE,UAFZ;QAGEf,UAAU,EAAE,CACV;UACEgB,cAAc,EAAE,CADlB;UAEEC,MAAM,EAAE,CAFV;UAGEC,MAAM,EAAE;QAHV,CADU;MAHd,CAHFhB;MAgBAA,QAAQ,CAACQ,YAATR,CACE,MADFA,EAEES,YAAY,CAACC,IAAbD,CAAkBX,UAAU,CAACoB,cAA7BT,CAFFT,EAGE;QACEY,WAAW,EAAE,CADf;QAEEC,QAAQ,EAAE,UAFZ;QAGEf,UAAU,EAAE,CACV;UACEgB,cAAc,EAAE,CADlB;UAEEC,MAAM,EAAE,CAFV;UAGEC,MAAM,EAAE;QAHV,CADU;MAHd,CAHFhB;MAgBAA,QAAQ,CAACQ,YAATR,CACE,OADFA,EAEES,YAAY,CAACC,IAAbD,CAAkBX,UAAU,CAACqB,eAA7BV,CAFFT,EAGE;QACEY,WAAW,EAAE,CADf;QAEEC,QAAQ,EAAE,UAFZ;QAGEf,UAAU,EAAE,CACV;UACEgB,cAAc,EAAE,CADlB;UAEEC,MAAM,EAAE,CAFV;UAGEC,MAAM,EAAE;QAHV,CADU;MAHd,CAHFhB;MAgBAA,QAAQ,CAACQ,YAATR,CACE,gBADFA,EAEES,YAAY,CAACC,IAAbD,CAAkBX,UAAU,CAACsB,sBAA7BX,CAFFT,EAGE;QACEY,WAAW,EAAE,IAAI,CADnB;QAEEC,QAAQ,EAAE,UAFZ;QAGEf,UAAU,EAAE,CACV;UACEgB,cAAc,EAAE,CADlB;UAEEC,MAAM,EAAE,CAFV;UAGEC,MAAM,EAAE;QAHV,CADU;MAHd,CAHFhB;MAgBA,KAAKqB,WAAL,CAAiBpD,QAAjB;MACA,KAAKqD,WAAL,CAAiBtB,QAAjB;IACD;EAjLH;IAAArC;IAAAC,+BAoLI2D,MApLJ,EAqLIzB,UArLJ,EAsLI0B,KAtLJ,EAuLI;MAAA;;MACA,mCAAU,CAACJ,sBAAX,EAAkCK,IAAlC,iDACK5E,kBAAkB,CAAC0E,MAAM,CAACG,EAAPH,IAAaC,KAAd,CADvB;;MAIA1B,UAAU,CAACqB,eAAXrB,CAA2B2B,IAA3B3B,CACE/C,WAAW,CAAC4E,OAAZ5E,CAAoBwE,MAAM,CAACK,KAAPL,IAAgB,QAApCxE,CADF+C;;MAGA,oCAAU,CAACmB,eAAX,EAA2BQ,IAA3B,kDAAoCF,MAAM,CAACM,KAAPN,IAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAApD;;MACA,oCAAU,CAACnB,gBAAX,EAA4BqB,IAA5B,kDAAqCF,MAAM,CAACO,QAAPP,IAAmB,CAAC,CAAD,EAAI,CAAJ,CAAxD;;MACA,oCAAU,CAACL,cAAX,EAA0BO,IAA1B,kDAAmCF,MAAM,CAACQ,IAAPR,IAAe,CAAC,GAAD,EAAM,GAAN,CAAlD;IACD;EAlMH;IAAA5D;IAAAC,kCAoM4B;MAAA;;MACxB,IAAMkC,UAA+B,GAAG;QACtCa,SAAS,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAC,CAAX,EAAc,CAAC,CAAf,EAAkB,CAAC,CAAnB,EAAsB,CAAC,CAAvB,EAA0B,CAA1B,CAD2B;QAEtCP,gBAAgB,EAAE,EAFoB;QAGtCa,eAAe,EAAE,EAHqB;QAItCC,cAAc,EAAE,EAJsB;QAKtCC,eAAe,EAAE,EALqB;QAMtCC,sBAAsB,EAAE;MANc,CAAxC;;MASA,IAAIY,KAAK,CAACC,OAAND,CAAc,KAAKT,MAAnBS,CAAJ,EAAgC;QAC9B,KAAKT,MAAL,CAAYW,OAAZ,CAAoB,UAACX,MAAD,EAASY,CAAT,EAAe;UACjCC,MAAI,CAACC,cAAL,CAAoBd,MAApB,EAA4BzB,UAA5B,EAAwCqC,CAAxC;QADF;MADF,OAIO;QACL,KAAKE,cAAL,CAAoB,KAAKd,MAAzB,EAAiCzB,UAAjC,EAA6C,CAA7C;MACD;;MAED,OAAOA,UAAP;IACD;EAvNH;;EAAA;AAAA,EAA2BhD,UAA3B;EAAAwF;EAAAC;EAAAC;EAAAC;AAAA;EAAAH;EAAAC;EAAAC;EAAAC;AAAA;EAAAH;EAAAC;EAAAC;EAAAC;AAAA","names":["gl","IDENTIFIER","inject","injectable","named","encodePickingColor","Renderable","pointShapes","Point","Systems","MaterialSystem","GeometrySystem","ShaderModuleService","_inherits","_classCallCheck","args","_this","_initializerDefineProperty","_createClass","key","value","name","data","mesh","getMeshComponent","material","setUniform","shaderModuleService","registerModule","vs","pointVert","fs","pointFrag","getModule","extractedUniforms","uniforms","materialSystem","createShaderMaterial","vertexShader","fragmentShader","cull","enable","depth","blend","func","srcRGB","SRC_ALPHA","dstRGB","ONE_MINUS_SRC_ALPHA","srcAlpha","dstAlpha","u_device_pixel_ratio","window","devicePixelRatio","attributes","buildAttributes","geometry","geometrySystem","createInstancedBufferGeometry","maxInstancedCount","instancedOffsets","length","vertexCount","setIndex","setAttribute","Float32Array","from","positions","arrayStride","stepMode","shaderLocation","offset","format","instancedColors","instancedSizes","instancedShapes","instancedPickingColors","setMaterial","setGeometry","config","index","push","id","indexOf","shape","color","position","size","Array","isArray","forEach","i","_this2","buildAttribute","configurable","enumerable","writable","initializer"],"sources":["../../../src/renderable/point/index.ts"],"sourcesContent":["import {\n  BufferData,\n  GeometrySystem,\n  gl,\n  IDENTIFIER,\n  IShaderModuleService,\n  MaterialSystem,\n} from '@antv/g-webgpu-core';\nimport { inject, injectable, named } from 'inversify';\nimport { encodePickingColor } from '../../utils/picking';\nimport { Renderable } from '../Renderable';\nimport pointFrag from './shaders/webgl.point.frag.glsl';\nimport pointVert from './shaders/webgl.point.vert.glsl';\n\nconst pointShapes = [\n  'circle',\n  'triangle',\n  'square',\n  'pentagon',\n  'hexagon',\n  'octogon',\n  'hexagram',\n  'rhombus',\n  'vesica',\n];\n\ninterface IPointConfig {\n  id: number;\n  shape:\n    | 'circle'\n    | 'triangle'\n    | 'square'\n    | 'pentagon'\n    | 'hexagon'\n    | 'octogon'\n    | 'hexagram'\n    | 'rhombus'\n    | 'vesica';\n  position: [number, number];\n  size: [number, number];\n  color: [number, number, number, number]; // sRGB\n  opacity: number;\n  strokeWidth: number;\n  strokeOpacity: number;\n  strokeColor: [number, number, number, number]; // sRGB\n}\n\ninterface IInstanceAttributes {\n  positions: number[];\n  instancedOffsets: number[];\n  instancedColors: number[];\n  instancedSizes: number[];\n  instancedShapes: number[];\n  instancedPickingColors: number[];\n}\n\n/**\n * Use SDF to draw 2D point with stroke.\n */\n@injectable()\nexport class Point extends Renderable<\n  Partial<IPointConfig> | Array<Partial<IPointConfig>>\n> {\n  @inject(IDENTIFIER.Systems)\n  @named(IDENTIFIER.MaterialSystem)\n  private readonly materialSystem: MaterialSystem;\n\n  @inject(IDENTIFIER.Systems)\n  @named(IDENTIFIER.GeometrySystem)\n  private readonly geometrySystem: GeometrySystem;\n\n  @inject(IDENTIFIER.ShaderModuleService)\n  private readonly shaderModuleService: IShaderModuleService;\n\n  protected onAttributeChanged({\n    name,\n    data,\n  }: {\n    name: string;\n    data: BufferData;\n  }) {\n    const mesh = this.getMeshComponent();\n    if (mesh && mesh.material) {\n      if (name === 'strokeWidth') {\n        mesh.material.setUniform('u_stroke_width', data);\n      } else if (name === 'strokeColor') {\n        mesh.material.setUniform('u_stroke_color', data);\n      } else if (name === 'strokeOpacity') {\n        mesh.material.setUniform('u_stroke_opacity', data);\n      } else if (name === 'opacity') {\n        mesh.material.setUniform('u_opacity', data);\n      } else if (name === 'blur') {\n        mesh.material.setUniform('u_blur', data);\n      }\n    }\n  }\n\n  protected onEntityCreated() {\n    this.shaderModuleService.registerModule('grid', {\n      vs: pointVert,\n      fs: pointFrag,\n    });\n    const {\n      vs,\n      fs,\n      uniforms: extractedUniforms,\n    } = this.shaderModuleService.getModule('grid');\n\n    const material = this.materialSystem.createShaderMaterial({\n      vertexShader: vs!,\n      fragmentShader: fs!,\n      cull: {\n        enable: false,\n      },\n      depth: {\n        enable: false,\n      },\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.SRC_ALPHA,\n          dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n          srcAlpha: 1,\n          dstAlpha: 1,\n        },\n      },\n    });\n\n    // TODO: support define stroke-relative props per point\n    material.setUniform({\n      u_device_pixel_ratio: window.devicePixelRatio,\n      ...extractedUniforms,\n    });\n\n    const attributes = this.buildAttributes();\n\n    const geometry = this.geometrySystem.createInstancedBufferGeometry({\n      maxInstancedCount: attributes.instancedOffsets.length / 2,\n      vertexCount: 6,\n    });\n\n    geometry.setIndex([0, 2, 1, 0, 3, 2]);\n\n    geometry.setAttribute('position', Float32Array.from(attributes.positions), {\n      arrayStride: 4 * 2,\n      stepMode: 'vertex',\n      attributes: [\n        {\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float2',\n        },\n      ],\n    });\n\n    geometry.setAttribute(\n      'offset',\n      Float32Array.from(attributes.instancedOffsets),\n      {\n        arrayStride: 4 * 2,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 1,\n            offset: 0,\n            format: 'float2',\n          },\n        ],\n      },\n    );\n\n    geometry.setAttribute(\n      'color',\n      Float32Array.from(attributes.instancedColors),\n      {\n        arrayStride: 4 * 4,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 2,\n            offset: 0,\n            format: 'float4',\n          },\n        ],\n      },\n    );\n\n    geometry.setAttribute(\n      'size',\n      Float32Array.from(attributes.instancedSizes),\n      {\n        arrayStride: 4,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 3,\n            offset: 0,\n            format: 'float',\n          },\n        ],\n      },\n    );\n\n    geometry.setAttribute(\n      'shape',\n      Float32Array.from(attributes.instancedShapes),\n      {\n        arrayStride: 4,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 4,\n            offset: 0,\n            format: 'float',\n          },\n        ],\n      },\n    );\n\n    geometry.setAttribute(\n      'a_PickingColor',\n      Float32Array.from(attributes.instancedPickingColors),\n      {\n        arrayStride: 4 * 3,\n        stepMode: 'instance',\n        attributes: [\n          {\n            shaderLocation: 6,\n            offset: 0,\n            format: 'float3',\n          },\n        ],\n      },\n    );\n\n    this.setMaterial(material);\n    this.setGeometry(geometry);\n  }\n\n  private buildAttribute(\n    config: Partial<IPointConfig>,\n    attributes: IInstanceAttributes,\n    index: number,\n  ) {\n    attributes.instancedPickingColors.push(\n      ...encodePickingColor(config.id || index),\n    );\n\n    attributes.instancedShapes.push(\n      pointShapes.indexOf(config.shape || 'circle'),\n    );\n    attributes.instancedColors.push(...(config.color || [1, 0, 0, 1]));\n    attributes.instancedOffsets.push(...(config.position || [0, 0]));\n    attributes.instancedSizes.push(...(config.size || [0.2, 0.2]));\n  }\n\n  private buildAttributes() {\n    const attributes: IInstanceAttributes = {\n      positions: [1, 1, 1, -1, -1, -1, -1, 1],\n      instancedOffsets: [],\n      instancedColors: [],\n      instancedSizes: [],\n      instancedShapes: [],\n      instancedPickingColors: [],\n    };\n\n    if (Array.isArray(this.config)) {\n      this.config.forEach((config, i) => {\n        this.buildAttribute(config, attributes, i);\n      });\n    } else {\n      this.buildAttribute(this.config, attributes, 0);\n    }\n\n    return attributes;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}