{"ast":null,"code":"import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-56cc1ecc\"), n = n(), _popScopeId(), n);\n\nconst _hoisted_1 = {\n  class: \"antv\"\n};\n\nconst _hoisted_2 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/_createElementVNode(\"div\", {\n  id: \"container\"\n}, null, -1\n/* HOISTED */\n));\n\nconst _hoisted_3 = [_hoisted_2];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, _hoisted_3);\n}","map":{"version":3,"mappings":";;;;;EACSA,KAAK,EAAC;;;gEACPC,oBAA0B,KAA1B,EAA0B;EAArBC,EAAE,EAAC;AAAkB,CAA1B,EAAmB,IAAnB,EAAmB;AAAA;AAAnB;;oBAAAC;;uBADJC,oBAEM,KAFN,cAEMC,UAFN","names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_3"],"sourceRoot":"","sources":["/Users/wawalike/Desktop/ggProject/src/views/antv/index.vue"],"sourcesContent":["<template>\n    <div class=\"antv\">\n        <div id=\"container\"></div>\n    </div>\n</template>\n<script>\nimport { defineComponent, onMounted } from 'vue'\nimport G6 from '@antv/g6';\nexport default defineComponent({\n    name: 'antV',\n    setup() {\n        \n        onMounted(()=> {\n            /**\n             * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n             */\n            // let addedCount = 0;\n            // // Register a custom behavior: add a node when user click the blank part of canvas\n            // G6.registerBehavior('click-add-node', {\n            //     // Set the events and the corresponding responsing function for this behavior\n            //     getEvents() {\n            //         // The event is canvas:click, the responsing function is onClick\n            //         return {\n            //         'canvas:click': 'onClick',\n            //         };\n            //     },\n            //     // Click event\n            //     onClick(ev) {\n            //         const self = this;\n            //         const graph = self.graph;\n            //         // Add a new node\n            //         graph.addItem('node', {\n            //         x: ev.canvasX,\n            //         y: ev.canvasY,\n            //         id: `node-${addedCount}`, // Generate the unique id\n            //         });\n            //         addedCount++;\n            //     },\n            // });\n            // // Register a custom behavior: click two end nodes to add an edge\n            // G6.registerBehavior('click-add-edge', {\n            //     // Set the events and the corresponding responsing function for this behavior\n            //     getEvents() {\n            //         return {\n            //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n            //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n            //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n            //         };\n            //     },\n            //     // The responsing function for node:click defined in getEvents\n            //     onClick(ev) {\n            //         // console.log(1111)\n            //         // console.log(this)\n            //         const self = this;\n            //         const node = ev.item;\n            //         const graph = self.graph;\n            //         // The position where the mouse clicks\n            //         const point = { x: ev.x, y: ev.y };\n            //         const model = node.getModel();\n            //         if (self.addingEdge && self.edge) {\n            //         graph.updateItem(self.edge, {\n            //             target: model.id,\n            //         });\n    \n            //         self.edge = null;\n            //         self.addingEdge = false;\n            //         } else {\n            //         // Add anew edge, the end node is the current node user clicks\n            //         self.edge = graph.addItem('edge', {\n            //             source: model.id,\n            //             target: model.id,\n            //         });\n            //         self.addingEdge = true;\n            //         }\n            //     },\n            //     // The responsing function for mousemove defined in getEvents\n            //     onMousemove(ev) {\n            //         const self = this;\n            //         // The current position the mouse clicks\n            //         const point = { x: ev.x, y: ev.y };\n            //         if (self.addingEdge && self.edge) {\n            //         // Update the end node to the current node the mouse clicks\n            //         self.graph.updateItem(self.edge, {\n            //             target: point,\n            //         });\n            //         }\n            //     },\n            //     // The responsing function for edge:click defined in getEvents\n            //     onEdgeClick(ev) {\n            //         const self = this;\n            //         const currentEdge = ev.item;\n            //         if (self.addingEdge && self.edge === currentEdge) {\n            //         self.graph.removeItem(self.edge);\n            //         self.edge = null;\n            //         self.addingEdge = false;\n            //         }\n            //     },\n            // });\n            // // Initial data\n            // const data = {\n            //     nodes: [\n            //         {\n            //         id: 'node1',\n            //         x: 100,\n            //         y: 200,\n            //         },\n            //         {\n            //         id: 'node2',\n            //         x: 300,\n            //         y: 200,\n            //         },\n            //         {\n            //         id: 'node3',\n            //         x: 300,\n            //         y: 300,\n            //         },\n            //     ],\n            //     edges: [\n            //         {\n            //         id: 'edge1',\n            //         target: 'node2',\n            //         source: 'node1',\n            //         },\n            //     ],\n            // };\n    \n            // const container = document.getElementById('container');\n            // // Add a layout 及子元素\n            // const layoutBox = document.createElement('div');\n            // layoutBox.id = 'layoutBox';\n            // const layoutLeft = document.createElement('div');\n            // layoutLeft.id = 'layoutLeft';\n            // const layoutRight = document.createElement('div');\n            // layoutRight.id = 'layoutRight';\n            // // 设置layout样式\n            // layoutBox.style = \"height:100%;display:flex\"\n            // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n            // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n            // // 添加左侧元素\n            // const node = document.createElement('div');\n            // node.value = 'addNode'\n            // node.id = 'nodeId';\n            // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n            // // 添加样式元素到container\n            // layoutBox.appendChild(layoutLeft);\n            // layoutBox.appendChild(layoutRight);\n            // // container.appendChild(layoutBox);\n            // // 添加子元素到左侧\n            // layoutLeft.appendChild(node);\n            // // Add a selector to DOM\n            // const selector = document.createElement('select');\n            // selector.id = 'selector';\n            // selector.style.border = 'none';\n            // const selection1 = document.createElement('option');\n            // selection1.value = 'default';\n            // selection1.innerHTML = 'Default Mode';\n            // const selection2 = document.createElement('option');\n            // selection2.value = 'addNode';\n            // selection2.innerHTML = 'Add Node (By clicking canvas)';\n            // const selection3 = document.createElement('option');\n            // selection3.value = 'addEdge';\n            // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n            // selector.appendChild(selection1);\n            // selector.appendChild(selection2);\n            // selector.appendChild(selection3);\n            // container.appendChild(selector);\n    \n            // const width = container.scrollWidth;\n            // const height = (container.scrollHeight || 500) - 30;\n            // const graph = new G6.Graph({\n            // container: 'container',\n            // width,\n            // height,\n            // // The sets of behavior modes\n            // modes: {\n            //     // Defualt mode\n            //     default: ['drag-node', 'click-select'],\n            //     // Adding node mode\n            //     addNode: ['click-add-node', 'click-select'],\n            //     // Adding edge mode\n            //     addEdge: ['click-add-edge', 'click-select'],\n            // },\n            // // The node styles in different states\n            // nodeStateStyles: {\n            //     // The node styles in selected state\n            //     selected: {\n            //         stroke: '#666',\n            //         lineWidth: 2,\n            //         fill: 'steelblue',\n            //     },\n            // },\n            // });\n            // graph.data(data);\n            // graph.render();\n    \n            // // Listen to the selector, change the mode when the selector is changed\n            // selector.addEventListener('change', (e) => {\n            //     const value = e.target.value;\n            //     // change the behavior mode\n            //     graph.setMode(value);\n            // });\n            // // 左侧长方形node元素点击事件\n            // node.addEventListener('click', (e) => {\n            //     console.log(e.target.value)\n            //     const value = e.target.value;\n            //     // change the behavior mode\n            //     graph.setMode(value);\n            // });\n    \n            // if (typeof window !== 'undefined')\n            // window.onresize = () => {\n            //     if (!graph || graph.get('destroyed')) return;\n            //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n            //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n            // };\n            // ---------------------------------------------------------------------------------------\n            // G6.Util.processParallelEdges processes the edges with same source node and target node,\n            // on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\n            const processParallelEdgesOnAnchorPoint = (\n                edges,\n                offsetDiff = 15,\n                multiEdgeType = 'quadratic',\n                singleEdgeType = undefined,\n                loopEdgeType = undefined\n                ) => {\n                    debugger\n                const len = edges.length;\n                const cod = offsetDiff * 2;\n                const loopPosition = [\n                    'top',\n                    'top-right',\n                    'right',\n                    'bottom-right',\n                    'bottom',\n                    'bottom-left',\n                    'left',\n                    'top-left',\n                ];\n                const edgeMap = {};\n                const tags = [];\n                const reverses = {};\n                for (let i = 0; i < len; i++) {\n                    const edge = edges[i];\n                    const { source, target, sourceAnchor, targetAnchor } = edge;\n                    const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n\n                    if (tags[i]) continue;\n                    if (!edgeMap[sourceTarget]) {\n                    edgeMap[sourceTarget] = [];\n                    }\n                    tags[i] = true;\n                    edgeMap[sourceTarget].push(edge);\n                    for (let j = 0; j < len; j++) {\n                    if (i === j) continue;\n                    const sedge = edges[j];\n                    const { source: src, target: dst, sourceAnchor: srcAnchor, targetAnchor: dstAnchor } = sedge;\n\n                    // 两个节点之间共同的边\n                    // 第一条的source = 第二条的target\n                    // 第一条的target = 第二条的source\n                    if (!tags[j]) {\n                        if (source === dst && sourceAnchor === dstAnchor\n                            && target === src && targetAnchor === srcAnchor) {\n                        edgeMap[sourceTarget].push(sedge);\n                        tags[j] = true;\n                        reverses[`${src}|${srcAnchor}|${dst}|${dstAnchor}|${edgeMap[sourceTarget].length - 1}`] = true;\n                        } else if (source === src && sourceAnchor === srcAnchor\n                        && target === dst  && targetAnchor === dstAnchor) {\n                        edgeMap[sourceTarget].push(sedge);\n                        tags[j] = true;\n                        }\n                    }\n                    }\n                }\n\n                for (const key in edgeMap) {\n                    const arcEdges = edgeMap[key];\n                    const { length } = arcEdges;\n                    for (let k = 0; k < length; k++) {\n                    const current = arcEdges[k];\n                    if (current.source === current.target) {\n                        if (loopEdgeType) current.type = loopEdgeType;\n                        // 超过8条自环边，则需要重新处理\n                        current.loopCfg = {\n                        position: loopPosition[k % 8],\n                        dist: Math.floor(k / 8) * 20 + 50,\n                        };\n                        continue;\n                    }\n                    if (length === 1 && singleEdgeType && (current.source !== current.target || current.sourceAnchor !== current.targetAnchor)) {\n                        current.type = singleEdgeType;\n                        continue;\n                    }\n                    current.type = multiEdgeType;\n                    const sign =\n                        (k % 2 === 0 ? 1 : -1) * (reverses[`${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`] ? -1 : 1);\n                    if (length % 2 === 1) {\n                        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n                    } else {\n                        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n                    }\n                    }\n                }\n                return edges;\n                };\n\n\n                const data = {\n                nodes: [\n                    { id: 'node1', x: 350, y: 100 },\n                    { id: 'node2', x: 350, y: 250 },\n                ],\n            };\n            const descriptionDiv = document.createElement('div');\n            descriptionDiv.innerHTML = 'Hover the node and the anchor points will show up, click anchor points to create edges.';\n            const container = document.getElementById('container');\n            container.appendChild(descriptionDiv);\n\n            // custom a node with anchor-point shapes\n            G6.registerNode('rect-node', {\n            // draw anchor-point circles according to the anchorPoints in afterDraw\n            afterDraw(cfg, group) {\n                const bbox = group.getBBox();\n                const anchorPoints = this.getAnchorPoints(cfg)\n                anchorPoints.forEach((anchorPos, i) => {\n                group.addShape('circle', {\n                    attrs: {\n                    r: 5,\n                    x: bbox.x + bbox.width * anchorPos[0],\n                    y: bbox.y + bbox.height * anchorPos[1],\n                    fill: '#fff',\n                    stroke: '#5F95FF'\n                    },\n                    name: `anchor-point`, // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n                    anchorPointIdx: i, // flag the idx of the anchor-point circle\n                    links: 0, // cache the number of edges connected to this shape\n                    visible: false, // invisible by default, shows up when links > 1 or the node is in showAnchors state\n                })\n                })\n            },\n            getAnchorPoints(cfg) {\n                return cfg.anchorPoints || [[0, 0.5], [0.33, 0], [0.66, 0], [1, 0.5], [0.33, 1], [0.66, 1]];\n            },\n            // response the state changes and show/hide the link-point circles\n            setState(name, value, item) {\n                if (name === 'showAnchors') {\n                const anchorPoints = item.getContainer().findAll(ele => ele.get('name') === 'anchor-point');\n                anchorPoints.forEach(point => {\n                    if (value || point.get('links') > 0) point.show()\n                    else point.hide()\n                })\n                }\n            }\n            }, 'rect')\n\n            let sourceAnchorIdx, targetAnchorIdx;\n\n            const width = container.scrollWidth;\n            const height = (container.scrollHeight || 500) - 20;\n            const graph = new G6.Graph({\n            container: 'container',\n            width,\n            height,\n            modes: {\n                default: [\n                'drag-node',\n                // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n                {\n                type: 'create-edge',\n                shouldBegin: e => {\n                    // avoid beginning at other shapes on the node\n                    if (e.target && e.target.get('name') !== 'anchor-point') return false;\n                    sourceAnchorIdx = e.target.get('anchorPointIdx');\n                    e.target.set('links', e.target.get('links') + 1); // cache the number of edge connected to this anchor-point circle\n                    return true;\n                },\n                shouldEnd: e => {\n                    // avoid ending at other shapes on the node\n                    if (e.target && e.target.get('name') !== 'anchor-point') return false;\n                    if (e.target) {\n                    targetAnchorIdx = e.target.get('anchorPointIdx');\n                    e.target.set('links', e.target.get('links') + 1);  // cache the number of edge connected to this anchor-point circle\n                    return true;\n                    }\n                    targetAnchorIdx = undefined;\n                    return true;\n                },\n                // update the sourceAnchor\n                // getEdgeConfig: () => {\n                //   return {\n                //     sourceAnchor: sourceAnchorIdx\n                //   }\n                // }\n                }],\n            },\n            defaultNode: {\n                type: 'rect-node',\n                style: {\n                fill: '#eee',\n                stroke: '#ccc',\n                }\n            },\n            defaultEdge: {\n                type: 'quadratic',\n                style: {\n                stroke: '#F6BD16',\n                lineWidth: 2,\n                },\n            },\n            });\n\n            graph.data(data);\n            graph.render();\n\n            graph.on('aftercreateedge', (e) => {\n            // update the sourceAnchor and targetAnchor for the newly added edge\n            graph.updateItem(e.edge, {\n                sourceAnchor: sourceAnchorIdx,\n                targetAnchor: targetAnchorIdx\n            })\n\n            // update the curveOffset for parallel edges\n            const edges = graph.save().edges;\n            processParallelEdgesOnAnchorPoint(edges);\n            graph.getEdges().forEach((edge, i) => {\n                graph.updateItem(edge, {\n                curveOffset: edges[i].curveOffset,\n                curvePosition: edges[i].curvePosition,\n                });\n            });\n            });\n\n            // if create-edge is canceled before ending, update the 'links' on the anchor-point circles\n            graph.on('afterremoveitem', e => {\n            if (e.item && e.item.source && e.item.target) {\n                const sourceNode = graph.findById(e.item.source);\n                const targetNode = graph.findById(e.item.target);\n                const { sourceAnchor, targetAnchor } = e.item;\n                if (sourceNode && !isNaN(sourceAnchor)) {\n                const sourceAnchorShape = sourceNode.getContainer().find(ele => (ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === sourceAnchor));\n                sourceAnchorShape.set('links', sourceAnchorShape.get('links') - 1);\n                }\n                if (targetNode && !isNaN(targetAnchor)) {\n                const targetAnchorShape = targetNode.getContainer().find(ele => (ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === targetAnchor));\n                targetAnchorShape.set('links', targetAnchorShape.get('links') - 1);\n                }\n            }\n            })\n\n            // after clicking on the first node, the edge is created, update the sourceAnchor\n            graph.on('afteradditem', e => {\n            if (e.item && e.item.getType() === 'edge') {\n                graph.updateItem(e.item, {\n                sourceAnchor: sourceAnchorIdx\n                });\n            }\n            })\n\n\n            // some listeners to control the state of nodes to show and hide anchor-point circles\n            graph.on('node:mouseenter', e => {\n            graph.setItemState(e.item, 'showAnchors', true);\n            })\n            graph.on('node:mouseleave', e => {\n            graph.setItemState(e.item, 'showAnchors', false);\n            })\n\n            if (typeof window !== 'undefined')\n            window.onresize = () => {\n                if (!graph || graph.get('destroyed')) return;\n                if (!container || !container.scrollWidth || !container.scrollHeight) return;\n                graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n            };\n        })\n    },\n})\n</script>\n<style lang=\"less\" scoped>\n.antv {\n    height: 100%;\n    // border: 1px solid #ddd;\n    border-radius: 6px;\n    #container {\n        height: 100%;\n    }\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}