{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport floydWarshall from './floydWarshall';\nimport gSpan from './gSpan/gSpan';\nimport dijkstra from './dijkstra';\nimport { uniqueId } from './util';\n/**\n * 为 graphData 中每个节点生成邻居单元数组\n * @param graphData\n * @param spm\n * @param nodeLabelProp\n * @param k k-近邻\n */\n\nvar findKNeighborUnits = function findKNeighborUnits(graphData, spm, nodeLabelProp, k) {\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (k === void 0) {\n    k = 2;\n  }\n\n  var units = [];\n  var nodes = graphData.nodes;\n  spm.forEach(function (row, i) {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\n\nvar findKNeighborUnit = function findKNeighborUnit(nodes, row, i, nodeLabelProp, k) {\n  var unitNodeIdxs = [i];\n  var neighbors = [];\n  var labelCountMap = {};\n  row.forEach(function (v, j) {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      var label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = {\n        count: 1,\n        dists: [v]\n      };else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  }); // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\n\n  Object.keys(labelCountMap).forEach(function (label) {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort(function (a, b) {\n      return a - b;\n    });\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors: neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap\n  };\n};\n/**\n * 随机寻找点对，满足距离小于 k\n * @param k 参数 k，表示 k-近邻\n * @param nodeNum 参数 length\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\n * @param spm 最短路径矩阵\n */\n\n\nvar findNodePairsRandomly = function findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm) {\n  // 每个节点需要随机找出的点对数\n  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  var nodePairMap = {};\n  var foundNodePairCount = 0; // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\n\n  kNeighborUnits.forEach(function (unit, i) {\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\n    var nodePairForICount = 0;\n    var outerLoopCount = 0;\n    var neighbors = unit.nodeIdxs; // the first one is the center node\n\n    var neighborNum = unit.neighborNum - 1;\n\n    while (nodePairForICount < nodePairNumEachNode) {\n      // 另一端节点在节点数组中的的 index\n      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      var innerLoopCount = 0; // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\n\n      while (nodePairMap[\"\".concat(i, \"-\").concat(oidx)] || nodePairMap[\"\".concat(oidx, \"-\").concat(i)]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n      }\n\n      if (innerLoopCount < 2 * nodeNum) {\n        // 未达到最大循环次数，说明找到了合适的另一端\n        nodePairMap[\"\".concat(i, \"-\").concat(oidx)] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx]\n        };\n        nodePairForICount++;\n        foundNodePairCount++; // 如果当前找到的点对数量达到了上限，返回结果\n\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n    } // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\n\n\n    if (nodePairForICount < nodePairNumEachNode) {\n      var gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n/**\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\n * @param neighborUnits 每个节点的邻居元数组\n * @param graphData 原图数据\n * @param edgeMap 边的 map，方便检索\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\n */\n\n\nvar getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {\n  var nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(function (key) {\n    var _a, _b;\n\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = {\n      nodes: [],\n      edges: []\n    };\n    var pair = nodePairMap[key];\n    var startUnitNodeIds = (_a = neighborUnits[pair.start]) === null || _a === void 0 ? void 0 : _a.nodeIdxs;\n    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\n\n    var endSet = new Set(endUnitNodeIds);\n    var intersect = startUnitNodeIds.filter(function (x) {\n      return endSet.has(x);\n    }); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\n\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\n\n    var intersectIdMap = {};\n    var intersectLength = intersect.length;\n\n    for (var i = 0; i < intersectLength; i++) {\n      var node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\n\n      intersectIdMap[node.id] = true;\n    } // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\n\n\n    graphData.edges.forEach(function (edge) {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n/**\n * 计算 strcutre 在 graph 上的匹配数量\n * @param graph 图数据\n * @param structure 目前支持只有两个节点一条边的最简单结构\n * @param nodeLabelProp 节点类型字段名\n * @param edgeLabelProp 边类型字段名\n */\n\n\nvar getMatchedCount = function getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp) {\n  var _a, _b;\n\n  var nodeMap = {};\n  graph.nodes.forEach(function (node) {\n    nodeMap[node.id] = node;\n  });\n  var count = 0;\n  if (!((_a = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a === void 0 ? void 0 : _a.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2) return 0;\n  graph.edges.forEach(function (e) {\n    var sourceLabel = nodeMap[e.source][nodeLabelProp];\n    var targetLabel = nodeMap[e.target][nodeLabelProp];\n    var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];\n    var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];\n    var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n\n    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {\n      count++;\n    }\n  });\n  return count;\n};\n/**\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\n * @param structures\n */\n\n\nvar findRepresentStructure = function findRepresentStructure(matchedCountMap, structureNum, structures) {\n  var maxOffset = Infinity,\n      representClusterType = 0;\n\n  var _loop_1 = function _loop_1(i) {\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\n    var countMapI = matchedCountMap[i]; // 按照 value 为该组排序，生成 keys 的数组：\n\n    var sortedGraphKeys = Object.keys(countMapI).sort(function (a, b) {\n      return countMapI[a] - countMapI[b];\n    }); // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\n\n    var groupNum = 10;\n    var clusters = []; // 总共有 groupNum 个项\n\n    sortedGraphKeys.forEach(function (key, j) {\n      if (!clusters[j % groupNum]) clusters[j % groupNum] = {\n        graphs: [],\n        totalCount: 0,\n        aveCount: 0\n      };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    }); // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\n\n    var aveIntraDist = 0; // 该类的类内平均值\n\n    var aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\n\n    clusters.forEach(function (graphsInCluster) {\n      // 类内均值\n      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount); // 对于每类，计算类内间距平均值\n\n      var aveIntraPerCluster = 0;\n      var graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach(function (graphKey1, j) {\n        var graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach(function (graphKey2, k) {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n    aveIntraDist /= clusters.length; // 用类内均值计算类间距\n\n    var aveInterDist = 0; // 类间间距平均值\n\n    aveCounts.forEach(function (aveCount1, j) {\n      aveCounts.forEach(function (aveCount2, k) {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;\n    }); // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\n\n    var offset = aveInterDist - aveIntraDist;\n\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  };\n\n  for (var i = 0; i < structureNum; i++) {\n    _loop_1(i);\n  }\n\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType]\n  };\n};\n\nvar getNodeMaps = function getNodeMaps(nodes, nodeLabelProp) {\n  var nodeMap = {},\n      nodeLabelMap = {};\n  nodes.forEach(function (node, i) {\n    nodeMap[node.id] = {\n      idx: i,\n      node: node,\n      degree: 0,\n      inDegree: 0,\n      outDegree: 0\n    };\n    var label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return {\n    nodeMap: nodeMap,\n    nodeLabelMap: nodeLabelMap\n  };\n};\n\nvar getEdgeMaps = function getEdgeMaps(edges, edgeLabelProp, nodeMap) {\n  var edgeMap = {},\n      edgeLabelMap = {};\n  edges.forEach(function (edge, i) {\n    edgeMap[\"\".concat(uniqueId)] = {\n      idx: i,\n      edge: edge\n    };\n    var label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n    var sourceNode = nodeMap[edge.source];\n\n    if (sourceNode) {\n      sourceNode.degree++;\n      sourceNode.outDegree++;\n    }\n\n    var targetNode = nodeMap[edge.target];\n\n    if (targetNode) {\n      targetNode.degree++;\n      targetNode.inDegree++;\n    }\n  });\n  return {\n    edgeMap: edgeMap,\n    edgeLabelMap: edgeLabelMap\n  };\n};\n/**\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\n * @param nodes\n * @param spm\n * @param directed\n */\n\n\nvar getSpmMap = function getSpmMap(nodes, spm, directed) {\n  var length = spm.length;\n  var map = {};\n  spm.forEach(function (row, i) {\n    var start = directed ? 0 : i + 1;\n    var iId = nodes[i].id;\n\n    for (var j = start; j < length; j++) {\n      if (i === j) continue;\n      var jId = nodes[j].id;\n      var dist = row[j];\n      map[\"\".concat(iId, \"-\").concat(jId)] = dist;\n      if (!directed) map[\"\".concat(jId, \"-\").concat(iId)] = dist;\n    }\n  });\n  return map;\n};\n/**\n * 计算一对节点（node1，node2）的 NDS 距离\n * @param graph 原图数据\n * @param node1\n * @param node2\n */\n\n\nvar getNDSDist = function getNDSDist(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {\n  var _a;\n\n  var key = \"\".concat(node1.id, \"-\").concat(node2.id);\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined; // 若没有缓存相交邻居诱导子图，计算\n\n  if (!interInducedGraph) {\n    var pairMap = (_a = {}, _a[key] = {\n      start: nodeMap[node1.id].idx,\n      end: nodeMap[node2.id].idx,\n      distance: spDist\n    }, _a);\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n/**\n * 计算 pattern 上绩点的度数并存储到 minPatternNodeLabelDegreeMap\n */\n\n\nvar stashPatternNodeLabelDegreeMap = function stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {\n  var _a, _b, _c;\n\n  var minPatternNodeLabelDegree = (_a = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a === void 0 ? void 0 : _a.degree;\n  var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;\n  var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;\n\n  if (minPatternNodeLabelDegreeMap[neighborLabel] === undefined) {\n    minPatternNodeLabelDegree = Infinity;\n    minPatternNodeLabelInDegree = Infinity;\n    minPatternNodeLabelOutDegree = Infinity;\n    patternNodeLabelMap[neighborLabel].forEach(function (patternNodeWithLabel) {\n      var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n      if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;\n      var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;\n      if (minPatternNodeLabelInDegree > patternNodeInDegree) minPatternNodeLabelInDegree = patternNodeInDegree;\n      var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;\n      if (minPatternNodeLabelOutDegree > patternNodeOutDegree) minPatternNodeLabelOutDegree = patternNodeOutDegree;\n    });\n    minPatternNodeLabelDegreeMap[neighborLabel] = {\n      degree: minPatternNodeLabelDegree,\n      inDegree: minPatternNodeLabelInDegree,\n      outDegree: minPatternNodeLabelOutDegree\n    };\n  }\n\n  return {\n    minPatternNodeLabelDegree: minPatternNodeLabelDegree,\n    minPatternNodeLabelInDegree: minPatternNodeLabelInDegree,\n    minPatternNodeLabelOutDegree: minPatternNodeLabelOutDegree\n  };\n};\n/**\n * GADDI 模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\n\n\nvar GADDI = function GADDI(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  var _a;\n\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n\n  if (!graphData || !graphData.nodes) return; // 分为三步：\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\n  // 1. 处理原图 graphData。再分为 1~5 小步\n  // 2. 匹配\n  // console.log(\"----- stage-pre: preprocessing -------\");\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\n\n  var nodeNum = graphData.nodes.length;\n  if (!nodeNum) return; // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n\n  var spm = floydWarshall(graphData, directed); // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n\n  var patternSpm = floydWarshall(pattern, directed); // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n\n  var spmMap = getSpmMap(graphData.nodes, spm, directed); // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n\n  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed); // console.log(\"----- stage-pre.5: establish maps -------\");\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\n\n  var _b = getNodeMaps(graphData.nodes, nodeLabelProp),\n      nodeMap = _b.nodeMap,\n      nodeLabelMap = _b.nodeLabelMap;\n\n  var _c = getNodeMaps(pattern.nodes, nodeLabelProp),\n      patternNodeMap = _c.nodeMap,\n      patternNodeLabelMap = _c.nodeLabelMap; // 计算节点度数\n\n\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap; // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\n\n  var patternSpmSpread = [];\n  patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function (row) {\n    patternSpmSpread = patternSpmSpread.concat(row);\n  });\n  if (!length) length = Math.max.apply(Math, __spreadArray(__spreadArray([], patternSpmSpread, false), [2], false));\n  if (!k) k = length; // console.log(\"params\", directed, length, k);\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  // 计算每个节点的 k 邻元集合\n\n  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k); // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // -------- 第一步，处理原图 graphData-------\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\n\n  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);\n  var nodePairsMap = findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm); // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n\n  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData); // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\n\n  var top = 10,\n      minSupport = 1,\n      minNodeNum = 1,\n      maxNodeNum = 4;\n  var params = {\n    graphs: intGMap,\n    nodeLabelProp: nodeLabelProp,\n    edgeLabelProp: edgeLabelProp,\n    minSupport: minSupport,\n    minNodeNum: minNodeNum,\n    maxNodeNum: maxNodeNum,\n    directed: directed\n  }; // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  // 暂时假设生成的 sub structure 都只有一条边\n\n  var freStructures = gSpan(params).slice(0, top); // structureNum 可能小于 top\n\n  var structureNum = freStructures.length; // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\n\n  var matchedCountMap = [];\n  freStructures.forEach(function (structure, i) {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(function (key) {\n      var graph = intGMap[key];\n      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  }); // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\n\n  var _d = findRepresentStructure(matchedCountMap, structureNum, freStructures),\n      dsG = _d.structure,\n      ndsDist = _d.structureCountMap; // -------- 第二步，匹配-------\n  // 2.1 找到从 Q 中的一个节点作为起始节点，寻找 G 中的匹配。这个其实节点的标签可以在 G 中找到最多的节点\n\n\n  var beginPNode = pattern.nodes[0],\n      candidates = [],\n      label = (_a = pattern.nodes[0]) === null || _a === void 0 ? void 0 : _a[nodeLabelProp],\n      maxNodeNumWithSameLabel = -Infinity;\n  pattern.nodes.forEach(function (node) {\n    var pLabel = node[nodeLabelProp];\n    var nodesWithSameLabel = nodeLabelMap[pLabel];\n\n    if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {\n      maxNodeNumWithSameLabel = nodesWithSameLabel.length;\n      candidates = nodesWithSameLabel;\n      label = pLabel;\n      beginPNode = node;\n    }\n  }); // console.log(\"----- stage2: going to find candidates -------\");\n  // 全局缓存，避免重复计算\n\n  var minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\n\n  var patternIntGraphMap = {},\n      patternNDSDist = {},\n      // key 为 node.id-node.id\n  patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\n\n  var patternSpDist = {};\n  var patternSpDistBack = {};\n  Object.keys(patternNodeLabelMap).forEach(function (label2, j) {\n    patternSpDist[label2] = [];\n\n    if (directed) {\n      patternSpDistBack[label2] = [];\n    }\n\n    var maxDist = -Infinity;\n    var patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    var patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(function (nodeWithLabel2) {\n      var dist = patternSpmMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist\n      };\n\n      if (directed) {\n        var distBack = patternSpmMap[\"\".concat(nodeWithLabel2.id, \"-\").concat(beginPNode.id)];\n        distBack && patternSpDistBack[label2].push(distBack);\n      }\n    }); // spDist[label2] 按照从小到大排序\n\n    patternSpDist[label2] = patternSpDist[label2].sort(function (a, b) {\n      return a - b;\n    });\n    if (directed) patternSpDistBack[label2] = patternSpDistBack[label2].sort(function (a, b) {\n      return a - b;\n    }); // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\n    // key: node1.id-node2.id\n\n    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap); // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\n\n    var currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(function (key) {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // 缓存过则不需要再次计算\n      }\n\n      var patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    }); // 根据值为 currentPatternNDSDist 从大到小排序\n\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function (a, b) {\n      return b - a;\n    });\n    patternNDSDistMap[\"\".concat(beginPNode.id, \"-\").concat(label2)] = currentPatternNDSDistArray;\n    if (label2 === label) return;\n    var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;\n\n    var _loop_4 = function _loop_4(m) {\n      var cNode = candidates[m]; // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\n\n      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      var patternLabel2Num = patternNodeLabelMap[label2].length;\n\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      } // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\n\n\n      var prune2Invalid = false;\n\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      } // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\n\n\n      var cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(function (neighborNode) {\n        var dist = spmMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)];\n        cNodePairMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist\n        };\n      }); // 更新 intGMap\n\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap); // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\n\n      var currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(function (key) {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // 缓存过则不需要再次计算\n        }\n\n        var intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      }); // 根据值为 currentNDSDistArray 从大到小排序\n\n      currentNDSDistArray = currentNDSDistArray.sort(function (a, b) {\n        return b - a;\n      });\n      var prune3Invalid = false;\n\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n    };\n\n    for (var m = candidatesNum - 1; m >= 0; m--) {\n      _loop_4(m);\n    }\n  });\n  var candidateGraphs = []; // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\n\n  candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function (candidate) {\n    var nodeIdx = nodeMap[candidate.id].idx;\n    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);\n    var neighborNodes = lengthNeighborUnit.neighbors; // 删除不可能找到匹配的邻居点\n\n    var neighborNum = neighborNodes.length;\n    var unmatched = false;\n\n    for (var i = neighborNum - 1; i >= 0; i--) {\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return;\n      }\n\n      var neighborNode = neighborNodes[i];\n      var neighborLabel = neighborNode[nodeLabelProp]; // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\n\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      } // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\n\n\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      var key = \"\".concat(candidate.id, \"-\").concat(neighborNode.id); // prune2.2\n\n      var distToCandidate = spmMap[key];\n      var idx = patternSpDist[neighborLabel].length - 1;\n      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx]; // patternSpDist[neighborLabel] 已经按照从小到大排序\n\n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      if (directed) {\n        var keyBack = \"\".concat(neighborNode.id, \"-\").concat(candidate.id);\n        var distFromCandidate = spmMap[keyBack];\n        idx = patternSpDistBack[neighborLabel].length - 1;\n        var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];\n\n        if (distFromCandidate > maxBackDistWithLabelInPattern) {\n          neighborNodes.splice(i, 1);\n          continue;\n        }\n      } // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\n\n\n      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);\n      var patternKey = \"\".concat(beginPNode.id, \"-\").concat(neighborLabel);\n      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\n\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      } // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\n\n\n      var _a = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap),\n          minPatternNodeLabelDegree = _a.minPatternNodeLabelDegree,\n          minPatternNodeLabelInDegree = _a.minPatternNodeLabelInDegree,\n          minPatternNodeLabelOutDegree = _a.minPatternNodeLabelOutDegree;\n\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n    } // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\n\n\n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes)\n      });\n    }\n  }); // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n\n  var undirectedLengthsToBeginPNode = dijkstra(pattern, beginPNode.id, false).length;\n  var undirectedLengthsToBeginPNodeLabelMap = {};\n\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(function (nodeId) {\n      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function (pLabel) {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function (a, b) {\n        return a - b;\n      });\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  } // 现在 candidateGraphs 里面只有节点，进行边的筛选\n\n\n  var candidateGraphNum = candidateGraphs.length;\n\n  var _loop_2 = function _loop_2(i) {\n    var candidateGraph = candidateGraphs[i];\n    var candidate = candidateGraph.nodes[0];\n    var candidateNodeLabelCountMap = {};\n    var candidateNodeMap = {};\n    candidateGraph.nodes.forEach(function (node, q) {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node: node,\n        degree: 0,\n        inDegree: 0,\n        outDegree: 0\n      };\n      var cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;else candidateNodeLabelCountMap[cNodeLabel]++;\n    }); // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\n\n    var candidateEdges = [];\n    var edgeLabelCountMap = {};\n    graphData.edges.forEach(function (edge) {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n        candidateNodeMap[edge.source].outDegree++;\n        candidateNodeMap[edge.target].inDegree++;\n      }\n    }); // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\n\n    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    var prunedByEdgeLabel = false;\n\n    for (var e = 0; e < pattenrEdgeLabelNum; e++) {\n      var label_1 = Object.keys(patternEdgeLabelMap)[e];\n\n      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    } // 遍历 candidateEdges，进行边的筛选\n\n\n    var candidateEdgeNum = candidateEdges.length; // prune：若边数过少，去除该图\n\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"break\";\n    }\n\n    var candidateGraphInvalid = false;\n\n    var _loop_5 = function _loop_5(e) {\n      var edge = candidateEdges[e];\n      var edgeLabel = edge[edgeLabelProp];\n      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel]; // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\n\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        candidateNodeMap[edge.source].outDegree--;\n        candidateNodeMap[edge.target].inDegree--;\n        return \"continue\";\n      } // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\n\n\n      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n      var edgeMatched = false;\n      patternEdgesWithLabel.forEach(function (patternEdge) {\n        var patternSource = patternNodeMap[patternEdge.source].node;\n        var patternTarget = patternNodeMap[patternEdge.target].node;\n        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;\n        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;\n      });\n\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        candidateNodeMap[edge.source].outDegree--;\n        candidateNodeMap[edge.target].inDegree--;\n        return \"continue\";\n      }\n    };\n\n    for (var e = candidateEdgeNum - 1; e >= 0; e--) {\n      var state_2 = _loop_5(e);\n\n      if (state_2 === \"break\") break;\n    } // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\n\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n\n    candidateGraph.edges = candidateEdges;\n    var lengthsToCandidate = dijkstra(candidateGraph, candidateGraph.nodes[0].id, false).length;\n    Object.keys(lengthsToCandidate).reverse().forEach(function (targetId) {\n      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return; // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\n\n      if (lengthsToCandidate[targetId] === Infinity) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n        return;\n      } // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\n\n\n      var nLabel = nodeMap[targetId].node[nodeLabelProp];\n\n      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n      }\n    });\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n\n    var degreeChanged = true;\n    var loopCount = 0;\n\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false; // candidate 度数不足，删去该图\n\n      var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;\n\n      if (condition) {\n        candidateGraphInvalid = true;\n        break;\n      } // candidate label 个数不足，删去该图\n\n\n      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {\n        candidateGraphInvalid = true;\n        break;\n      } // prune6：去除度数过小的节点\n\n\n      var currentCandidateNodeNum = candidateGraph.nodes.length;\n\n      for (var o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        var cgNode = candidateGraph.nodes[o];\n        var nodeDegree = candidateNodeMap[cgNode.id].degree;\n        var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;\n        var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;\n        var cNodeLabel = cgNode[nodeLabelProp];\n\n        var _e = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap),\n            minPatternNodeLabelDegree = _e.minPatternNodeLabelDegree,\n            minPatternNodeLabelInDegree = _e.minPatternNodeLabelInDegree,\n            minPatternNodeLabelOutDegree = _e.minPatternNodeLabelOutDegree;\n\n        var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;\n\n        if (deleteCondition) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--; // 节点 label 个数不足\n\n          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n\n      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break; // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\n\n      candidateEdgeNum = candidateEdges.length;\n\n      for (var y = candidateEdgeNum - 1; y >= 0; y--) {\n        var cedge = candidateEdges[y];\n\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          var edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n\n          if (candidateNodeMap[cedge.source]) {\n            candidateNodeMap[cedge.source].degree--;\n            candidateNodeMap[cedge.source].outDegree--;\n          }\n\n          if (candidateNodeMap[cedge.target]) {\n            candidateNodeMap[cedge.target].degree--;\n            candidateNodeMap[cedge.target].inDegree--;\n          } // 边 label 数量不足\n\n\n          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n\n          degreeChanged = true;\n        }\n      }\n\n      loopCount++;\n    }\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    } // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\n\n\n    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n  };\n\n  for (var i = candidateGraphNum - 1; i >= 0; i--) {\n    var state_1 = _loop_2(i);\n\n    if (state_1 === \"break\") break;\n  } // 此时已经生成的多个 candidateGraphs，可能有重复\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\n\n\n  var currentLength = candidateGraphs.length;\n\n  var _loop_3 = function _loop_3(i) {\n    var cg1 = candidateGraphs[i];\n    var cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n\n    cg1.edges.forEach(function (edge) {\n      var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;else cg1EdgeMap[key]++;\n    });\n\n    var _loop_6 = function _loop_6(j) {\n      var cg2 = candidateGraphs[j];\n      var cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n\n      cg2.edges.forEach(function (edge) {\n        var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;else cg2EdgeMap[key]++;\n      });\n      var same = true;\n\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(function (key) {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    };\n\n    for (var j = currentLength - 1; j > i; j--) {\n      _loop_6(j);\n    }\n\n    currentLength = candidateGraphs.length;\n  };\n\n  for (var i = 0; i <= currentLength - 1; i++) {\n    _loop_3(i);\n  }\n\n  return candidateGraphs;\n};\n\nexport default GADDI;","map":{"version":3,"names":["__spreadArray","floydWarshall","gSpan","dijkstra","uniqueId","findKNeighborUnits","graphData","spm","nodeLabelProp","k","units","nodes","forEach","row","i","push","findKNeighborUnit","unitNodeIdxs","neighbors","labelCountMap","v","j","label","count","dists","Object","keys","sort","a","b","nodeIdx","nodeId","id","nodeIdxs","neighborNum","length","nodeLabelCountMap","findNodePairsRandomly","nodeNum","maxNodePairNum","kNeighborUnits","nodePairNumEachNode","Math","ceil","nodePairMap","foundNodePairCount","unit","nodePairForICount","outerLoopCount","oidx","floor","random","innerLoopCount","concat","start","end","distance","gap","getIntersectNeighborInducedGraph","neighborUnits","cachedInducedGraphMap","key","_a","_b","edges","pair","startUnitNodeIds","endUnitNodeIds","endSet","Set","intersect","filter","x","has","intersectIdMap","intersectLength","node","edge","source","target","getMatchedCount","graph","structure","edgeLabelProp","nodeMap","e","sourceLabel","targetLabel","strNodeLabel1","strNodeLabel2","strEdgeLabel","findRepresentStructure","matchedCountMap","structureNum","structures","maxOffset","Infinity","representClusterType","_loop_1","countMapI","sortedGraphKeys","groupNum","clusters","graphs","totalCount","aveCount","aveIntraDist","aveCounts","graphsInCluster","aveIntraPerCluster","graphsNum","graphKey1","graph1Count","graphKey2","abs","aveInterDist","aveCount1","aveCount2","offset","structureCountMap","getNodeMaps","nodeLabelMap","idx","degree","inDegree","outDegree","getEdgeMaps","edgeMap","edgeLabelMap","sourceNode","targetNode","getSpmMap","directed","map","iId","jId","dist","getNDSDist","node1","node2","spDist","cachedNDSMap","cachedInterInducedGraph","interInducedGraph","undefined","pairMap","stashPatternNodeLabelDegreeMap","minPatternNodeLabelDegreeMap","neighborLabel","patternNodeMap","patternNodeLabelMap","_c","minPatternNodeLabelDegree","minPatternNodeLabelInDegree","minPatternNodeLabelOutDegree","patternNodeWithLabel","patternNodeDegree","patternNodeInDegree","patternNodeOutDegree","GADDI","pattern","patternSpm","spmMap","patternSpmMap","patternEdgeLabelMap","patternSpmSpread","max","apply","patternKNeighborUnits","min","nodePairsMap","intGMap","top","minSupport","minNodeNum","maxNodeNum","params","freStructures","slice","subStructureCount","_d","dsG","ndsDist","beginPNode","candidates","maxNodeNumWithSameLabel","pLabel","nodesWithSameLabel","patternIntGraphMap","patternNDSDist","patternNDSDistMap","patternSpDist","patternSpDistBack","label2","maxDist","patternNodesWithLabel2","patternNodePairMap","nodeWithLabel2","distBack","currentPatternNDSDistArray","patternIntGraph","candidatesNum","_loop_4","m","cNode","graphNeighborUnit","graphNeighborUnitCountMap","patternLabel2Num","splice","prune2Invalid","n","cNodePairMap","neighborNode","currentNDSDistArray","intGraph","prune3Invalid","candidateGraphs","candidate","lengthNeighborUnit","neighborNodes","unmatched","distToCandidate","maxDistWithLabelInPattern","keyBack","distFromCandidate","maxBackDistWithLabelInPattern","ndsToCandidate","patternKey","minNdsWithLabelInPattern","undirectedLengthsToBeginPNode","undirectedLengthsToBeginPNodeLabelMap","nodeLabel","candidateGraphNum","_loop_2","candidateGraph","candidateNodeLabelCountMap","candidateNodeMap","q","cNodeLabel","candidateEdges","edgeLabelCountMap","pattenrEdgeLabelNum","prunedByEdgeLabel","label_1","candidateEdgeNum","candidateGraphInvalid","_loop_5","edgeLabel","patternEdgesWithLabel","edgeMatched","patternEdge","patternSource","patternTarget","state_2","lengthsToCandidate","reverse","targetId","targetNodeLabel","indexOf","nLabel","degreeChanged","loopCount","condition","currentCandidateNodeNum","o","cgNode","nodeDegree","nodeInDegree","nodeOutDegree","_e","deleteCondition","y","cedge","state_1","currentLength","_loop_3","cg1","cg1EdgeMap","_loop_6","cg2","cg2EdgeMap","same"],"sources":["/Users/wawalike/Desktop/ggProject/node_modules/@antv/algorithm/es/gaddi.js"],"sourcesContent":["import { __spreadArray } from \"tslib\";\nimport floydWarshall from './floydWarshall';\nimport gSpan from './gSpan/gSpan';\nimport dijkstra from './dijkstra';\nimport { uniqueId } from './util';\n/**\n * 为 graphData 中每个节点生成邻居单元数组\n * @param graphData\n * @param spm\n * @param nodeLabelProp\n * @param k k-近邻\n */\n\nvar findKNeighborUnits = function findKNeighborUnits(graphData, spm, nodeLabelProp, k) {\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (k === void 0) {\n    k = 2;\n  }\n\n  var units = [];\n  var nodes = graphData.nodes;\n  spm.forEach(function (row, i) {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\n\nvar findKNeighborUnit = function findKNeighborUnit(nodes, row, i, nodeLabelProp, k) {\n  var unitNodeIdxs = [i];\n  var neighbors = [];\n  var labelCountMap = {};\n  row.forEach(function (v, j) {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      var label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = {\n        count: 1,\n        dists: [v]\n      };else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  }); // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\n\n  Object.keys(labelCountMap).forEach(function (label) {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort(function (a, b) {\n      return a - b;\n    });\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors: neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap\n  };\n};\n/**\n * 随机寻找点对，满足距离小于 k\n * @param k 参数 k，表示 k-近邻\n * @param nodeNum 参数 length\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\n * @param spm 最短路径矩阵\n */\n\n\nvar findNodePairsRandomly = function findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm) {\n  // 每个节点需要随机找出的点对数\n  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  var nodePairMap = {};\n  var foundNodePairCount = 0; // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\n\n  kNeighborUnits.forEach(function (unit, i) {\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\n    var nodePairForICount = 0;\n    var outerLoopCount = 0;\n    var neighbors = unit.nodeIdxs; // the first one is the center node\n\n    var neighborNum = unit.neighborNum - 1;\n\n    while (nodePairForICount < nodePairNumEachNode) {\n      // 另一端节点在节点数组中的的 index\n      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      var innerLoopCount = 0; // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\n\n      while (nodePairMap[\"\".concat(i, \"-\").concat(oidx)] || nodePairMap[\"\".concat(oidx, \"-\").concat(i)]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n      }\n\n      if (innerLoopCount < 2 * nodeNum) {\n        // 未达到最大循环次数，说明找到了合适的另一端\n        nodePairMap[\"\".concat(i, \"-\").concat(oidx)] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx]\n        };\n        nodePairForICount++;\n        foundNodePairCount++; // 如果当前找到的点对数量达到了上限，返回结果\n\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n    } // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\n\n\n    if (nodePairForICount < nodePairNumEachNode) {\n      var gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n/**\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\n * @param neighborUnits 每个节点的邻居元数组\n * @param graphData 原图数据\n * @param edgeMap 边的 map，方便检索\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\n */\n\n\nvar getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {\n  var nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(function (key) {\n    var _a, _b;\n\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = {\n      nodes: [],\n      edges: []\n    };\n    var pair = nodePairMap[key];\n    var startUnitNodeIds = (_a = neighborUnits[pair.start]) === null || _a === void 0 ? void 0 : _a.nodeIdxs;\n    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\n\n    var endSet = new Set(endUnitNodeIds);\n    var intersect = startUnitNodeIds.filter(function (x) {\n      return endSet.has(x);\n    }); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\n\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\n\n    var intersectIdMap = {};\n    var intersectLength = intersect.length;\n\n    for (var i = 0; i < intersectLength; i++) {\n      var node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\n\n      intersectIdMap[node.id] = true;\n    } // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\n\n\n    graphData.edges.forEach(function (edge) {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n/**\n * 计算 strcutre 在 graph 上的匹配数量\n * @param graph 图数据\n * @param structure 目前支持只有两个节点一条边的最简单结构\n * @param nodeLabelProp 节点类型字段名\n * @param edgeLabelProp 边类型字段名\n */\n\n\nvar getMatchedCount = function getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp) {\n  var _a, _b;\n\n  var nodeMap = {};\n  graph.nodes.forEach(function (node) {\n    nodeMap[node.id] = node;\n  });\n  var count = 0;\n  if (!((_a = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a === void 0 ? void 0 : _a.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2) return 0;\n  graph.edges.forEach(function (e) {\n    var sourceLabel = nodeMap[e.source][nodeLabelProp];\n    var targetLabel = nodeMap[e.target][nodeLabelProp];\n    var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];\n    var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];\n    var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n\n    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {\n      count++;\n    }\n  });\n  return count;\n};\n/**\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\n * @param structures\n */\n\n\nvar findRepresentStructure = function findRepresentStructure(matchedCountMap, structureNum, structures) {\n  var maxOffset = Infinity,\n      representClusterType = 0;\n\n  var _loop_1 = function _loop_1(i) {\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\n    var countMapI = matchedCountMap[i]; // 按照 value 为该组排序，生成 keys 的数组：\n\n    var sortedGraphKeys = Object.keys(countMapI).sort(function (a, b) {\n      return countMapI[a] - countMapI[b];\n    }); // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\n\n    var groupNum = 10;\n    var clusters = []; // 总共有 groupNum 个项\n\n    sortedGraphKeys.forEach(function (key, j) {\n      if (!clusters[j % groupNum]) clusters[j % groupNum] = {\n        graphs: [],\n        totalCount: 0,\n        aveCount: 0\n      };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    }); // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\n\n    var aveIntraDist = 0; // 该类的类内平均值\n\n    var aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\n\n    clusters.forEach(function (graphsInCluster) {\n      // 类内均值\n      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount); // 对于每类，计算类内间距平均值\n\n      var aveIntraPerCluster = 0;\n      var graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach(function (graphKey1, j) {\n        var graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach(function (graphKey2, k) {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n    aveIntraDist /= clusters.length; // 用类内均值计算类间距\n\n    var aveInterDist = 0; // 类间间距平均值\n\n    aveCounts.forEach(function (aveCount1, j) {\n      aveCounts.forEach(function (aveCount2, k) {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;\n    }); // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\n\n    var offset = aveInterDist - aveIntraDist;\n\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  };\n\n  for (var i = 0; i < structureNum; i++) {\n    _loop_1(i);\n  }\n\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType]\n  };\n};\n\nvar getNodeMaps = function getNodeMaps(nodes, nodeLabelProp) {\n  var nodeMap = {},\n      nodeLabelMap = {};\n  nodes.forEach(function (node, i) {\n    nodeMap[node.id] = {\n      idx: i,\n      node: node,\n      degree: 0,\n      inDegree: 0,\n      outDegree: 0\n    };\n    var label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return {\n    nodeMap: nodeMap,\n    nodeLabelMap: nodeLabelMap\n  };\n};\n\nvar getEdgeMaps = function getEdgeMaps(edges, edgeLabelProp, nodeMap) {\n  var edgeMap = {},\n      edgeLabelMap = {};\n  edges.forEach(function (edge, i) {\n    edgeMap[\"\".concat(uniqueId)] = {\n      idx: i,\n      edge: edge\n    };\n    var label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n    var sourceNode = nodeMap[edge.source];\n\n    if (sourceNode) {\n      sourceNode.degree++;\n      sourceNode.outDegree++;\n    }\n\n    var targetNode = nodeMap[edge.target];\n\n    if (targetNode) {\n      targetNode.degree++;\n      targetNode.inDegree++;\n    }\n  });\n  return {\n    edgeMap: edgeMap,\n    edgeLabelMap: edgeLabelMap\n  };\n};\n/**\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\n * @param nodes\n * @param spm\n * @param directed\n */\n\n\nvar getSpmMap = function getSpmMap(nodes, spm, directed) {\n  var length = spm.length;\n  var map = {};\n  spm.forEach(function (row, i) {\n    var start = directed ? 0 : i + 1;\n    var iId = nodes[i].id;\n\n    for (var j = start; j < length; j++) {\n      if (i === j) continue;\n      var jId = nodes[j].id;\n      var dist = row[j];\n      map[\"\".concat(iId, \"-\").concat(jId)] = dist;\n      if (!directed) map[\"\".concat(jId, \"-\").concat(iId)] = dist;\n    }\n  });\n  return map;\n};\n/**\n * 计算一对节点（node1，node2）的 NDS 距离\n * @param graph 原图数据\n * @param node1\n * @param node2\n */\n\n\nvar getNDSDist = function getNDSDist(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {\n  var _a;\n\n  var key = \"\".concat(node1.id, \"-\").concat(node2.id);\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined; // 若没有缓存相交邻居诱导子图，计算\n\n  if (!interInducedGraph) {\n    var pairMap = (_a = {}, _a[key] = {\n      start: nodeMap[node1.id].idx,\n      end: nodeMap[node2.id].idx,\n      distance: spDist\n    }, _a);\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n/**\n * 计算 pattern 上绩点的度数并存储到 minPatternNodeLabelDegreeMap\n */\n\n\nvar stashPatternNodeLabelDegreeMap = function stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {\n  var _a, _b, _c;\n\n  var minPatternNodeLabelDegree = (_a = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a === void 0 ? void 0 : _a.degree;\n  var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;\n  var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;\n\n  if (minPatternNodeLabelDegreeMap[neighborLabel] === undefined) {\n    minPatternNodeLabelDegree = Infinity;\n    minPatternNodeLabelInDegree = Infinity;\n    minPatternNodeLabelOutDegree = Infinity;\n    patternNodeLabelMap[neighborLabel].forEach(function (patternNodeWithLabel) {\n      var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n      if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;\n      var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;\n      if (minPatternNodeLabelInDegree > patternNodeInDegree) minPatternNodeLabelInDegree = patternNodeInDegree;\n      var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;\n      if (minPatternNodeLabelOutDegree > patternNodeOutDegree) minPatternNodeLabelOutDegree = patternNodeOutDegree;\n    });\n    minPatternNodeLabelDegreeMap[neighborLabel] = {\n      degree: minPatternNodeLabelDegree,\n      inDegree: minPatternNodeLabelInDegree,\n      outDegree: minPatternNodeLabelOutDegree\n    };\n  }\n\n  return {\n    minPatternNodeLabelDegree: minPatternNodeLabelDegree,\n    minPatternNodeLabelInDegree: minPatternNodeLabelInDegree,\n    minPatternNodeLabelOutDegree: minPatternNodeLabelOutDegree\n  };\n};\n/**\n * GADDI 模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\n\n\nvar GADDI = function GADDI(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\n  var _a;\n\n  if (directed === void 0) {\n    directed = false;\n  }\n\n  if (nodeLabelProp === void 0) {\n    nodeLabelProp = 'cluster';\n  }\n\n  if (edgeLabelProp === void 0) {\n    edgeLabelProp = 'cluster';\n  }\n\n  if (!graphData || !graphData.nodes) return; // 分为三步：\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\n  // 1. 处理原图 graphData。再分为 1~5 小步\n  // 2. 匹配\n  // console.log(\"----- stage-pre: preprocessing -------\");\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\n\n  var nodeNum = graphData.nodes.length;\n  if (!nodeNum) return; // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n\n  var spm = floydWarshall(graphData, directed); // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n\n  var patternSpm = floydWarshall(pattern, directed); // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n\n  var spmMap = getSpmMap(graphData.nodes, spm, directed); // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n\n  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed); // console.log(\"----- stage-pre.5: establish maps -------\");\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\n\n  var _b = getNodeMaps(graphData.nodes, nodeLabelProp),\n      nodeMap = _b.nodeMap,\n      nodeLabelMap = _b.nodeLabelMap;\n\n  var _c = getNodeMaps(pattern.nodes, nodeLabelProp),\n      patternNodeMap = _c.nodeMap,\n      patternNodeLabelMap = _c.nodeLabelMap; // 计算节点度数\n\n\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap; // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\n\n  var patternSpmSpread = [];\n  patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function (row) {\n    patternSpmSpread = patternSpmSpread.concat(row);\n  });\n  if (!length) length = Math.max.apply(Math, __spreadArray(__spreadArray([], patternSpmSpread, false), [2], false));\n  if (!k) k = length; // console.log(\"params\", directed, length, k);\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  // 计算每个节点的 k 邻元集合\n\n  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k); // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // -------- 第一步，处理原图 graphData-------\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\n\n  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);\n  var nodePairsMap = findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm); // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n\n  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData); // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\n\n  var top = 10,\n      minSupport = 1,\n      minNodeNum = 1,\n      maxNodeNum = 4;\n  var params = {\n    graphs: intGMap,\n    nodeLabelProp: nodeLabelProp,\n    edgeLabelProp: edgeLabelProp,\n    minSupport: minSupport,\n    minNodeNum: minNodeNum,\n    maxNodeNum: maxNodeNum,\n    directed: directed\n  }; // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  // 暂时假设生成的 sub structure 都只有一条边\n\n  var freStructures = gSpan(params).slice(0, top); // structureNum 可能小于 top\n\n  var structureNum = freStructures.length; // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\n\n  var matchedCountMap = [];\n  freStructures.forEach(function (structure, i) {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(function (key) {\n      var graph = intGMap[key];\n      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  }); // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\n\n  var _d = findRepresentStructure(matchedCountMap, structureNum, freStructures),\n      dsG = _d.structure,\n      ndsDist = _d.structureCountMap; // -------- 第二步，匹配-------\n  // 2.1 找到从 Q 中的一个节点作为起始节点，寻找 G 中的匹配。这个其实节点的标签可以在 G 中找到最多的节点\n\n\n  var beginPNode = pattern.nodes[0],\n      candidates = [],\n      label = (_a = pattern.nodes[0]) === null || _a === void 0 ? void 0 : _a[nodeLabelProp],\n      maxNodeNumWithSameLabel = -Infinity;\n  pattern.nodes.forEach(function (node) {\n    var pLabel = node[nodeLabelProp];\n    var nodesWithSameLabel = nodeLabelMap[pLabel];\n\n    if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {\n      maxNodeNumWithSameLabel = nodesWithSameLabel.length;\n      candidates = nodesWithSameLabel;\n      label = pLabel;\n      beginPNode = node;\n    }\n  }); // console.log(\"----- stage2: going to find candidates -------\");\n  // 全局缓存，避免重复计算\n\n  var minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\n\n  var patternIntGraphMap = {},\n      patternNDSDist = {},\n      // key 为 node.id-node.id\n  patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\n\n  var patternSpDist = {};\n  var patternSpDistBack = {};\n  Object.keys(patternNodeLabelMap).forEach(function (label2, j) {\n    patternSpDist[label2] = [];\n\n    if (directed) {\n      patternSpDistBack[label2] = [];\n    }\n\n    var maxDist = -Infinity;\n    var patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    var patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(function (nodeWithLabel2) {\n      var dist = patternSpmMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist\n      };\n\n      if (directed) {\n        var distBack = patternSpmMap[\"\".concat(nodeWithLabel2.id, \"-\").concat(beginPNode.id)];\n        distBack && patternSpDistBack[label2].push(distBack);\n      }\n    }); // spDist[label2] 按照从小到大排序\n\n    patternSpDist[label2] = patternSpDist[label2].sort(function (a, b) {\n      return a - b;\n    });\n    if (directed) patternSpDistBack[label2] = patternSpDistBack[label2].sort(function (a, b) {\n      return a - b;\n    }); // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\n    // key: node1.id-node2.id\n\n    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap); // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\n\n    var currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(function (key) {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // 缓存过则不需要再次计算\n      }\n\n      var patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    }); // 根据值为 currentPatternNDSDist 从大到小排序\n\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function (a, b) {\n      return b - a;\n    });\n    patternNDSDistMap[\"\".concat(beginPNode.id, \"-\").concat(label2)] = currentPatternNDSDistArray;\n    if (label2 === label) return;\n    var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;\n\n    var _loop_4 = function _loop_4(m) {\n      var cNode = candidates[m]; // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\n\n      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      var patternLabel2Num = patternNodeLabelMap[label2].length;\n\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      } // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\n\n\n      var prune2Invalid = false;\n\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      } // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\n\n\n      var cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(function (neighborNode) {\n        var dist = spmMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)];\n        cNodePairMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist\n        };\n      }); // 更新 intGMap\n\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap); // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\n\n      var currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(function (key) {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // 缓存过则不需要再次计算\n        }\n\n        var intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      }); // 根据值为 currentNDSDistArray 从大到小排序\n\n      currentNDSDistArray = currentNDSDistArray.sort(function (a, b) {\n        return b - a;\n      });\n      var prune3Invalid = false;\n\n      for (var n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        return \"continue\";\n      }\n    };\n\n    for (var m = candidatesNum - 1; m >= 0; m--) {\n      _loop_4(m);\n    }\n  });\n  var candidateGraphs = []; // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\n\n  candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function (candidate) {\n    var nodeIdx = nodeMap[candidate.id].idx;\n    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);\n    var neighborNodes = lengthNeighborUnit.neighbors; // 删除不可能找到匹配的邻居点\n\n    var neighborNum = neighborNodes.length;\n    var unmatched = false;\n\n    for (var i = neighborNum - 1; i >= 0; i--) {\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return;\n      }\n\n      var neighborNode = neighborNodes[i];\n      var neighborLabel = neighborNode[nodeLabelProp]; // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\n\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      } // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\n\n\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      var key = \"\".concat(candidate.id, \"-\").concat(neighborNode.id); // prune2.2\n\n      var distToCandidate = spmMap[key];\n      var idx = patternSpDist[neighborLabel].length - 1;\n      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx]; // patternSpDist[neighborLabel] 已经按照从小到大排序\n\n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      if (directed) {\n        var keyBack = \"\".concat(neighborNode.id, \"-\").concat(candidate.id);\n        var distFromCandidate = spmMap[keyBack];\n        idx = patternSpDistBack[neighborLabel].length - 1;\n        var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];\n\n        if (distFromCandidate > maxBackDistWithLabelInPattern) {\n          neighborNodes.splice(i, 1);\n          continue;\n        }\n      } // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\n\n\n      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);\n      var patternKey = \"\".concat(beginPNode.id, \"-\").concat(neighborLabel);\n      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\n\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      } // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\n\n\n      var _a = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap),\n          minPatternNodeLabelDegree = _a.minPatternNodeLabelDegree,\n          minPatternNodeLabelInDegree = _a.minPatternNodeLabelInDegree,\n          minPatternNodeLabelOutDegree = _a.minPatternNodeLabelOutDegree;\n\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n    } // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\n\n\n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes)\n      });\n    }\n  }); // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n\n  var undirectedLengthsToBeginPNode = dijkstra(pattern, beginPNode.id, false).length;\n  var undirectedLengthsToBeginPNodeLabelMap = {};\n\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(function (nodeId) {\n      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function (pLabel) {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function (a, b) {\n        return a - b;\n      });\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  } // 现在 candidateGraphs 里面只有节点，进行边的筛选\n\n\n  var candidateGraphNum = candidateGraphs.length;\n\n  var _loop_2 = function _loop_2(i) {\n    var candidateGraph = candidateGraphs[i];\n    var candidate = candidateGraph.nodes[0];\n    var candidateNodeLabelCountMap = {};\n    var candidateNodeMap = {};\n    candidateGraph.nodes.forEach(function (node, q) {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node: node,\n        degree: 0,\n        inDegree: 0,\n        outDegree: 0\n      };\n      var cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;else candidateNodeLabelCountMap[cNodeLabel]++;\n    }); // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\n\n    var candidateEdges = [];\n    var edgeLabelCountMap = {};\n    graphData.edges.forEach(function (edge) {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n        candidateNodeMap[edge.source].outDegree++;\n        candidateNodeMap[edge.target].inDegree++;\n      }\n    }); // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\n\n    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    var prunedByEdgeLabel = false;\n\n    for (var e = 0; e < pattenrEdgeLabelNum; e++) {\n      var label_1 = Object.keys(patternEdgeLabelMap)[e];\n\n      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    } // 遍历 candidateEdges，进行边的筛选\n\n\n    var candidateEdgeNum = candidateEdges.length; // prune：若边数过少，去除该图\n\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"break\";\n    }\n\n    var candidateGraphInvalid = false;\n\n    var _loop_5 = function _loop_5(e) {\n      var edge = candidateEdges[e];\n      var edgeLabel = edge[edgeLabelProp];\n      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel]; // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\n\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        candidateNodeMap[edge.source].outDegree--;\n        candidateNodeMap[edge.target].inDegree--;\n        return \"continue\";\n      } // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\n\n\n      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n      var edgeMatched = false;\n      patternEdgesWithLabel.forEach(function (patternEdge) {\n        var patternSource = patternNodeMap[patternEdge.source].node;\n        var patternTarget = patternNodeMap[patternEdge.target].node;\n        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;\n        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;\n      });\n\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          return \"break\";\n        }\n\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        candidateNodeMap[edge.source].outDegree--;\n        candidateNodeMap[edge.target].inDegree--;\n        return \"continue\";\n      }\n    };\n\n    for (var e = candidateEdgeNum - 1; e >= 0; e--) {\n      var state_2 = _loop_5(e);\n\n      if (state_2 === \"break\") break;\n    } // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\n\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n\n    candidateGraph.edges = candidateEdges;\n    var lengthsToCandidate = dijkstra(candidateGraph, candidateGraph.nodes[0].id, false).length;\n    Object.keys(lengthsToCandidate).reverse().forEach(function (targetId) {\n      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return; // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\n\n      if (lengthsToCandidate[targetId] === Infinity) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n        return;\n      } // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\n\n\n      var nLabel = nodeMap[targetId].node[nodeLabelProp];\n\n      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n        candidateNodeLabelCountMap[targetNodeLabel]--;\n\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\n          candidateGraphInvalid = true;\n          return;\n        }\n\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n        candidateGraph.nodes.splice(idx, 1);\n        candidateNodeMap[targetId] = undefined;\n      }\n    });\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n\n    var degreeChanged = true;\n    var loopCount = 0;\n\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false; // candidate 度数不足，删去该图\n\n      var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;\n\n      if (condition) {\n        candidateGraphInvalid = true;\n        break;\n      } // candidate label 个数不足，删去该图\n\n\n      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {\n        candidateGraphInvalid = true;\n        break;\n      } // prune6：去除度数过小的节点\n\n\n      var currentCandidateNodeNum = candidateGraph.nodes.length;\n\n      for (var o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        var cgNode = candidateGraph.nodes[o];\n        var nodeDegree = candidateNodeMap[cgNode.id].degree;\n        var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;\n        var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;\n        var cNodeLabel = cgNode[nodeLabelProp];\n\n        var _e = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap),\n            minPatternNodeLabelDegree = _e.minPatternNodeLabelDegree,\n            minPatternNodeLabelInDegree = _e.minPatternNodeLabelInDegree,\n            minPatternNodeLabelOutDegree = _e.minPatternNodeLabelOutDegree;\n\n        var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;\n\n        if (deleteCondition) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--; // 节点 label 个数不足\n\n          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n\n      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break; // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\n\n      candidateEdgeNum = candidateEdges.length;\n\n      for (var y = candidateEdgeNum - 1; y >= 0; y--) {\n        var cedge = candidateEdges[y];\n\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          var edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n\n          if (candidateNodeMap[cedge.source]) {\n            candidateNodeMap[cedge.source].degree--;\n            candidateNodeMap[cedge.source].outDegree--;\n          }\n\n          if (candidateNodeMap[cedge.target]) {\n            candidateNodeMap[cedge.target].degree--;\n            candidateNodeMap[cedge.target].inDegree--;\n          } // 边 label 数量不足\n\n\n          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {\n            candidateGraphInvalid = true;\n            break;\n          }\n\n          degreeChanged = true;\n        }\n      }\n\n      loopCount++;\n    }\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    } // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\n\n\n    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      return \"continue\";\n    }\n  };\n\n  for (var i = candidateGraphNum - 1; i >= 0; i--) {\n    var state_1 = _loop_2(i);\n\n    if (state_1 === \"break\") break;\n  } // 此时已经生成的多个 candidateGraphs，可能有重复\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\n\n\n  var currentLength = candidateGraphs.length;\n\n  var _loop_3 = function _loop_3(i) {\n    var cg1 = candidateGraphs[i];\n    var cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n\n    cg1.edges.forEach(function (edge) {\n      var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;else cg1EdgeMap[key]++;\n    });\n\n    var _loop_6 = function _loop_6(j) {\n      var cg2 = candidateGraphs[j];\n      var cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n\n      cg2.edges.forEach(function (edge) {\n        var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;else cg2EdgeMap[key]++;\n      });\n      var same = true;\n\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(function (key) {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    };\n\n    for (var j = currentLength - 1; j > i; j--) {\n      _loop_6(j);\n    }\n\n    currentLength = candidateGraphs.length;\n  };\n\n  for (var i = 0; i <= currentLength - 1; i++) {\n    _loop_3(i);\n  }\n\n  return candidateGraphs;\n};\n\nexport default GADDI;"],"mappings":"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"},"metadata":{},"sourceType":"module"}