{"ast":null,"code":"import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Line } from './line';\nimport { Geometry } from './geometry';\nexport class Polyline extends Geometry {\n  constructor(points) {\n    super();\n\n    if (points != null) {\n      if (typeof points === 'string') {\n        return Polyline.parse(points);\n      }\n\n      this.points = points.map(p => Point.create(p));\n    } else {\n      this.points = [];\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return Polyline.toStringTag;\n  }\n\n  get start() {\n    if (this.points.length === 0) {\n      return null;\n    }\n\n    return this.points[0];\n  }\n\n  get end() {\n    if (this.points.length === 0) {\n      return null;\n    }\n\n    return this.points[this.points.length - 1];\n  }\n\n  scale(sx, sy, origin = new Point()) {\n    this.points.forEach(p => p.scale(sx, sy, origin));\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.points.forEach(p => p.rotate(angle, origin));\n    return this;\n  }\n\n  translate(dx, dy) {\n    const t = Point.create(dx, dy);\n    this.points.forEach(p => p.translate(t.x, t.y));\n    return this;\n  }\n\n  bbox() {\n    if (this.points.length === 0) {\n      return new Rectangle();\n    }\n\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n    const points = this.points;\n\n    for (let i = 0, ii = points.length; i < ii; i += 1) {\n      const point = points[i];\n      const x = point.x;\n      const y = point.y;\n      if (x < x1) x1 = x;\n      if (x > x2) x2 = x;\n      if (y < y1) y1 = y;\n      if (y > y2) y2 = y;\n    }\n\n    return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n  }\n\n  closestPoint(p) {\n    const cpLength = this.closestPointLength(p);\n    return this.pointAtLength(cpLength);\n  }\n\n  closestPointLength(p) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return 0;\n    }\n\n    let length = 0;\n    let cpLength = 0;\n    let minSqrDistance = Infinity;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const line = new Line(points[i], points[i + 1]);\n      const lineLength = line.length();\n      const cpNormalizedLength = line.closestPointNormalizedLength(p);\n      const cp = line.pointAt(cpNormalizedLength);\n      const sqrDistance = cp.squaredDistance(p);\n\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance;\n        cpLength = length + cpNormalizedLength * lineLength;\n      }\n\n      length += lineLength;\n    }\n\n    return cpLength;\n  }\n\n  closestPointNormalizedLength(p) {\n    const cpLength = this.closestPointLength(p);\n\n    if (cpLength === 0) {\n      return 0;\n    }\n\n    const length = this.length();\n\n    if (length === 0) {\n      return 0;\n    }\n\n    return cpLength / length;\n  }\n\n  closestPointTangent(p) {\n    const cpLength = this.closestPointLength(p);\n    return this.tangentAtLength(cpLength);\n  }\n\n  containsPoint(p) {\n    if (this.points.length === 0) {\n      return false;\n    }\n\n    const ref = Point.clone(p);\n    const x = ref.x;\n    const y = ref.y;\n    const points = this.points;\n    const count = points.length;\n    let startIndex = count - 1;\n    let intersectionCount = 0;\n\n    for (let endIndex = 0; endIndex < count; endIndex += 1) {\n      const start = points[startIndex];\n      const end = points[endIndex];\n\n      if (ref.equals(start)) {\n        return true;\n      }\n\n      const segment = new Line(start, end);\n\n      if (segment.containsPoint(p)) {\n        return true;\n      } // do we have an intersection?\n\n\n      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          const rayEnd = new Point(x + xDifference, y); // right\n\n          const ray = new Line(p, rayEnd);\n\n          if (segment.intersectsWithLine(ray)) {\n            // an intersection was detected to the right of `p`\n            intersectionCount += 1;\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\n      } // move to check the next polyline segment\n\n\n      startIndex = endIndex;\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return intersectionCount % 2 === 1;\n  }\n\n  intersectsWithLine(line) {\n    const intersections = [];\n\n    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      const int = line.intersectsWithLine(new Line(a, b));\n\n      if (int) {\n        intersections.push(int);\n      }\n    }\n\n    return intersections.length > 0 ? intersections : null;\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      const line = new Line(a, b);\n\n      if (line.isDifferentiable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  length() {\n    let len = 0;\n\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      len += a.distance(b);\n    }\n\n    return len;\n  }\n\n  pointAt(ratio) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    if (count === 1) {\n      return points[0].clone();\n    }\n\n    if (ratio <= 0) {\n      return points[0].clone();\n    }\n\n    if (ratio >= 1) {\n      return points[count - 1].clone();\n    }\n\n    const total = this.length();\n    const length = total * ratio;\n    return this.pointAtLength(length);\n  }\n\n  pointAtLength(length) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    if (count === 1) {\n      return points[0].clone();\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    let tmp = 0;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const a = points[index];\n      const b = points[index + 1];\n      const l = new Line(a, b);\n      const d = a.distance(b);\n\n      if (length <= tmp + d) {\n        return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));\n      }\n\n      tmp += d;\n    }\n\n    const lastPoint = fromStart ? points[count - 1] : points[0];\n    return lastPoint.clone();\n  }\n\n  tangentAt(ratio) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return null;\n    }\n\n    if (ratio < 0) {\n      ratio = 0; // eslint-disable-line\n    }\n\n    if (ratio > 1) {\n      ratio = 1; // eslint-disable-line\n    }\n\n    const total = this.length();\n    const length = total * ratio;\n    return this.tangentAtLength(length);\n  }\n\n  tangentAtLength(length) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    let lastValidLine;\n    let tmp = 0;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const a = points[index];\n      const b = points[index + 1];\n      const l = new Line(a, b);\n      const d = a.distance(b);\n\n      if (l.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= tmp + d) {\n          return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));\n        }\n\n        lastValidLine = l;\n      }\n\n      tmp += d;\n    }\n\n    if (lastValidLine) {\n      const ratio = fromStart ? 1 : 0;\n      return lastValidLine.tangentAt(ratio);\n    }\n\n    return null;\n  }\n\n  simplify( // TODO: Accept startIndex and endIndex to specify where to start and end simplification\n  options = {}) {\n    const points = this.points; // we need at least 3 points\n\n    if (points.length < 3) {\n      return this;\n    }\n\n    const threshold = options.threshold || 0; // start at the beginning of the polyline and go forward\n\n    let currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex;\n      const middleIndex = currentIndex + 1;\n      const lastIndex = currentIndex + 2;\n      const firstPoint = points[firstIndex];\n      const middlePoint = points[middleIndex];\n      const lastPoint = points[lastIndex];\n      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\n      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\n      const closestPointDistance = closestPoint.distance(middlePoint);\n\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1; //    = (point after first point becomes first point)\n      }\n    } // `points` array was modified in-place\n\n\n    return this;\n  }\n\n  toHull() {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return new Polyline();\n    } // Step 1: find the starting point -- point with\n    // the lowest y (if equality, highest x).\n\n\n    let startPoint = points[0];\n\n    for (let i = 1; i < count; i += 1) {\n      if (points[i].y < startPoint.y) {\n        startPoint = points[i];\n      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n        startPoint = points[i];\n      }\n    } // Step 2: sort the list of points by angle between line\n    // from start point to current point and the x-axis (theta).\n    // Step 2a: create the point records = [point, originalIndex, angle]\n\n\n    const sortedRecords = [];\n\n    for (let i = 0; i < count; i += 1) {\n      let angle = startPoint.theta(points[i]);\n\n      if (angle === 0) {\n        // Give highest angle to start point.\n        // The start point will end up at end of sorted list.\n        // The start point will end up at beginning of hull points list.\n        angle = 360;\n      }\n\n      sortedRecords.push([points[i], i, angle]);\n    } // Step 2b: sort the list in place\n\n\n    sortedRecords.sort((record1, record2) => {\n      let ret = record1[2] - record2[2];\n\n      if (ret === 0) {\n        ret = record2[1] - record1[1];\n      }\n\n      return ret;\n    }); // Step 2c: duplicate start record from the top of\n    // the stack to the bottom of the stack.\n\n    if (sortedRecords.length > 2) {\n      const startPoint = sortedRecords[sortedRecords.length - 1];\n      sortedRecords.unshift(startPoint);\n    } // Step 3\n    // ------\n    // Step 3a: go through sorted points in order and find those with\n    // right turns, and we want to get our results in clockwise order.\n    // Dictionary of points with left turns - cannot be on the hull.\n\n\n    const insidePoints = {}; // Stack of records with right turns - hull point candidates.\n\n    const hullRecords = [];\n\n    const getKey = record => `${record[0].toString()}@${record[1]}`;\n\n    while (sortedRecords.length !== 0) {\n      const currentRecord = sortedRecords.pop();\n      const currentPoint = currentRecord[0]; // Check if point has already been discarded.\n\n      if (insidePoints[getKey(currentRecord)]) {\n        continue;\n      }\n\n      let correctTurnFound = false;\n\n      while (!correctTurnFound) {\n        if (hullRecords.length < 2) {\n          // Not enough points for comparison, just add current point.\n          hullRecords.push(currentRecord);\n          correctTurnFound = true;\n        } else {\n          const lastHullRecord = hullRecords.pop();\n          const lastHullPoint = lastHullRecord[0];\n          const secondLastHullRecord = hullRecords.pop();\n          const secondLastHullPoint = secondLastHullRecord[0];\n          const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n          if (crossProduct < 0) {\n            // Found a right turn.\n            hullRecords.push(secondLastHullRecord);\n            hullRecords.push(lastHullRecord);\n            hullRecords.push(currentRecord);\n            correctTurnFound = true;\n          } else if (crossProduct === 0) {\n            // the three points are collinear\n            // three options:\n            // there may be a 180 or 0 degree angle at lastHullPoint\n            // or two of the three points are coincident\n            // we have to take rounding errors into account\n            const THRESHOLD = 1e-10;\n            const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\n            if (Math.abs(angleBetween - 180) < THRESHOLD) {\n              // rouding around 180 to 180\n              // if the cross product is 0 because the angle is 180 degrees\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n              hullRecords.push(secondLastHullRecord); // do not do anything with current point\n              // correct turn not found\n            } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n              // if the cross product is 0 because two points are the same\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n              hullRecords.push(secondLastHullRecord); // do not do anything with current point\n              // correct turn not found\n            } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n              // rounding around 0 and 360 to 0\n              // if the cross product is 0 because the angle is 0 degrees\n              // remove last hull point from hull BUT do not discard it\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord); // put last hull point back into the sorted point records list\n\n              sortedRecords.push(lastHullRecord); // we are switching the order of the 0deg and 180deg points\n              // correct turn not found\n            }\n          } else {\n            // found a left turn\n            // discard last hull point (add to insidePoints)\n            // insidePoints.unshift(lastHullPoint);\n            insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)\n\n            hullRecords.push(secondLastHullRecord); // do not do anything with current point\n            // correct turn not found\n          }\n        }\n      }\n    } // At this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n    // Step 3b: remove duplicated startPointRecord from the end of the array\n\n\n    if (hullRecords.length > 2) {\n      hullRecords.pop();\n    } // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n\n\n    let lowestHullIndex; // the lowest originalIndex on the hull\n\n    let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\n    for (let i = 0, n = hullRecords.length; i < n; i += 1) {\n      const currentHullIndex = hullRecords[i][1];\n\n      if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n        lowestHullIndex = currentHullIndex;\n        indexOfLowestHullIndexRecord = i;\n      }\n    }\n\n    let hullPointRecordsReordered = [];\n\n    if (indexOfLowestHullIndexRecord > 0) {\n      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);\n      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);\n      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n    } else {\n      hullPointRecordsReordered = hullRecords;\n    }\n\n    const hullPoints = [];\n\n    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {\n      hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return new Polyline(hullPoints);\n  }\n\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n\n    if (p.points.length !== this.points.length) {\n      return false;\n    }\n\n    return p.points.every((a, i) => a.equals(this.points[i]));\n  }\n\n  clone() {\n    return new Polyline(this.points.map(p => p.clone()));\n  }\n\n  toJSON() {\n    return this.points.map(p => p.toJSON());\n  }\n\n  serialize() {\n    return this.points.map(p => `${p.x}, ${p.y}`).join(' ');\n  }\n\n}\n\n(function (Polyline) {\n  Polyline.toStringTag = `X6.Geometry.${Polyline.name}`;\n\n  function isPolyline(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Polyline) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const polyline = instance;\n\n    if ((tag == null || tag === Polyline.toStringTag) && typeof polyline.toHull === 'function' && typeof polyline.simplify === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Polyline.isPolyline = isPolyline;\n})(Polyline || (Polyline = {}));\n\n(function (Polyline) {\n  function parse(svgString) {\n    const str = svgString.trim();\n\n    if (str === '') {\n      return new Polyline();\n    }\n\n    const points = [];\n    const coords = str.split(/\\s*,\\s*|\\s+/);\n\n    for (let i = 0, ii = coords.length; i < ii; i += 2) {\n      points.push({\n        x: +coords[i],\n        y: +coords[i + 1]\n      });\n    }\n\n    return new Polyline(points);\n  }\n\n  Polyline.parse = parse;\n})(Polyline || (Polyline = {}));","map":{"version":3,"mappings":"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","names":["Point","Rectangle","Line","Geometry","Polyline","constructor","points","parse","map","p","create","Symbol","toStringTag","start","length","end","scale","sx","sy","origin","forEach","rotate","angle","translate","dx","dy","t","x","y","bbox","x1","Infinity","x2","y1","y2","i","ii","point","closestPoint","cpLength","closestPointLength","pointAtLength","count","minSqrDistance","line","lineLength","cpNormalizedLength","closestPointNormalizedLength","cp","pointAt","sqrDistance","squaredDistance","closestPointTangent","tangentAtLength","containsPoint","ref","clone","startIndex","intersectionCount","endIndex","equals","segment","xDifference","rayEnd","ray","intersectsWithLine","intersections","n","a","b","int","push","isDifferentiable","len","distance","ratio","total","fromStart","tmp","index","l","d","lastPoint","tangentAt","lastValidLine","simplify","options","threshold","currentIndex","firstIndex","middleIndex","lastIndex","firstPoint","middlePoint","chord","closestPointDistance","splice","toHull","startPoint","sortedRecords","theta","sort","record1","record2","ret","unshift","insidePoints","hullRecords","getKey","record","toString","currentRecord","pop","currentPoint","correctTurnFound","lastHullRecord","lastHullPoint","secondLastHullRecord","secondLastHullPoint","crossProduct","cross","THRESHOLD","angleBetween","Math","abs","lowestHullIndex","indexOfLowestHullIndexRecord","currentHullIndex","undefined","hullPointRecordsReordered","newFirstChunk","slice","newSecondChunk","concat","hullPoints","every","toJSON","serialize","join","name","isPolyline","instance","tag","polyline","svgString","str","trim","coords","split"],"sourceRoot":"","sources":["../../src/geometry/polyline.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}