{"ast":null,"code":"import { defineComponent, onMounted } from 'vue';\nimport G6 from '@antv/g6';\nexport default defineComponent({\n  name: 'antV',\n\n  setup() {\n    onMounted(() => {\n      /**\n       * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n       */\n      // let addedCount = 0;\n      // // Register a custom behavior: add a node when user click the blank part of canvas\n      // G6.registerBehavior('click-add-node', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         // The event is canvas:click, the responsing function is onClick\n      //         return {\n      //         'canvas:click': 'onClick',\n      //         };\n      //     },\n      //     // Click event\n      //     onClick(ev) {\n      //         const self = this;\n      //         const graph = self.graph;\n      //         // Add a new node\n      //         graph.addItem('node', {\n      //         x: ev.canvasX,\n      //         y: ev.canvasY,\n      //         id: `node-${addedCount}`, // Generate the unique id\n      //         });\n      //         addedCount++;\n      //     },\n      // });\n      // // Register a custom behavior: click two end nodes to add an edge\n      // G6.registerBehavior('click-add-edge', {\n      //     // Set the events and the corresponding responsing function for this behavior\n      //     getEvents() {\n      //         return {\n      //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n      //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n      //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n      //         };\n      //     },\n      //     // The responsing function for node:click defined in getEvents\n      //     onClick(ev) {\n      //         // console.log(1111)\n      //         // console.log(this)\n      //         const self = this;\n      //         const node = ev.item;\n      //         const graph = self.graph;\n      //         // The position where the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         const model = node.getModel();\n      //         if (self.addingEdge && self.edge) {\n      //         graph.updateItem(self.edge, {\n      //             target: model.id,\n      //         });\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         } else {\n      //         // Add anew edge, the end node is the current node user clicks\n      //         self.edge = graph.addItem('edge', {\n      //             source: model.id,\n      //             target: model.id,\n      //         });\n      //         self.addingEdge = true;\n      //         }\n      //     },\n      //     // The responsing function for mousemove defined in getEvents\n      //     onMousemove(ev) {\n      //         const self = this;\n      //         // The current position the mouse clicks\n      //         const point = { x: ev.x, y: ev.y };\n      //         if (self.addingEdge && self.edge) {\n      //         // Update the end node to the current node the mouse clicks\n      //         self.graph.updateItem(self.edge, {\n      //             target: point,\n      //         });\n      //         }\n      //     },\n      //     // The responsing function for edge:click defined in getEvents\n      //     onEdgeClick(ev) {\n      //         const self = this;\n      //         const currentEdge = ev.item;\n      //         if (self.addingEdge && self.edge === currentEdge) {\n      //         self.graph.removeItem(self.edge);\n      //         self.edge = null;\n      //         self.addingEdge = false;\n      //         }\n      //     },\n      // });\n      // // Initial data\n      // const data = {\n      //     nodes: [\n      //         {\n      //         id: 'node1',\n      //         x: 100,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node2',\n      //         x: 300,\n      //         y: 200,\n      //         },\n      //         {\n      //         id: 'node3',\n      //         x: 300,\n      //         y: 300,\n      //         },\n      //     ],\n      //     edges: [\n      //         {\n      //         id: 'edge1',\n      //         target: 'node2',\n      //         source: 'node1',\n      //         },\n      //     ],\n      // };\n      // const container = document.getElementById('container');\n      // // Add a layout 及子元素\n      // const layoutBox = document.createElement('div');\n      // layoutBox.id = 'layoutBox';\n      // const layoutLeft = document.createElement('div');\n      // layoutLeft.id = 'layoutLeft';\n      // const layoutRight = document.createElement('div');\n      // layoutRight.id = 'layoutRight';\n      // // 设置layout样式\n      // layoutBox.style = \"height:100%;display:flex\"\n      // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n      // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n      // // 添加左侧元素\n      // const node = document.createElement('div');\n      // node.value = 'addNode'\n      // node.id = 'nodeId';\n      // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n      // // 添加样式元素到container\n      // layoutBox.appendChild(layoutLeft);\n      // layoutBox.appendChild(layoutRight);\n      // // container.appendChild(layoutBox);\n      // // 添加子元素到左侧\n      // layoutLeft.appendChild(node);\n      // // Add a selector to DOM\n      // const selector = document.createElement('select');\n      // selector.id = 'selector';\n      // selector.style.border = 'none';\n      // const selection1 = document.createElement('option');\n      // selection1.value = 'default';\n      // selection1.innerHTML = 'Default Mode';\n      // const selection2 = document.createElement('option');\n      // selection2.value = 'addNode';\n      // selection2.innerHTML = 'Add Node (By clicking canvas)';\n      // const selection3 = document.createElement('option');\n      // selection3.value = 'addEdge';\n      // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n      // selector.appendChild(selection1);\n      // selector.appendChild(selection2);\n      // selector.appendChild(selection3);\n      // container.appendChild(selector);\n      // const width = container.scrollWidth;\n      // const height = (container.scrollHeight || 500) - 30;\n      // const graph = new G6.Graph({\n      // container: 'container',\n      // width,\n      // height,\n      // // The sets of behavior modes\n      // modes: {\n      //     // Defualt mode\n      //     default: ['drag-node', 'click-select'],\n      //     // Adding node mode\n      //     addNode: ['click-add-node', 'click-select'],\n      //     // Adding edge mode\n      //     addEdge: ['click-add-edge', 'click-select'],\n      // },\n      // // The node styles in different states\n      // nodeStateStyles: {\n      //     // The node styles in selected state\n      //     selected: {\n      //         stroke: '#666',\n      //         lineWidth: 2,\n      //         fill: 'steelblue',\n      //     },\n      // },\n      // });\n      // graph.data(data);\n      // graph.render();\n      // // Listen to the selector, change the mode when the selector is changed\n      // selector.addEventListener('change', (e) => {\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // // 左侧长方形node元素点击事件\n      // node.addEventListener('click', (e) => {\n      //     console.log(e.target.value)\n      //     const value = e.target.value;\n      //     // change the behavior mode\n      //     graph.setMode(value);\n      // });\n      // if (typeof window !== 'undefined')\n      // window.onresize = () => {\n      //     if (!graph || graph.get('destroyed')) return;\n      //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n      //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n      // };\n      // ---------------------------------------------------------------------------------------\n      // G6.Util.processParallelEdges processes the edges with same source node and target node,\n      // on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\n      const processParallelEdgesOnAnchorPoint = (edges, offsetDiff = 15, multiEdgeType = 'quadratic', singleEdgeType = undefined, loopEdgeType = undefined) => {\n        const len = edges.length;\n        const cod = offsetDiff * 2;\n        const loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n        const edgeMap = {};\n        const tags = [];\n        const reverses = {};\n\n        for (let i = 0; i < len; i++) {\n          const edge = edges[i];\n          const {\n            source,\n            target,\n            sourceAnchor,\n            targetAnchor\n          } = edge;\n          const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n          if (tags[i]) continue;\n\n          if (!edgeMap[sourceTarget]) {\n            edgeMap[sourceTarget] = [];\n          }\n\n          tags[i] = true;\n          edgeMap[sourceTarget].push(edge);\n\n          for (let j = 0; j < len; j++) {\n            if (i === j) continue;\n            const sedge = edges[j];\n            const {\n              source: src,\n              target: dst,\n              sourceAnchor: srcAnchor,\n              targetAnchor: dstAnchor\n            } = sedge; // 两个节点之间共同的边\n            // 第一条的source = 第二条的target\n            // 第一条的target = 第二条的source\n\n            if (!tags[j]) {\n              if (source === dst && sourceAnchor === dstAnchor && target === src && targetAnchor === srcAnchor) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n                reverses[`${src}|${srcAnchor}|${dst}|${dstAnchor}|${edgeMap[sourceTarget].length - 1}`] = true;\n              } else if (source === src && sourceAnchor === srcAnchor && target === dst && targetAnchor === dstAnchor) {\n                edgeMap[sourceTarget].push(sedge);\n                tags[j] = true;\n              }\n            }\n          }\n        }\n\n        for (const key in edgeMap) {\n          const arcEdges = edgeMap[key];\n          const {\n            length\n          } = arcEdges;\n\n          for (let k = 0; k < length; k++) {\n            const current = arcEdges[k];\n\n            if (current.source === current.target) {\n              if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n              current.loopCfg = {\n                position: loopPosition[k % 8],\n                dist: Math.floor(k / 8) * 20 + 50\n              };\n              continue;\n            }\n\n            if (length === 1 && singleEdgeType && (current.source !== current.target || current.sourceAnchor !== current.targetAnchor)) {\n              current.type = singleEdgeType;\n              continue;\n            }\n\n            current.type = multiEdgeType;\n            const sign = (k % 2 === 0 ? 1 : -1) * (reverses[`${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`] ? -1 : 1);\n\n            if (length % 2 === 1) {\n              current.curveOffset = sign * Math.ceil(k / 2) * cod;\n            } else {\n              current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n            }\n          }\n        }\n\n        return edges;\n      };\n\n      const data = {\n        nodes: [{\n          id: 'node1',\n          x: 350,\n          y: 100\n        }, {\n          id: 'node2',\n          x: 350,\n          y: 250\n        }]\n      };\n      const descriptionDiv = document.createElement('div');\n      descriptionDiv.innerHTML = 'Hover the node and the anchor points will show up, click anchor points to create edges.';\n      const container = document.getElementById('container');\n      container.appendChild(descriptionDiv); // custom a node with anchor-point shapes\n\n      G6.registerNode('rect-node', {\n        // draw anchor-point circles according to the anchorPoints in afterDraw\n        afterDraw(cfg, group) {\n          const bbox = group.getBBox();\n          const anchorPoints = this.getAnchorPoints(cfg);\n          anchorPoints.forEach((anchorPos, i) => {\n            group.addShape('circle', {\n              attrs: {\n                r: 5,\n                x: bbox.x + bbox.width * anchorPos[0],\n                y: bbox.y + bbox.height * anchorPos[1],\n                fill: '#fff',\n                stroke: '#5F95FF'\n              },\n              name: `anchor-point`,\n              // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n              anchorPointIdx: i,\n              // flag the idx of the anchor-point circle\n              links: 0,\n              // cache the number of edges connected to this shape\n              visible: false // invisible by default, shows up when links > 1 or the node is in showAnchors state\n\n            });\n          });\n        },\n\n        getAnchorPoints(cfg) {\n          return cfg.anchorPoints || [[0, 0.5], [0.33, 0], [0.66, 0], [1, 0.5], [0.33, 1], [0.66, 1]];\n        },\n\n        // response the state changes and show/hide the link-point circles\n        setState(name, value, item) {\n          if (name === 'showAnchors') {\n            const anchorPoints = item.getContainer().findAll(ele => ele.get('name') === 'anchor-point');\n            anchorPoints.forEach(point => {\n              if (value || point.get('links') > 0) point.show();else point.hide();\n            });\n          }\n        }\n\n      }, 'rect');\n      let sourceAnchorIdx, targetAnchorIdx;\n      const width = container.scrollWidth;\n      const height = (container.scrollHeight || 500) - 20;\n      const graph = new G6.Graph({\n        container: 'container',\n        width,\n        height,\n        modes: {\n          default: ['drag-node', // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n          {\n            type: 'create-edge',\n            shouldBegin: e => {\n              // avoid beginning at other shapes on the node\n              if (e.target && e.target.get('name') !== 'anchor-point') return false;\n              sourceAnchorIdx = e.target.get('anchorPointIdx');\n              e.target.set('links', e.target.get('links') + 1); // cache the number of edge connected to this anchor-point circle\n\n              return true;\n            },\n            shouldEnd: e => {\n              // avoid ending at other shapes on the node\n              if (e.target && e.target.get('name') !== 'anchor-point') return false;\n\n              if (e.target) {\n                targetAnchorIdx = e.target.get('anchorPointIdx');\n                e.target.set('links', e.target.get('links') + 1); // cache the number of edge connected to this anchor-point circle\n\n                return true;\n              }\n\n              targetAnchorIdx = undefined;\n              return true;\n            } // update the sourceAnchor\n            // getEdgeConfig: () => {\n            //   return {\n            //     sourceAnchor: sourceAnchorIdx\n            //   }\n            // }\n\n          }]\n        },\n        defaultNode: {\n          type: 'rect-node',\n          style: {\n            fill: '#eee',\n            stroke: '#ccc'\n          }\n        },\n        defaultEdge: {\n          type: 'quadratic',\n          style: {\n            stroke: '#F6BD16',\n            lineWidth: 2\n          }\n        }\n      });\n      graph.data(data);\n      graph.render();\n      graph.on('aftercreateedge', e => {\n        // update the sourceAnchor and targetAnchor for the newly added edge\n        graph.updateItem(e.edge, {\n          sourceAnchor: sourceAnchorIdx,\n          targetAnchor: targetAnchorIdx\n        }); // update the curveOffset for parallel edges\n\n        const edges = graph.save().edges;\n        processParallelEdgesOnAnchorPoint(edges);\n        graph.getEdges().forEach((edge, i) => {\n          graph.updateItem(edge, {\n            curveOffset: edges[i].curveOffset,\n            curvePosition: edges[i].curvePosition\n          });\n        });\n      }); // if create-edge is canceled before ending, update the 'links' on the anchor-point circles\n\n      graph.on('afterremoveitem', e => {\n        if (e.item && e.item.source && e.item.target) {\n          const sourceNode = graph.findById(e.item.source);\n          const targetNode = graph.findById(e.item.target);\n          const {\n            sourceAnchor,\n            targetAnchor\n          } = e.item;\n\n          if (sourceNode && !isNaN(sourceAnchor)) {\n            const sourceAnchorShape = sourceNode.getContainer().find(ele => ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === sourceAnchor);\n            sourceAnchorShape.set('links', sourceAnchorShape.get('links') - 1);\n          }\n\n          if (targetNode && !isNaN(targetAnchor)) {\n            const targetAnchorShape = targetNode.getContainer().find(ele => ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === targetAnchor);\n            targetAnchorShape.set('links', targetAnchorShape.get('links') - 1);\n          }\n        }\n      }); // after clicking on the first node, the edge is created, update the sourceAnchor\n\n      graph.on('afteradditem', e => {\n        if (e.item && e.item.getType() === 'edge') {\n          graph.updateItem(e.item, {\n            sourceAnchor: sourceAnchorIdx\n          });\n        }\n      }); // some listeners to control the state of nodes to show and hide anchor-point circles\n\n      graph.on('node:mouseenter', e => {\n        graph.setItemState(e.item, 'showAnchors', true);\n      });\n      graph.on('node:mouseleave', e => {\n        graph.setItemState(e.item, 'showAnchors', false);\n      });\n      if (typeof window !== 'undefined') window.onresize = () => {\n        if (!graph || graph.get('destroyed')) return;\n        if (!container || !container.scrollWidth || !container.scrollHeight) return;\n        graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n      };\n    });\n  }\n\n});","map":{"version":3,"mappings":"AAMA,SAASA,eAAT,EAA0BC,SAA1B,QAA2C,KAA3C;AACA,OAAOC,EAAP,MAAe,UAAf;AACA,eAAeF,eAAe,CAAC;EAC3BG,IAAI,EAAE,MADqB;;EAE3BC,KAAK,GAAG;IAEJH,SAAS,CAAC,MAAK;MACX;;;MAGA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACZ;MACA,MAAMI,iCAAgC,GAAI,CACxCC,KADwC,EAExCC,UAAS,GAAI,EAF2B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","names":["defineComponent","onMounted","G6","name","setup","processParallelEdgesOnAnchorPoint","edges","offsetDiff","multiEdgeType","singleEdgeType","undefined","loopEdgeType","len","length","cod","loopPosition","edgeMap","tags","reverses","i","edge","source","target","sourceAnchor","targetAnchor","sourceTarget","push","j","sedge","src","dst","srcAnchor","dstAnchor","key","arcEdges","k","current","type","loopCfg","position","dist","Math","floor","sign","curveOffset","ceil","data","nodes","id","x","y","descriptionDiv","document","createElement","innerHTML","container","getElementById","appendChild","registerNode","afterDraw","cfg","group","bbox","getBBox","anchorPoints","getAnchorPoints","forEach","anchorPos","addShape","attrs","r","width","height","fill","stroke","anchorPointIdx","links","visible","setState","value","item","getContainer","findAll","ele","get","point","show","hide","sourceAnchorIdx","targetAnchorIdx","scrollWidth","scrollHeight","graph","Graph","modes","default","shouldBegin","e","set","shouldEnd","defaultNode","style","defaultEdge","lineWidth","render","on","updateItem","save","getEdges","curvePosition","sourceNode","findById","targetNode","isNaN","sourceAnchorShape","find","targetAnchorShape","getType","setItemState","window","onresize","changeSize"],"sourceRoot":"","sources":["/Users/wawalike/Desktop/ggProject/src/views/antv/index.vue"],"sourcesContent":["<template>\n    <div class=\"antv\">\n        <div id=\"container\"></div>\n    </div>\n</template>\n<script>\nimport { defineComponent, onMounted } from 'vue'\nimport G6 from '@antv/g6';\nexport default defineComponent({\n    name: 'antV',\n    setup() {\n        \n        onMounted(()=> {\n            /**\n             * 该案例演示切换交互模式，在不同模式下实现拖动节点、增加节点、增加边的交互行为。\n             */\n            // let addedCount = 0;\n            // // Register a custom behavior: add a node when user click the blank part of canvas\n            // G6.registerBehavior('click-add-node', {\n            //     // Set the events and the corresponding responsing function for this behavior\n            //     getEvents() {\n            //         // The event is canvas:click, the responsing function is onClick\n            //         return {\n            //         'canvas:click': 'onClick',\n            //         };\n            //     },\n            //     // Click event\n            //     onClick(ev) {\n            //         const self = this;\n            //         const graph = self.graph;\n            //         // Add a new node\n            //         graph.addItem('node', {\n            //         x: ev.canvasX,\n            //         y: ev.canvasY,\n            //         id: `node-${addedCount}`, // Generate the unique id\n            //         });\n            //         addedCount++;\n            //     },\n            // });\n            // // Register a custom behavior: click two end nodes to add an edge\n            // G6.registerBehavior('click-add-edge', {\n            //     // Set the events and the corresponding responsing function for this behavior\n            //     getEvents() {\n            //         return {\n            //         'node:click': 'onClick', // The event is canvas:click, the responsing function is onClick\n            //         mousemove: 'onMousemove', // The event is mousemove, the responsing function is onMousemove\n            //         'edge:click': 'onEdgeClick', // The event is edge:click, the responsing function is onEdgeClick\n            //         };\n            //     },\n            //     // The responsing function for node:click defined in getEvents\n            //     onClick(ev) {\n            //         // console.log(1111)\n            //         // console.log(this)\n            //         const self = this;\n            //         const node = ev.item;\n            //         const graph = self.graph;\n            //         // The position where the mouse clicks\n            //         const point = { x: ev.x, y: ev.y };\n            //         const model = node.getModel();\n            //         if (self.addingEdge && self.edge) {\n            //         graph.updateItem(self.edge, {\n            //             target: model.id,\n            //         });\n    \n            //         self.edge = null;\n            //         self.addingEdge = false;\n            //         } else {\n            //         // Add anew edge, the end node is the current node user clicks\n            //         self.edge = graph.addItem('edge', {\n            //             source: model.id,\n            //             target: model.id,\n            //         });\n            //         self.addingEdge = true;\n            //         }\n            //     },\n            //     // The responsing function for mousemove defined in getEvents\n            //     onMousemove(ev) {\n            //         const self = this;\n            //         // The current position the mouse clicks\n            //         const point = { x: ev.x, y: ev.y };\n            //         if (self.addingEdge && self.edge) {\n            //         // Update the end node to the current node the mouse clicks\n            //         self.graph.updateItem(self.edge, {\n            //             target: point,\n            //         });\n            //         }\n            //     },\n            //     // The responsing function for edge:click defined in getEvents\n            //     onEdgeClick(ev) {\n            //         const self = this;\n            //         const currentEdge = ev.item;\n            //         if (self.addingEdge && self.edge === currentEdge) {\n            //         self.graph.removeItem(self.edge);\n            //         self.edge = null;\n            //         self.addingEdge = false;\n            //         }\n            //     },\n            // });\n            // // Initial data\n            // const data = {\n            //     nodes: [\n            //         {\n            //         id: 'node1',\n            //         x: 100,\n            //         y: 200,\n            //         },\n            //         {\n            //         id: 'node2',\n            //         x: 300,\n            //         y: 200,\n            //         },\n            //         {\n            //         id: 'node3',\n            //         x: 300,\n            //         y: 300,\n            //         },\n            //     ],\n            //     edges: [\n            //         {\n            //         id: 'edge1',\n            //         target: 'node2',\n            //         source: 'node1',\n            //         },\n            //     ],\n            // };\n    \n            // const container = document.getElementById('container');\n            // // Add a layout 及子元素\n            // const layoutBox = document.createElement('div');\n            // layoutBox.id = 'layoutBox';\n            // const layoutLeft = document.createElement('div');\n            // layoutLeft.id = 'layoutLeft';\n            // const layoutRight = document.createElement('div');\n            // layoutRight.id = 'layoutRight';\n            // // 设置layout样式\n            // layoutBox.style = \"height:100%;display:flex\"\n            // layoutLeft.style = \"width: 300px;height:100%;border:1px solid #ddd;border-radius:6px;padding:20px\";\n            // layoutRight.style = \"flex:1;height:100%;border:1px solid #ddd;border-radius:6px;margin-left:10px\";\n            // // 添加左侧元素\n            // const node = document.createElement('div');\n            // node.value = 'addNode'\n            // node.id = 'nodeId';\n            // node.style = 'width: 100px;height: 50px;margin: 0 auto;border:1px solid #ddd;border-radius:4px;cursor:pointer'\n            // // 添加样式元素到container\n            // layoutBox.appendChild(layoutLeft);\n            // layoutBox.appendChild(layoutRight);\n            // // container.appendChild(layoutBox);\n            // // 添加子元素到左侧\n            // layoutLeft.appendChild(node);\n            // // Add a selector to DOM\n            // const selector = document.createElement('select');\n            // selector.id = 'selector';\n            // selector.style.border = 'none';\n            // const selection1 = document.createElement('option');\n            // selection1.value = 'default';\n            // selection1.innerHTML = 'Default Mode';\n            // const selection2 = document.createElement('option');\n            // selection2.value = 'addNode';\n            // selection2.innerHTML = 'Add Node (By clicking canvas)';\n            // const selection3 = document.createElement('option');\n            // selection3.value = 'addEdge';\n            // selection3.innerHTML = 'Add Edge (By clicking two end nodes)';\n            // selector.appendChild(selection1);\n            // selector.appendChild(selection2);\n            // selector.appendChild(selection3);\n            // container.appendChild(selector);\n    \n            // const width = container.scrollWidth;\n            // const height = (container.scrollHeight || 500) - 30;\n            // const graph = new G6.Graph({\n            // container: 'container',\n            // width,\n            // height,\n            // // The sets of behavior modes\n            // modes: {\n            //     // Defualt mode\n            //     default: ['drag-node', 'click-select'],\n            //     // Adding node mode\n            //     addNode: ['click-add-node', 'click-select'],\n            //     // Adding edge mode\n            //     addEdge: ['click-add-edge', 'click-select'],\n            // },\n            // // The node styles in different states\n            // nodeStateStyles: {\n            //     // The node styles in selected state\n            //     selected: {\n            //         stroke: '#666',\n            //         lineWidth: 2,\n            //         fill: 'steelblue',\n            //     },\n            // },\n            // });\n            // graph.data(data);\n            // graph.render();\n    \n            // // Listen to the selector, change the mode when the selector is changed\n            // selector.addEventListener('change', (e) => {\n            //     const value = e.target.value;\n            //     // change the behavior mode\n            //     graph.setMode(value);\n            // });\n            // // 左侧长方形node元素点击事件\n            // node.addEventListener('click', (e) => {\n            //     console.log(e.target.value)\n            //     const value = e.target.value;\n            //     // change the behavior mode\n            //     graph.setMode(value);\n            // });\n    \n            // if (typeof window !== 'undefined')\n            // window.onresize = () => {\n            //     if (!graph || graph.get('destroyed')) return;\n            //     if (!container || !container.scrollWidth || !container.scrollHeight) return;\n            //     graph.changeSize(container.scrollWidth, container.scrollHeight - 30);\n            // };\n            // ---------------------------------------------------------------------------------------\n            // G6.Util.processParallelEdges processes the edges with same source node and target node,\n// on this basis, processParallelEdgesOnAnchorPoint consider the end nodes and anchor points in the same time.\nconst processParallelEdgesOnAnchorPoint = (\n  edges,\n  offsetDiff = 15,\n  multiEdgeType = 'quadratic',\n  singleEdgeType = undefined,\n  loopEdgeType = undefined\n) => {\n  const len = edges.length;\n  const cod = offsetDiff * 2;\n  const loopPosition = [\n    'top',\n    'top-right',\n    'right',\n    'bottom-right',\n    'bottom',\n    'bottom-left',\n    'left',\n    'top-left',\n  ];\n  const edgeMap = {};\n  const tags = [];\n  const reverses = {};\n  for (let i = 0; i < len; i++) {\n    const edge = edges[i];\n    const { source, target, sourceAnchor, targetAnchor } = edge;\n    const sourceTarget = `${source}|${sourceAnchor}-${target}|${targetAnchor}`;\n\n    if (tags[i]) continue;\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n    for (let j = 0; j < len; j++) {\n      if (i === j) continue;\n      const sedge = edges[j];\n      const { source: src, target: dst, sourceAnchor: srcAnchor, targetAnchor: dstAnchor } = sedge;\n\n      // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n      if (!tags[j]) {\n        if (source === dst && sourceAnchor === dstAnchor\n            && target === src && targetAnchor === srcAnchor) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[`${src}|${srcAnchor}|${dst}|${dstAnchor}|${edgeMap[sourceTarget].length - 1}`] = true;\n        } else if (source === src && sourceAnchor === srcAnchor\n           && target === dst  && targetAnchor === dstAnchor) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (const key in edgeMap) {\n    const arcEdges = edgeMap[key];\n    const { length } = arcEdges;\n    for (let k = 0; k < length; k++) {\n      const current = arcEdges[k];\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType;\n        // 超过8条自环边，则需要重新处理\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50,\n        };\n        continue;\n      }\n      if (length === 1 && singleEdgeType && (current.source !== current.target || current.sourceAnchor !== current.targetAnchor)) {\n        current.type = singleEdgeType;\n        continue;\n      }\n      current.type = multiEdgeType;\n      const sign =\n        (k % 2 === 0 ? 1 : -1) * (reverses[`${current.source}|${current.sourceAnchor}|${current.target}|${current.targetAnchor}|${k}`] ? -1 : 1);\n      if (length % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n  return edges;\n};\n\n\nconst data = {\n  nodes: [\n    { id: 'node1', x: 350, y: 100 },\n    { id: 'node2', x: 350, y: 250 },\n  ],\n};\nconst descriptionDiv = document.createElement('div');\ndescriptionDiv.innerHTML = 'Hover the node and the anchor points will show up, click anchor points to create edges.';\nconst container = document.getElementById('container');\ncontainer.appendChild(descriptionDiv);\n\n// custom a node with anchor-point shapes\nG6.registerNode('rect-node', {\n  // draw anchor-point circles according to the anchorPoints in afterDraw\n  afterDraw(cfg, group) {\n    const bbox = group.getBBox();\n    const anchorPoints = this.getAnchorPoints(cfg)\n    anchorPoints.forEach((anchorPos, i) => {\n      group.addShape('circle', {\n        attrs: {\n          r: 5,\n          x: bbox.x + bbox.width * anchorPos[0],\n          y: bbox.y + bbox.height * anchorPos[1],\n          fill: '#fff',\n          stroke: '#5F95FF'\n        },\n        name: `anchor-point`, // the name, for searching by group.find(ele => ele.get('name') === 'anchor-point')\n        anchorPointIdx: i, // flag the idx of the anchor-point circle\n        links: 0, // cache the number of edges connected to this shape\n        visible: false, // invisible by default, shows up when links > 1 or the node is in showAnchors state\n      })\n    })\n  },\n  getAnchorPoints(cfg) {\n    return cfg.anchorPoints || [[0, 0.5], [0.33, 0], [0.66, 0], [1, 0.5], [0.33, 1], [0.66, 1]];\n  },\n  // response the state changes and show/hide the link-point circles\n  setState(name, value, item) {\n    if (name === 'showAnchors') {\n      const anchorPoints = item.getContainer().findAll(ele => ele.get('name') === 'anchor-point');\n      anchorPoints.forEach(point => {\n        if (value || point.get('links') > 0) point.show()\n        else point.hide()\n      })\n    }\n  }\n}, 'rect')\n\nlet sourceAnchorIdx, targetAnchorIdx;\n\nconst width = container.scrollWidth;\nconst height = (container.scrollHeight || 500) - 20;\nconst graph = new G6.Graph({\n  container: 'container',\n  width,\n  height,\n  modes: {\n    default: [\n      'drag-node',\n      // config the shouldBegin and shouldEnd to make sure the create-edge is began and ended at anchor-point circles\n      {\n      type: 'create-edge',\n      shouldBegin: e => {\n        // avoid beginning at other shapes on the node\n        if (e.target && e.target.get('name') !== 'anchor-point') return false;\n        sourceAnchorIdx = e.target.get('anchorPointIdx');\n        e.target.set('links', e.target.get('links') + 1); // cache the number of edge connected to this anchor-point circle\n        return true;\n      },\n      shouldEnd: e => {\n        // avoid ending at other shapes on the node\n        if (e.target && e.target.get('name') !== 'anchor-point') return false;\n        if (e.target) {\n          targetAnchorIdx = e.target.get('anchorPointIdx');\n          e.target.set('links', e.target.get('links') + 1);  // cache the number of edge connected to this anchor-point circle\n          return true;\n        }\n        targetAnchorIdx = undefined;\n        return true;\n      },\n      // update the sourceAnchor\n      // getEdgeConfig: () => {\n      //   return {\n      //     sourceAnchor: sourceAnchorIdx\n      //   }\n      // }\n    }],\n  },\n  defaultNode: {\n    type: 'rect-node',\n    style: {\n      fill: '#eee',\n      stroke: '#ccc',\n    }\n  },\n  defaultEdge: {\n    type: 'quadratic',\n    style: {\n      stroke: '#F6BD16',\n      lineWidth: 2,\n    },\n  },\n});\n\ngraph.data(data);\ngraph.render();\n\ngraph.on('aftercreateedge', (e) => {\n  // update the sourceAnchor and targetAnchor for the newly added edge\n  graph.updateItem(e.edge, {\n    sourceAnchor: sourceAnchorIdx,\n    targetAnchor: targetAnchorIdx\n  })\n\n  // update the curveOffset for parallel edges\n  const edges = graph.save().edges;\n  processParallelEdgesOnAnchorPoint(edges);\n  graph.getEdges().forEach((edge, i) => {\n    graph.updateItem(edge, {\n      curveOffset: edges[i].curveOffset,\n      curvePosition: edges[i].curvePosition,\n    });\n  });\n});\n\n// if create-edge is canceled before ending, update the 'links' on the anchor-point circles\ngraph.on('afterremoveitem', e => {\n  if (e.item && e.item.source && e.item.target) {\n    const sourceNode = graph.findById(e.item.source);\n    const targetNode = graph.findById(e.item.target);\n    const { sourceAnchor, targetAnchor } = e.item;\n    if (sourceNode && !isNaN(sourceAnchor)) {\n      const sourceAnchorShape = sourceNode.getContainer().find(ele => (ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === sourceAnchor));\n      sourceAnchorShape.set('links', sourceAnchorShape.get('links') - 1);\n    }\n    if (targetNode && !isNaN(targetAnchor)) {\n      const targetAnchorShape = targetNode.getContainer().find(ele => (ele.get('name') === 'anchor-point' && ele.get('anchorPointIdx') === targetAnchor));\n      targetAnchorShape.set('links', targetAnchorShape.get('links') - 1);\n    }\n  }\n})\n\n// after clicking on the first node, the edge is created, update the sourceAnchor\ngraph.on('afteradditem', e => {\n  if (e.item && e.item.getType() === 'edge') {\n    graph.updateItem(e.item, {\n      sourceAnchor: sourceAnchorIdx\n    });\n  }\n})\n\n\n// some listeners to control the state of nodes to show and hide anchor-point circles\ngraph.on('node:mouseenter', e => {\n  graph.setItemState(e.item, 'showAnchors', true);\n})\ngraph.on('node:mouseleave', e => {\n  graph.setItemState(e.item, 'showAnchors', false);\n})\n\nif (typeof window !== 'undefined')\n  window.onresize = () => {\n    if (!graph || graph.get('destroyed')) return;\n    if (!container || !container.scrollWidth || !container.scrollHeight) return;\n    graph.changeSize(container.scrollWidth, container.scrollHeight - 20);\n  };\n        })\n    },\n})\n</script>\n<style lang=\"less\" scoped>\n.antv {\n    height: 100%;\n    // border: 1px solid #ddd;\n    border-radius: 6px;\n    #container {\n        height: 100%;\n    }\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}